#!/usr/bin/env python3

import argparse
import json
import logging
import traceback
from pathlib import Path

from .beepobjs import BeepSeed
from .cpmeta import CPMetadata
from .llm import LLMClient
from .redis import RedisCacheClient
from .sinkpoint_beep import SinkpointExpTool
from .utils import CRS_ERR_LOG, CRS_WARN_LOG

CRS_ERR = CRS_ERR_LOG("exploit")
CRS_WARN = CRS_WARN_LOG("exploit")


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


try:
    from libCRS.otel import install_otel_logger

    install_otel_logger(action_name="crs-java:expkit")
except Exception as e:
    print(f"{CRS_ERR} Failed to install OpenTelemetry logger: {e}.")


def parse_model_weights(models_str: str) -> list:
    """Parse a string of model:weight pairs into a weighted list.

    Format: "model1:weight1,model2:weight2,..."
    Example: "gpt-4o:10,o1-preview:20,none:10"

    Returns a list with models repeated according to their weights.
    """
    if not models_str:
        return []

    result = []
    try:
        for pair in models_str.split(","):
            if ":" not in pair:
                logger.warning(
                    f"{CRS_ERR} Invalid model:weight pair: {pair}, expected format 'model:weight'"
                )
                continue

            model, weight_str = pair.split(":", 1)
            try:
                weight = int(weight_str)
                if weight <= 0:
                    logger.warning(
                        f"{CRS_ERR} Invalid weight {weight} for model {model}, must be positive"
                    )
                    continue
                result.extend([model.strip()] * weight)
            except ValueError:
                logger.warning(
                    f"{CRS_ERR} Invalid weight value: {weight_str}, must be an integer"
                )
    except Exception as e:
        logger.error(f"{CRS_ERR} parsing model weights: {e}")

    return result


def run(
    beepseed_path: str,
    output_path: str,
    metadata_path: str,
    exp_time: int = 300,
    verbose: bool = False,
    workdir: str = None,
    gen_models_str: str = None,
    x_models_str: str = None,
):
    """Run the appropriate exploitation based on BeepSeed type"""
    # TODO: extend beepseed types and exploit tools
    try:
        workdir_path = Path(workdir) if workdir else None

        gen_models = parse_model_weights(gen_models_str)
        logger.info(f"Generation models distribution: {gen_models}")

        x_models = parse_model_weights(x_models_str)
        logger.info(f"Extraction models distribution: {x_models}")

        exp_tool = SinkpointExpTool(
            llm_client=LLMClient(verbose=verbose),
            redis_client=RedisCacheClient(),
            beepseed=BeepSeed.frm_beep_file(beepseed_path),
            exp_time=exp_time,
            cp_meta=CPMetadata(metadata_path),
            workdir=workdir_path,
            gen_models=gen_models,
            x_models=x_models,
        )

        result = exp_tool.exploit()

    except Exception as e:
        err_str = f"Exception: {e}\n{traceback.format_exc()}"
        logger.error(f"{CRS_ERR} Exploitation failed with {err_str}")
        result = {"status": False, "error": err_str}

    finally:
        try:
            with open(output_path, "w") as f:
                json.dump(result, f, indent=2, sort_keys=True)
            logger.info(f"Result saved to {output_path}")
        except Exception as e:
            logger.error(
                f"{CRS_ERR} Failed to save result: {e} with traceback:\n{traceback.format_exc()}"
            )

        logger.info("Exploitation completed.")


def main():
    """Main entry point for the exploit tool"""
    parser = argparse.ArgumentParser(description="BEEP seed exploitation tool")
    parser.add_argument("beepseed", help="Path to the BEEP seed JSON file")
    parser.add_argument("output", help="Path to save the exploitation result")
    parser.add_argument(
        "--metadata", required=True, help="Path to the CP metadata JSON file"
    )
    parser.add_argument(
        "--exp-time",
        type=int,
        default=300,
        help="Time limit for exploitation in seconds",
    )
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")
    parser.add_argument(
        "--workdir", default=None, help="Working directory for exploitation artifacts"
    )
    parser.add_argument(
        "--gen-models",
        default="o1-preview:1,claude-3-7-sonnet-20250219:1",
        help="Comma-separated list of generation models with weights. Format: 'model1:weight1,model2:weight2,...'. Example: 'o1-preview:10,claude-3-7-sonnet-20250219:20,none:5'",
    )
    parser.add_argument(
        "--x-models",
        default="gpt-4o:1,o3-mini:1",
        help="Comma-separated list of extraction models with weights. Format: 'model1:weight1,model2:weight2,...'. Example: 'gpt-4o:10,o3-mini:20,none:5'",
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    run(
        args.beepseed,
        args.output,
        args.metadata,
        args.exp_time,
        args.verbose,
        args.workdir,
        args.gen_models,
        args.x_models,
    )


if __name__ == "__main__":
    main()
