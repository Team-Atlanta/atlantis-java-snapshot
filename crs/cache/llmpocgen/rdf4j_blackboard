{
    "sinks": {
        "Server Side Request Forgery (SSRF)": [
            {
                "path": "src/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFLoader.java",
                "line": 146,
                "column": 25
            },
            {
                "path": "src/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPRepositoryConnection.java",
                "line": 424,
                "column": 20
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 438,
                "column": 32
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/xml/DocumentUtil.java",
                "line": 95,
                "column": 33
            },
            {
                "path": "src/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/SPARQLProtocolSession.java",
                "line": 1094,
                "column": 46
            }
        ],
        "load arbitrary library": [
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/xml/XMLReaderFactory.java",
                "line": 137,
                "column": 35
            }
        ],
        "Regular Expression Injection": [
            {
                "path": "src/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/RDF4JProtocolSession.java",
                "line": 155,
                "column": 40
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 460,
                "column": 46
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 468,
                "column": 46
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 476,
                "column": 46
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 500,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 518,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 536,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 554,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 572,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 590,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 608,
                "column": 21
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/datatypes/XMLDatatypeUtil.java",
                "line": 626,
                "column": 32
            },
            {
                "path": "src/rdf4j/model/src/main/java/org/eclipse/rdf4j/model/util/URIUtil.java",
                "line": 153,
                "column": 35
            },
            {
                "path": "src/rdf4j/queryparser/sparql/src/main/java/org/eclipse/rdf4j/query/parser/sparql/PrefixDeclProcessor.java",
                "line": 173,
                "column": 6
            },
            {
                "path": "src/rdf4j/queryparser/sparql/src/main/java/org/eclipse/rdf4j/query/parser/sparql/TupleExprBuilder.java",
                "line": 186,
                "column": 78
            },
            {
                "path": "src/rdf4j/queryparser/sparql/src/main/java/org/eclipse/rdf4j/query/parser/sparql/TupleExprBuilder.java",
                "line": 891,
                "column": 75
            },
            {
                "path": "src/rdf4j/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/BaseTupleExprRenderer.java",
                "line": 194,
                "column": 29
            },
            {
                "path": "src/rdf4j/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/RenderUtils.java",
                "line": 147,
                "column": 36
            },
            {
                "path": "src/rdf4j/queryrender/src/main/java/org/eclipse/rdf4j/queryrender/RenderUtils.java",
                "line": 150,
                "column": 38
            },
            {
                "path": "src/rdf4j/queryresultio/text/src/main/java/org/eclipse/rdf4j/query/resultio/text/csv/SPARQLResultsCSVWriter.java",
                "line": 199,
                "column": 29
            },
            {
                "path": "src/rdf4j/queryresultio/text/src/main/java/org/eclipse/rdf4j/query/resultio/text/tsv/SPARQLResultsTSVParser.java",
                "line": 60,
                "column": 37
            },
            {
                "path": "src/rdf4j/queryresultio/text/src/main/java/org/eclipse/rdf4j/query/resultio/text/tsv/SPARQLResultsTSVParser.java",
                "line": 77,
                "column": 42
            },
            {
                "path": "src/rdf4j/queryresultio/text/src/main/java/org/eclipse/rdf4j/query/resultio/text/tsv/SPARQLResultsTSVWriter.java",
                "line": 209,
                "column": 49
            },
            {
                "path": "src/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/config/ConfigTemplate.java",
                "line": 69,
                "column": 72
            },
            {
                "path": "src/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/config/ConfigTemplate.java",
                "line": 98,
                "column": 72
            },
            {
                "path": "src/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPRepository.java",
                "line": 104,
                "column": 40
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java",
                "line": 67,
                "column": 32
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java",
                "line": 73,
                "column": 30
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java",
                "line": 123,
                "column": 26
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/SPARQLOperation.java",
                "line": 111,
                "column": 25
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/SPARQLOperation.java",
                "line": 130,
                "column": 32
            },
            {
                "path": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/SPARQLOperation.java",
                "line": 131,
                "column": 30
            },
            {
                "path": "src/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/AbstractRDFParser.java",
                "line": 787,
                "column": 50
            },
            {
                "path": "src/rdf4j/rio/datatypes/src/main/java/org/eclipse/rdf4j/rio/datatypes/VirtuosoGeometryDatatypeHandler.java",
                "line": 94,
                "column": 39
            },
            {
                "path": "src/rdf4j/rio/languages/src/main/java/org/eclipse/rdf4j/rio/languages/RFC3066LanguageHandler.java",
                "line": 32,
                "column": 52
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java",
                "line": 1337,
                "column": 82
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java",
                "line": 1415,
                "column": 31
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java",
                "line": 1416,
                "column": 33
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/text/StringUtil.java",
                "line": 142,
                "column": 39
            }
        ],
        "File read/write hook path": [
            {
                "path": "src/rdf4j/repository/manager/src/main/java/org/eclipse/rdf4j/repository/manager/LocalRepositoryManager.java",
                "line": 445,
                "column": 30
            },
            {
                "path": "src/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFLoader.java",
                "line": 93,
                "column": 45
            },
            {
                "path": "src/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPRepositoryConnection.java",
                "line": 392,
                "column": 40
            },
            {
                "path": "src/rdf4j/repository/manager/src/main/java/org/eclipse/rdf4j/repository/manager/LocalRepositoryManager.java",
                "line": 331,
                "column": 49
            },
            {
                "path": "src/rdf4j/repository/manager/src/main/java/org/eclipse/rdf4j/repository/manager/LocalRepositoryManager.java",
                "line": 438,
                "column": 51
            },
            {
                "path": "src/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/Rio.java",
                "line": 707,
                "column": 58
            },
            {
                "path": "src/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/Rio.java",
                "line": 708,
                "column": 52
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/FileUtil.java",
                "line": 163,
                "column": 29
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 40,
                "column": 44
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 174,
                "column": 44
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 284,
                "column": 45
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 339,
                "column": 47
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 387,
                "column": 47
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 405,
                "column": 35
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 417,
                "column": 47
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 493,
                "column": 47
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java",
                "line": 542,
                "column": 38
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/ResourceUtil.java",
                "line": 228,
                "column": 43
            },
            {
                "path": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/xml/SimpleSAXParser.java",
                "line": 174,
                "column": 40
            }
        ]
    },
    "tasks": [
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/trix/src/main/java/org/eclipse/rdf4j/rio/trix/TriXParser.java:\n112   \t@Override\n113   \tpublic void parse(InputStream in, String baseURI)\n114   \t\tthrows IOException, RDFParseException, RDFHandlerException\n115   \t{\n116   \t\tif (in == null) {\n117   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n118   \t\t}\n119   \t\tif (baseURI == null) {\n120   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n121   \t\t}\n122   \n123   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n124   \t\tinputSource.setSystemId(baseURI);\n125   \n126   \t\tparse(inputSource);\n127   \t}\n163   \tprivate void parse(InputSource inputStreamOrReader)\n164   \t\tthrows IOException, RDFParseException, RDFHandlerException\n165   \t{\n166   \t\tclear();\n167   \t\t\n168   \t\ttry {\n169   \t\t\tif (rdfHandler != null) {\n170   \t\t\t\trdfHandler.startRDF();\n171   \t\t\t}\n172   \n173   \t\t\tXMLReader xmlReader;\n174   \n175   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n176   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n177   \t\t\t}\n178   \t\t\telse {\n179   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n180   \t\t\t}\n181   \n182   \t\t\txmlReader.setErrorHandler(this);\n183   \n184   \t\t\tsaxParser = new SimpleSAXParser(xmlReader);\n185   \t\t\tsaxParser.setPreserveWhitespace(true);\n186   \t\t\tsaxParser.setListener(new TriXSAXHandler());\n187   \n188   \t\t\tsaxParser.parse(inputStreamOrReader);\n189   \t\t}\n190   \t\tcatch (SAXParseException e) {\n191   \t\t\tException wrappedExc = e.getException();\n192   \n193   \t\t\tif (wrappedExc == null) {\n194   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n195   \t\t\t}\n196   \t\t\telse {\n197   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n198   \t\t\t}\n199   \t\t}\n200   \t\tcatch (SAXException e) {\n201   \t\t\tException wrappedExc = e.getException();\n202   \n203   \t\t\tif (wrappedExc == null) {\n204   \t\t\t\treportFatalError(e);\n205   \t\t\t}\n206   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n207   \t\t\t\tthrow (RDFParseException)wrappedExc;\n208   \t\t\t}\n209   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n210   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n211   \t\t\t}\n212   \t\t\telse {\n213   \t\t\t\treportFatalError(wrappedExc);\n214   \t\t\t}\n215   \t\t}\n216   \t\tfinally {\n217   \t\t\tclear();\n218   \t\t}\n219   \n220   \t\tif (rdfHandler != null) {\n221   \t\t\trdfHandler.endRDF();\n222   \t\t}\n223   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java:\n 87   \tprivate void processBuffer()\n 88   \t\tthrows RDFHandlerException\n 89   \t{\n 90   \t\t// primary grouping per context.\n 91   \t\tfor (Resource context : contexts) {\n 92   \t\t\tSet<Resource> subjects = GraphUtil.getSubjects(bufferedStatements, null, null, context);\n 93   \t\t\tfor (Resource subject : subjects) {\n 94   \t\t\t\tSet<IRI> processedPredicates = new HashSet<IRI>();\n 95   \n 96   \t\t\t\t// give rdf:type preference over other predicates.\n 97   \t\t\t\tIterator<Statement> typeStatements = bufferedStatements.match(subject, RDF.TYPE, null,\n 98   \t\t\t\t\t\tcontext);\n 99   \t\t\t\twhile (typeStatements.hasNext()) {\n100   \t\t\t\t\tStatement typeStatement = typeStatements.next();\n101   \t\t\t\t\tsuper.handleStatement(typeStatement);\n102   \t\t\t\t}\n103   \n104   \t\t\t\tprocessedPredicates.add(RDF.TYPE);\n105   \n106   \t\t\t\t// retrieve other statement from this context with the same\n107   \t\t\t\t// subject, and output them grouped by predicate\n108   \t\t\t\tIterator<Statement> subjectStatements = bufferedStatements.match(subject, null, null,\n109   \t\t\t\t\t\tcontext);\n110   \t\t\t\twhile (subjectStatements.hasNext()) {\n111   \t\t\t\t\tStatement subjectStatement = subjectStatements.next();\n112   \t\t\t\t\tIRI predicate = subjectStatement.getPredicate();\n113   \t\t\t\t\tif (!processedPredicates.contains(predicate)) {\n114   \t\t\t\t\t\tIterator<Statement> toWrite = bufferedStatements.match(subject, predicate, null,\n115   \t\t\t\t\t\t\t\tcontext);\n116   \t\t\t\t\t\twhile (toWrite.hasNext()) {\n117   \t\t\t\t\t\t\tStatement toWriteSt = toWrite.next();\n118   \t\t\t\t\t\t\tsuper.handleStatement(toWriteSt);\n119   \t\t\t\t\t\t}\n120   \t\t\t\t\t\tprocessedPredicates.add(predicate);\n121   \t\t\t\t\t}\n122   \t\t\t\t}\n123   \t\t\t}\n124   \t\t}\n125   \t\tbufferedStatements.clear();\n126   \t\tcontexts.clear();\n127   \t}\n129   \t@Override\n130   \tpublic void endRDF()\n131   \t\tthrows RDFHandlerException\n132   \t{\n133   \t\tsynchronized (bufferLock) {\n134   \t\t\tprocessBuffer();\n135   \t\t}\n136   \t\tsuper.endRDF();\n137   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/RDFHandlerWrapper.java:\n77   \tpublic void handleStatement(Statement st)\n78   \t\tthrows RDFHandlerException\n79   \t{\n80   \t\tfor (RDFHandler rdfHandler : rdfHandlers) {\n81   \t\t\trdfHandler.handleStatement(st);\n82   \t\t}\n83   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFRemover.java:\n 96   \t@Override\n 97   \tpublic void handleStatement(Statement st)\n 98   \t\tthrows RDFHandlerException\n 99   \t{\n100   \t\ttry {\n101   \t\t\tif (enforceContext) {\n102   \t\t\t\t// Override supplied context info\n103   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), context);\n104   \t\t\t}\n105   \t\t\telse {\n106   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), st.getContext());\n107   \t\t\t}\n108   \t\t}\n109   \t\tcatch (RepositoryException e) {\n110   \t\t\tthrow new RDFHandlerException(e);\n111   \t\t}\n112   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/base/AbstractRepositoryConnection.java:\n580   \t@Override\n581   \tpublic void remove(Resource subject, IRI predicate, Value object, Resource... contexts)\n582   \t\tthrows RepositoryException\n583   \t{\n584   \t\tboolean localTransaction = startLocalTransaction();\n585   \n586   \t\tOpenRDFUtil.verifyContextNotNull(contexts);\n587   \t\tremoveWithoutCommit(subject, predicate, object, contexts);\n588   \n589   \t\tconditionalCommit(localTransaction);\n590   \t}\n\nsrc/rdf4j/repository/contextaware/src/main/java/org/eclipse/rdf4j/repository/contextaware/ContextAwareConnection.java:\n842   \t@Override\n843   \tprotected void removeWithoutCommit(Resource subject, IRI predicate, Value object, Resource... contexts)\n844   \t\tthrows RepositoryException\n845   \t{\n846   \t\tIRI[] archiveContexts = getArchiveContexts();\n847   \t\tif (archiveContexts.length > 0) {\n848   \t\t\tRDFHandler handler = new RDFInserter(getDelegate());\n849   \t\t\ttry {\n850   \t\t\t\tgetDelegate().exportStatements(subject, predicate, object, true, handler, archiveContexts);\n851   \t\t\t}\n852   \t\t\tcatch (RDFHandlerException e) {\n853   \t\t\t\tif (e.getCause() instanceof RepositoryException) {\n854   \t\t\t\t\tthrow (RepositoryException)e.getCause();\n855   \t\t\t\t}\n856   \t\t\t\tthrow new AssertionError(e);\n857   \t\t\t}\n858   \t\t}\n859   \t\tif (isAllContext(contexts)) {\n860   \t\t\tgetDelegate().remove(subject, predicate, object, getRemoveContexts());\n861   \t\t}\n862   \t\telse {\n863   \t\t\tgetDelegate().remove(subject, predicate, object, contexts);\n864   \t\t}\n865   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/SPARQLConnection.java:\n 132   \tpublic void exportStatements(Resource subj, IRI pred, Value obj, boolean includeInferred,\n 133   \t\t\tRDFHandler handler, Resource... contexts)\n 134   \t\tthrows RepositoryException, RDFHandlerException\n 135   \t{\n 136   \t\ttry {\n 137   \t\t\tGraphQuery query = prepareGraphQuery(SPARQL, EVERYTHING, \"\");\n 138   \t\t\tsetBindings(query, subj, pred, obj, contexts);\n 139   \t\t\tquery.evaluate(handler);\n 140   \t\t}\n 141   \t\tcatch (MalformedQueryException e) {\n 142   \t\t\tthrow new RepositoryException(e);\n 143   \t\t}\n 144   \t\tcatch (QueryEvaluationException e) {\n 145   \t\t\tthrow new RepositoryException(e);\n 146   \t\t}\n 147   \t}\n\nsrc/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPGraphQuery.java:\n73   \tpublic void evaluate(RDFHandler handler)\n74   \t\tthrows QueryEvaluationException, RDFHandlerException\n75   \t{\n76   \t\tSPARQLProtocolSession client = getHttpClient();\n77   \t\ttry {\n78   \t\t\tconn.flushTransactionState(Protocol.Action.QUERY);\n79   \t\t\tclient.sendGraphQuery(queryLanguage, queryString, baseURI, dataset, includeInferred,\n80   \t\t\t\t\tgetMaxExecutionTime(), handler, getBindingsArray());\n81   \t\t}\n82   \t\tcatch (IOException e) {\n83   \t\t\tthrow new HTTPQueryEvaluationException(e.getMessage(), e);\n84   \t\t}\n85   \t\tcatch (RepositoryException e) {\n86   \t\t\tthrow new HTTPQueryEvaluationException(e.getMessage(), e);\n87   \t\t}\n88   \t\tcatch (MalformedQueryException e) {\n89   \t\t\tthrow new HTTPQueryEvaluationException(e.getMessage(), e);\n90   \t\t}\n91   \t}\n\nsrc/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/SPARQLProtocolSession.java:\n 456   \tpublic void sendGraphQuery(QueryLanguage ql, String query, String baseURI, Dataset dataset,\n 457   \t\t\tboolean includeInferred, int maxQueryTime, RDFHandler handler, Binding... bindings)\n 458   \t\tthrows IOException, RDFHandlerException, RepositoryException, MalformedQueryException,\n 459   \t\tUnauthorizedException, QueryInterruptedException\n 460   \t{\n 461   \t\tHttpUriRequest method = getQueryMethod(ql, query, baseURI, dataset, includeInferred, maxQueryTime,\n 462   \t\t\t\tbindings);\n 463   \t\tgetRDF(method, handler, false);\n 464   \t}\n 908   \tprotected void getRDF(HttpUriRequest method, RDFHandler handler, boolean requireContext)\n 909   \t\tthrows IOException, RDFHandlerException, RepositoryException, MalformedQueryException,\n 910   \t\tUnauthorizedException, QueryInterruptedException\n 911   \t{\n 912   \t\t// Specify which formats we support using Accept headers\n 913   \t\tSet<RDFFormat> rdfFormats = RDFParserRegistry.getInstance().getKeys();\n 914   \t\tif (rdfFormats.isEmpty()) {\n 915   \t\t\tthrow new RepositoryException(\"No tuple RDF parsers have been registered\");\n 916   \t\t}\n 917   \n 918   \t\t// send the tuple query\n 919   \t\tHttpResponse response = sendGraphQueryViaHttp(method, requireContext, rdfFormats);\n 920   \t\ttry {\n 921   \n 922   \t\t\tString mimeType = getResponseMIMEType(response);\n 923   \t\t\ttry {\n 924   \t\t\t\tRDFFormat format = RDFFormat.matchMIMEType(mimeType, rdfFormats).orElseThrow(\n 925   \t\t\t\t\t\t() -> new RepositoryException(\n 926   \t\t\t\t\t\t\t\t\"Server responded with an unsupported file format: \" + mimeType));\n 927   \t\t\t\tRDFParser parser = Rio.createParser(format, getValueFactory());\n 928   \t\t\t\tparser.setParserConfig(getParserConfig());\n 929   \t\t\t\tparser.setParseErrorListener(new ParseErrorLogger());\n 930   \t\t\t\tparser.setRDFHandler(handler);\n 931   \t\t\t\tparser.parse(response.getEntity().getContent(), method.getURI().toASCIIString());\n 932   \t\t\t}\n 933   \t\t\tcatch (RDFParseException e) {\n 934   \t\t\t\tthrow new RepositoryException(\"Malformed query result from server\", e);\n 935   \t\t\t}\n 936   \t\t}\n 937   \t\tfinally {\n 938   \t\t\tEntityUtils.consumeQuietly(response.getEntity());\n 939   \t\t}\n 940   \t}\n 942   \tprivate HttpResponse sendGraphQueryViaHttp(HttpUriRequest method, boolean requireContext,\n 943   \t\t\tSet<RDFFormat> rdfFormats)\n 944   \t\tthrows RepositoryException, IOException, QueryInterruptedException, MalformedQueryException\n 945   \t{\n 946   \n 947   \t\tList<String> acceptParams = RDFFormat.getAcceptParams(rdfFormats, requireContext,\n 948   \t\t\t\tgetPreferredRDFFormat());\n 949   \n 950   \t\tmethod.addHeader(ACCEPT_PARAM_NAME, String.join(\", \", acceptParams));\n 951   \n 952   \t\ttry {\n 953   \t\t\treturn executeOK(method);\n 954   \t\t}\n 955   \t\tcatch (RepositoryException | MalformedQueryException | QueryInterruptedException e) {\n 956   \t\t\tthrow e;\n 957   \t\t}\n 958   \t\tcatch (RDF4JException e) {\n 959   \t\t\tthrow new RepositoryException(e);\n 960   \t\t}\n 961   \t}\n1043   \tprotected HttpResponse executeOK(HttpUriRequest method)\n1044   \t\tthrows IOException, RDF4JException\n1045   \t{\n1046   \t\tboolean fail = true;\n1047   \t\tHttpResponse response = execute(method);\n1048   \n1049   \t\ttry {\n1050   \t\t\tint httpCode = response.getStatusLine().getStatusCode();\n1051   \t\t\tif (httpCode == HttpURLConnection.HTTP_OK\n1052   \t\t\t\t\t|| httpCode == HttpURLConnection.HTTP_NOT_AUTHORITATIVE)\n1053   \t\t\t{\n1054   \t\t\t\tfail = false;\n1055   \t\t\t\treturn response; // everything OK, control flow can continue\n1056   \t\t\t}\n1057   \t\t\telse {\n1058   \t\t\t\t// trying to contact a non-SPARQL server?\n1059   \t\t\t\tthrow new RepositoryException(\n1060   \t\t\t\t\t\t\"Failed to get server protocol; no such resource on this server: \"\n1061   \t\t\t\t\t\t\t\t+ method.getURI().toString());\n1062   \t\t\t}\n1063   \t\t}\n1064   \t\tfinally {\n1065   \t\t\tif (fail) {\n1066   \t\t\t\tEntityUtils.consumeQuietly(response.getEntity());\n1067   \t\t\t}\n1068   \t\t}\n1069   \t}\n1087   \tprotected HttpResponse execute(HttpUriRequest method)\n1088   \t\tthrows IOException, RDF4JException\n1089   \t{\n1090   \t\tboolean consume = true;\n1091   \t\tif (params != null) {\n1092   \t\t\tmethod.setParams(params);\n1093   \t\t}\n1094   \t\tHttpResponse response = httpClient.execute(method, httpContext);\n1095   \n1096   \t\ttry {\n1097   \t\t\tint httpCode = response.getStatusLine().getStatusCode();\n1098   \t\t\tif (httpCode >= 200 && httpCode < 300 || httpCode == HttpURLConnection.HTTP_NOT_FOUND) {\n1099   \t\t\t\tconsume = false;\n1100   \t\t\t\treturn response; // everything OK, control flow can continue\n1101   \t\t\t}\n1102   \t\t\telse {\n1103   \t\t\t\tswitch (httpCode) {\n1104   \t\t\t\t\tcase HttpURLConnection.HTTP_UNAUTHORIZED: // 401\n1105   \t\t\t\t\t\tthrow new UnauthorizedException();\n1106   \t\t\t\t\tcase HttpURLConnection.HTTP_UNAVAILABLE: // 503\n1107   \t\t\t\t\t\tthrow new QueryInterruptedException();\n1108   \t\t\t\t\tdefault:\n1109   \t\t\t\t\t\tErrorInfo errInfo = getErrorInfo(response);\n1110   \t\t\t\t\t\t// Throw appropriate exception\n1111   \t\t\t\t\t\tif (errInfo.getErrorType() == ErrorType.MALFORMED_DATA) {\n1112   \t\t\t\t\t\t\tthrow new RDFParseException(errInfo.getErrorMessage());\n1113   \t\t\t\t\t\t}\n1114   \t\t\t\t\t\telse if (errInfo.getErrorType() == ErrorType.UNSUPPORTED_FILE_FORMAT) {\n1115   \t\t\t\t\t\t\tthrow new UnsupportedRDFormatException(errInfo.getErrorMessage());\n1116   \t\t\t\t\t\t}\n1117   \t\t\t\t\t\telse if (errInfo.getErrorType() == ErrorType.MALFORMED_QUERY) {\n1118   \t\t\t\t\t\t\tthrow new MalformedQueryException(errInfo.getErrorMessage());\n1119   \t\t\t\t\t\t}\n1120   \t\t\t\t\t\telse if (errInfo.getErrorType() == ErrorType.UNSUPPORTED_QUERY_LANGUAGE) {\n1121   \t\t\t\t\t\t\tthrow new UnsupportedQueryLanguageException(errInfo.getErrorMessage());\n1122   \t\t\t\t\t\t}\n1123   \t\t\t\t\t\telse if (errInfo.toString().length() > 0){\n1124   \t\t\t\t\t\t\tthrow new RepositoryException(errInfo.toString());\n1125   \t\t\t\t\t\t}\n1126   \t\t\t\t\t\telse {\n1127   \t\t\t\t\t\t\tthrow new RepositoryException(response.getStatusLine().getReasonPhrase());\n1128   \t\t\t\t\t\t}\n1129   \t\t\t\t}\n1130   \t\t\t}\n1131   \t\t}\n1132   \t\tfinally {\n1133   \t\t\tif (consume) {\n1134   \t\t\t\tEntityUtils.consumeQuietly(response.getEntity());\n1135   \t\t\t}\n1136   \t\t}\n1137   \t}\n",
            "cost": 0.120895,
            "harness_id": "id_1",
            "sanitizer": "Server Side Request Forgery (SSRF)",
            "sink": "src/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/SPARQLProtocolSession.java:1094:46",
            "status": "corpus",
            "valid_path": "NO",
            "id": 1
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java:\n 191   \t@Override\n 192   \tpublic synchronized void parse(InputStream in, String baseURI)\n 193   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 194   \t{\n 195   \t\tif (in == null) {\n 196   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n 197   \t\t}\n 198   \t\tif (baseURI == null) {\n 199   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n 200   \t\t}\n 201   \n 202   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n 203   \t\tinputSource.setSystemId(baseURI);\n 204   \n 205   \t\tparse(inputSource);\n 206   \t}\n 242   \tprivate void parse(InputSource inputSource)\n 243   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 244   \t{\n 245   \t\tclear();\n 246   \t\t\n 247   \t\ttry {\n 248   \t\t\tdocumentURI = inputSource.getSystemId();\n 249   \n 250   \t\t\tsaxFilter.setParseStandAloneDocuments(\n 251   \t\t\t\t\tgetParserConfig().get(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS));\n 252   \n 253   \t\t\t// saxFilter.clear();\n 254   \t\t\tsaxFilter.setDocumentURI(documentURI);\n 255   \n 256   \t\t\tXMLReader xmlReader;\n 257   \n 258   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n 259   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n 260   \t\t\t}\n 261   \t\t\telse {\n 262   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n 263   \t\t\t}\n 264   \n 265   \t\t\txmlReader.setContentHandler(saxFilter);\n 266   \t\t\txmlReader.setErrorHandler(this);\n 267   \n 268   \t\t\t// Set all compulsory feature settings, using the defaults if they are\n 269   \t\t\t// not explicitly set\n 270   \t\t\tfor (RioSetting<Boolean> aSetting : getCompulsoryXmlFeatureSettings()) {\n 271   \t\t\t\ttry {\n 272   \t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 273   \t\t\t\t}\n 274   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 275   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 276   \t\t\t\t}\n 277   \t\t\t\tcatch (SAXNotSupportedException e) {\n 278   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 279   \t\t\t\t}\n 280   \t\t\t}\n 281   \n 282   \t\t\t// Set all compulsory property settings, using the defaults if they are\n 283   \t\t\t// not explicitly set\n 284   \t\t\tfor (RioSetting<?> aSetting : getCompulsoryXmlPropertySettings()) {\n 285   \t\t\t\ttry {\n 286   \t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 287   \t\t\t\t}\n 288   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 289   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 290   \t\t\t\t}\n 291   \t\t\t\tcatch (SAXNotSupportedException e) {\n 292   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 293   \t\t\t\t}\n 294   \t\t\t}\n 295   \n 296   \t\t\t// Check for any optional feature settings that are explicitly set in\n 297   \t\t\t// the parser config\n 298   \t\t\tfor (RioSetting<Boolean> aSetting : getOptionalXmlFeatureSettings()) {\n 299   \t\t\t\ttry {\n 300   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 301   \t\t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 302   \t\t\t\t\t}\n 303   \t\t\t\t}\n 304   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 305   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 306   \t\t\t\t}\n 307   \t\t\t\tcatch (SAXNotSupportedException e) {\n 308   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 309   \t\t\t\t}\n 310   \t\t\t}\n 311   \n 312   \t\t\t// Check for any optional property settings that are explicitly set in\n 313   \t\t\t// the parser config\n 314   \t\t\tfor (RioSetting<?> aSetting : getOptionalXmlPropertySettings()) {\n 315   \t\t\t\ttry {\n 316   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 317   \t\t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 318   \t\t\t\t\t}\n 319   \t\t\t\t}\n 320   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 321   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 322   \t\t\t\t}\n 323   \t\t\t\tcatch (SAXNotSupportedException e) {\n 324   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 325   \t\t\t\t}\n 326   \t\t\t}\n 327   \n 328   \t\t\txmlReader.parse(inputSource);\n 329   \t\t}\n 330   \t\tcatch (SAXParseException e) {\n 331   \t\t\tException wrappedExc = e.getException();\n 332   \n 333   \t\t\tif (wrappedExc == null) {\n 334   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n 335   \t\t\t}\n 336   \t\t\telse {\n 337   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n 338   \t\t\t}\n 339   \t\t}\n 340   \t\tcatch (SAXException e) {\n 341   \t\t\tException wrappedExc = e.getException();\n 342   \n 343   \t\t\tif (wrappedExc == null) {\n 344   \t\t\t\treportFatalError(e);\n 345   \t\t\t}\n 346   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n 347   \t\t\t\tthrow (RDFParseException)wrappedExc;\n 348   \t\t\t}\n 349   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n 350   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n 351   \t\t\t}\n 352   \t\t\telse {\n 353   \t\t\t\treportFatalError(wrappedExc);\n 354   \t\t\t}\n 355   \t\t}\n 356   \t\tfinally {\n 357   \t\t\t// Clean up\n 358   \t\t\tsaxFilter.clear();\n 359   \t\t\txmlLang = null;\n 360   \t\t\telementStack.clear();\n 361   \t\t\tusedIDs.clear();\n 362   \t\t\tclear();\n 363   \t\t}\n 364   \t}\n\nsrc/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/xml/XMLReaderFactory.java:\n 36   \tpublic static XMLReader createXMLReader()\n 37   \t\tthrows SAXException\n 38   \t{\n 39   \t\tfinal Logger logger = LoggerFactory.getLogger(XMLReader.class);\n 40   \n 41   \t\tXMLReader reader = null;\n 42   \n 43   \t\t// first, try and initialize based on the system property.\n 44   \t\tString xmlReaderName = System.getProperty(\"org.xml.sax.driver\");\n 45   \t\tif (xmlReaderName != null) {\n 46   \t\t\ttry {\n 47   \t\t\t\treader = _createXMLReader(xmlReaderName);\n 48   \t\t\t}\n 49   \t\t\tcatch (ClassNotFoundException e) {\n 50   \t\t\t\tlogger.warn(\"Class \" + xmlReaderName + \" not found\");\n 51   \t\t\t}\n 52   \t\t\tcatch (ClassCastException e) {\n 53   \t\t\t\tlogger.warn(xmlReaderName + \" is not a valid XMLReader.\");\n 54   \t\t\t}\n 55   \t\t\tcatch (Exception e) {\n 56   \t\t\t\tlogger.warn(\"could not create instance of \" + xmlReaderName);\n 57   \t\t\t}\n 58   \t\t\tlogger.debug(\"XMLReader initialized using system property: \" + xmlReaderName);\n 59   \t\t}\n 60   \n 61   \t\t// next, try using javax.xml.parsers.SAXParserFactory\n 62   \t\tif (reader == null) {\n 63   \t\t\ttry {\n 64   \t\t\t\tjavax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory.newInstance();\n 65   \t\t\t\tfactory.setNamespaceAware(true);\n 66   \n 67   \t\t\t\treader = factory.newSAXParser().getXMLReader();\n 68   \t\t\t}\n 69   \t\t\tcatch (NoClassDefFoundError e) {\n 70   \t\t\t\tlogger.warn(\"javax.xml.parsers.SAXParserFactory not available\");\n 71   \t\t\t}\n 72   \t\t\tcatch (Exception e) {\n 73   \t\t\t\tlogger.warn(\"Failed to initialize XMLReader through JAXP\");\n 74   \t\t\t}\n 75   \t\t\tlogger.debug(\"XMLReader initialized using JAXP: \" + reader);\n 76   \t\t}\n 77   \n 78   \t\t// Last resort: try using the Xerces 2 SAX Parser\n 79   \t\tif (reader == null) {\n 80   \t\t\ttry {\n 81   \t\t\t\treader = _createXMLReader(XERCES_SAXPARSER);\n 82   \t\t\t}\n 83   \t\t\tcatch (ClassNotFoundException e) {\n 84   \t\t\t\tString message = \"Class \" + XERCES_SAXPARSER + \" not found\";\n 85   \t\t\t\tlogger.error(message);\n 86   \t\t\t\tthrow new SAXException(message);\n 87   \t\t\t}\n 88   \t\t\tcatch (ClassCastException e) {\n 89   \t\t\t\tString message = XERCES_SAXPARSER + \" is not a valid XMLReader.\";\n 90   \t\t\t\tlogger.error(message);\n 91   \t\t\t\tthrow new SAXException(message);\n 92   \t\t\t}\n 93   \t\t\tcatch (Exception e) {\n 94   \t\t\t\tString message = \"Could not create instance of \" + XERCES_SAXPARSER;\n 95   \t\t\t\tlogger.error(message);\n 96   \t\t\t\tthrow new SAXException(message);\n 97   \t\t\t}\n 98   \t\t\tlogger.debug(\"XMLReader initialized using default Xerces SAX parser \" + XERCES_SAXPARSER);\n 99   \t\t}\n100   \t\treturn reader;\n101   \t}\n134   \tprotected static XMLReader _createXMLReader(String name)\n135   \t\tthrows ClassNotFoundException, ClassCastException, InstantiationException, IllegalAccessException\n136   \t{\n137   \t\treturn (XMLReader)Class.forName(name).newInstance();\n138   \t}\n",
            "cost": 0.07572999999999999,
            "harness_id": "id_1",
            "sanitizer": "load arbitrary library",
            "sink": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/xml/XMLReaderFactory.java:137:35",
            "status": "corpus",
            "valid_path": "NO",
            "id": 2
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/trix/src/main/java/org/eclipse/rdf4j/rio/trix/TriXParser.java:\n112   \t@Override\n113   \tpublic void parse(InputStream in, String baseURI)\n114   \t\tthrows IOException, RDFParseException, RDFHandlerException\n115   \t{\n116   \t\tif (in == null) {\n117   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n118   \t\t}\n119   \t\tif (baseURI == null) {\n120   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n121   \t\t}\n122   \n123   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n124   \t\tinputSource.setSystemId(baseURI);\n125   \n126   \t\tparse(inputSource);\n127   \t}\n163   \tprivate void parse(InputSource inputStreamOrReader)\n164   \t\tthrows IOException, RDFParseException, RDFHandlerException\n165   \t{\n166   \t\tclear();\n167   \t\t\n168   \t\ttry {\n169   \t\t\tif (rdfHandler != null) {\n170   \t\t\t\trdfHandler.startRDF();\n171   \t\t\t}\n172   \n173   \t\t\tXMLReader xmlReader;\n174   \n175   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n176   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n177   \t\t\t}\n178   \t\t\telse {\n179   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n180   \t\t\t}\n181   \n182   \t\t\txmlReader.setErrorHandler(this);\n183   \n184   \t\t\tsaxParser = new SimpleSAXParser(xmlReader);\n185   \t\t\tsaxParser.setPreserveWhitespace(true);\n186   \t\t\tsaxParser.setListener(new TriXSAXHandler());\n187   \n188   \t\t\tsaxParser.parse(inputStreamOrReader);\n189   \t\t}\n190   \t\tcatch (SAXParseException e) {\n191   \t\t\tException wrappedExc = e.getException();\n192   \n193   \t\t\tif (wrappedExc == null) {\n194   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n195   \t\t\t}\n196   \t\t\telse {\n197   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n198   \t\t\t}\n199   \t\t}\n200   \t\tcatch (SAXException e) {\n201   \t\t\tException wrappedExc = e.getException();\n202   \n203   \t\t\tif (wrappedExc == null) {\n204   \t\t\t\treportFatalError(e);\n205   \t\t\t}\n206   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n207   \t\t\t\tthrow (RDFParseException)wrappedExc;\n208   \t\t\t}\n209   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n210   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n211   \t\t\t}\n212   \t\t\telse {\n213   \t\t\t\treportFatalError(wrappedExc);\n214   \t\t\t}\n215   \t\t}\n216   \t\tfinally {\n217   \t\t\tclear();\n218   \t\t}\n219   \n220   \t\tif (rdfHandler != null) {\n221   \t\t\trdfHandler.endRDF();\n222   \t\t}\n223   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java:\n 87   \tprivate void processBuffer()\n 88   \t\tthrows RDFHandlerException\n 89   \t{\n 90   \t\t// primary grouping per context.\n 91   \t\tfor (Resource context : contexts) {\n 92   \t\t\tSet<Resource> subjects = GraphUtil.getSubjects(bufferedStatements, null, null, context);\n 93   \t\t\tfor (Resource subject : subjects) {\n 94   \t\t\t\tSet<IRI> processedPredicates = new HashSet<IRI>();\n 95   \n 96   \t\t\t\t// give rdf:type preference over other predicates.\n 97   \t\t\t\tIterator<Statement> typeStatements = bufferedStatements.match(subject, RDF.TYPE, null,\n 98   \t\t\t\t\t\tcontext);\n 99   \t\t\t\twhile (typeStatements.hasNext()) {\n100   \t\t\t\t\tStatement typeStatement = typeStatements.next();\n101   \t\t\t\t\tsuper.handleStatement(typeStatement);\n102   \t\t\t\t}\n103   \n104   \t\t\t\tprocessedPredicates.add(RDF.TYPE);\n105   \n106   \t\t\t\t// retrieve other statement from this context with the same\n107   \t\t\t\t// subject, and output them grouped by predicate\n108   \t\t\t\tIterator<Statement> subjectStatements = bufferedStatements.match(subject, null, null,\n109   \t\t\t\t\t\tcontext);\n110   \t\t\t\twhile (subjectStatements.hasNext()) {\n111   \t\t\t\t\tStatement subjectStatement = subjectStatements.next();\n112   \t\t\t\t\tIRI predicate = subjectStatement.getPredicate();\n113   \t\t\t\t\tif (!processedPredicates.contains(predicate)) {\n114   \t\t\t\t\t\tIterator<Statement> toWrite = bufferedStatements.match(subject, predicate, null,\n115   \t\t\t\t\t\t\t\tcontext);\n116   \t\t\t\t\t\twhile (toWrite.hasNext()) {\n117   \t\t\t\t\t\t\tStatement toWriteSt = toWrite.next();\n118   \t\t\t\t\t\t\tsuper.handleStatement(toWriteSt);\n119   \t\t\t\t\t\t}\n120   \t\t\t\t\t\tprocessedPredicates.add(predicate);\n121   \t\t\t\t\t}\n122   \t\t\t\t}\n123   \t\t\t}\n124   \t\t}\n125   \t\tbufferedStatements.clear();\n126   \t\tcontexts.clear();\n127   \t}\n129   \t@Override\n130   \tpublic void endRDF()\n131   \t\tthrows RDFHandlerException\n132   \t{\n133   \t\tsynchronized (bufferLock) {\n134   \t\t\tprocessBuffer();\n135   \t\t}\n136   \t\tsuper.endRDF();\n137   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/RDFHandlerWrapper.java:\n77   \tpublic void handleStatement(Statement st)\n78   \t\tthrows RDFHandlerException\n79   \t{\n80   \t\tfor (RDFHandler rdfHandler : rdfHandlers) {\n81   \t\t\trdfHandler.handleStatement(st);\n82   \t\t}\n83   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFRemover.java:\n 96   \t@Override\n 97   \tpublic void handleStatement(Statement st)\n 98   \t\tthrows RDFHandlerException\n 99   \t{\n100   \t\ttry {\n101   \t\t\tif (enforceContext) {\n102   \t\t\t\t// Override supplied context info\n103   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), context);\n104   \t\t\t}\n105   \t\t\telse {\n106   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), st.getContext());\n107   \t\t\t}\n108   \t\t}\n109   \t\tcatch (RepositoryException e) {\n110   \t\t\tthrow new RDFHandlerException(e);\n111   \t\t}\n112   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/base/AbstractRepositoryConnection.java:\n580   \t@Override\n581   \tpublic void remove(Resource subject, IRI predicate, Value object, Resource... contexts)\n582   \t\tthrows RepositoryException\n583   \t{\n584   \t\tboolean localTransaction = startLocalTransaction();\n585   \n586   \t\tOpenRDFUtil.verifyContextNotNull(contexts);\n587   \t\tremoveWithoutCommit(subject, predicate, object, contexts);\n588   \n589   \t\tconditionalCommit(localTransaction);\n590   \t}\n\nsrc/rdf4j/repository/event/src/main/java/org/eclipse/rdf4j/repository/event/base/NotifyingRepositoryConnectionWrapper.java:\n173   \t@Override\n174   \tpublic void removeWithoutCommit(Resource subj, IRI pred, Value obj, Resource... ctx)\n175   \t\tthrows RepositoryException\n176   \t{\n177   \t\tif (activated && reportDeltas()) {\n178   \t\t\tRepositoryResult<Statement> stmts;\n179   \t\t\tstmts = getDelegate().getStatements(subj, pred, obj, false, ctx);\n180   \t\t\tList<Statement> list = new ArrayList<Statement>();\n181   \t\t\ttry {\n182   \t\t\t\twhile (stmts.hasNext()) {\n183   \t\t\t\t\tlist.add(stmts.next());\n184   \t\t\t\t}\n185   \t\t\t}\n186   \t\t\tfinally {\n187   \t\t\t\tstmts.close();\n188   \t\t\t}\n189   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n190   \t\t\tfor (RepositoryConnectionListener listener : listeners) {\n191   \t\t\t\tfor (Statement stmt : list) {\n192   \t\t\t\t\tResource s = stmt.getSubject();\n193   \t\t\t\t\tIRI p = stmt.getPredicate();\n194   \t\t\t\t\tValue o = stmt.getObject();\n195   \t\t\t\t\tResource c = stmt.getContext();\n196   \t\t\t\t\tlistener.remove(getDelegate(), s, p, o, c);\n197   \t\t\t\t}\n198   \t\t\t}\n199   \t\t}\n200   \t\telse if (activated) {\n201   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n202   \t\t\tfor (RepositoryConnectionListener listener : listeners) {\n203   \t\t\t\tlistener.remove(getDelegate(), subj, pred, obj, ctx);\n204   \t\t\t}\n205   \t\t}\n206   \t\telse {\n207   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n208   \t\t}\n209   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/SPARQLConnection.java:\n 252   \tpublic RepositoryResult<Statement> getStatements(Resource subj, IRI pred, Value obj,\n 253   \t\t\tboolean includeInferred, Resource... contexts)\n 254   \t\tthrows RepositoryException\n 255   \t{\n 256   \t\ttry {\n 257   \t\t\tif (isQuadMode()) {\n 258   \t\t\t\treturn getStatementsQuadMode(subj, pred, obj, includeInferred, contexts);\n 259   \t\t\t}\n 260   \t\t\telse if (subj != null && pred != null && obj != null) {\n 261   \t\t\t\treturn getStatementsSingleTriple(subj, pred, obj, includeInferred, contexts);\n 262   \t\t\t}\n 263   \t\t\telse {\n 264   \t\t\t\treturn getStatementGeneral(subj, pred, obj, includeInferred, contexts);\n 265   \t\t\t}\n 266   \t\t}\n 267   \t\tcatch (MalformedQueryException e) {\n 268   \t\t\tthrow new RepositoryException(e);\n 269   \t\t}\n 270   \t\tcatch (QueryEvaluationException e) {\n 271   \t\t\tthrow new RepositoryException(e);\n 272   \t\t}\n 273   \t}\n 275   \tprivate RepositoryResult<Statement> getStatementsQuadMode(Resource subj, IRI pred, Value obj,\n 276   \t\t\tboolean includeInferred, Resource... contexts)\n 277   \t\tthrows MalformedQueryException, RepositoryException, QueryEvaluationException\n 278   \t{\n 279   \t\tTupleQueryResult qRes = null;\n 280   \t\tRepositoryResult<Statement> result = null;\n 281   \n 282   \t\tboolean allGood = false;\n 283   \t\ttry {\n 284   \t\t\tTupleQuery tupleQuery = prepareTupleQuery(SPARQL, EVERYTHING_WITH_GRAPH);\n 285   \t\t\tsetBindings(tupleQuery, subj, pred, obj, contexts);\n 286   \t\t\ttupleQuery.setIncludeInferred(includeInferred);\n 287   \t\t\tqRes = tupleQuery.evaluate();\n 288   \t\t\tresult = new RepositoryResult<Statement>(\n 289   \t\t\t\t\tnew ExceptionConvertingIteration<Statement, RepositoryException>(\n 290   \t\t\t\t\t\t\ttoStatementIteration(qRes, subj, pred, obj))\n 291   \t\t\t\t\t{\n 292   \n 293   \t\t\t\t\t\t@Override\n 294   \t\t\t\t\t\tprotected RepositoryException convert(Exception e) {\n 295   \t\t\t\t\t\t\treturn new RepositoryException(e);\n 296   \t\t\t\t\t\t}\n 297   \t\t\t\t\t});\n 298   \t\t\tallGood = true;\n 299   \t\t\treturn result;\n 300   \t\t}\n 301   \t\tfinally {\n 302   \t\t\tif (!allGood) {\n 303   \t\t\t\ttry {\n 304   \t\t\t\t\tif (result != null) {\n 305   \t\t\t\t\t\tresult.close();\n 306   \t\t\t\t\t}\n 307   \t\t\t\t}\n 308   \t\t\t\tfinally {\n 309   \t\t\t\t\tif (qRes != null) {\n 310   \t\t\t\t\t\tqRes.close();\n 311   \t\t\t\t\t}\n 312   \t\t\t\t}\n 313   \t\t\t}\n 314   \t\t}\n 315   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/SPARQLTupleQuery.java:\n37   \tpublic TupleQueryResult evaluate()\n38   \t\tthrows QueryEvaluationException\n39   \t{\n40   \n41   \t\tSPARQLProtocolSession client = getHttpClient();\n42   \t\ttry {\n43   \t\t\treturn client.sendTupleQuery(QueryLanguage.SPARQL, getQueryString(), baseURI, dataset,\n44   \t\t\t\t\tgetIncludeInferred(), getMaxExecutionTime(), getBindingsArray());\n45   \t\t}\n46   \t\tcatch (IOException e) {\n47   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n48   \t\t}\n49   \t\tcatch (RepositoryException e) {\n50   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n51   \t\t}\n52   \t\tcatch (MalformedQueryException e) {\n53   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n54   \t\t}\n55   \t}\n77   \tprivate String getQueryString() {\n78   \t\treturn QueryStringUtil.getTupleQueryString(queryString, getBindings());\n79   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java:\n 54   \tpublic static String getTupleQueryString(String queryString, BindingSet bindings) {\n 55   \t\tif (bindings.size() == 0) {\n 56   \t\t\treturn queryString;\n 57   \t\t}\n 58   \n 59   \t\tString qry = queryString;\n 60   \t\tint b = qry.indexOf('{');\n 61   \t\tString select = qry.substring(0, b);\n 62   \t\tString where = qry.substring(b);\n 63   \t\tfor (String name : bindings.getBindingNames()) {\n 64   \t\t\tString replacement = valueToString(bindings.getValue(name));\n 65   \t\t\tif (replacement != null) {\n 66   \t\t\t\tString pattern = \"[\\\\?\\\\$]\" + name + \"(?=\\\\W)\";\n 67   \t\t\t\tselect = select.replaceAll(pattern,\n 68   \t\t\t\t\t\t\"(\" + Matcher.quoteReplacement(replacement) + \" as ?\" + name + \")\");\n 69   \n 70   \t\t\t\t// we use Matcher.quoteReplacement to make sure things like newlines\n 71   \t\t\t\t// in literal values\n 72   \t\t\t\t// are preserved\n 73   \t\t\t\twhere = where.replaceAll(pattern, Matcher.quoteReplacement(replacement));\n 74   \t\t\t}\n 75   \t\t}\n 76   \t\treturn select + where;\n 77   \t}\n",
            "cost": 0.099495,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java:67:32",
            "status": "corpus",
            "valid_path": "NO",
            "id": 3
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/trix/src/main/java/org/eclipse/rdf4j/rio/trix/TriXParser.java:\n112   \t@Override\n113   \tpublic void parse(InputStream in, String baseURI)\n114   \t\tthrows IOException, RDFParseException, RDFHandlerException\n115   \t{\n116   \t\tif (in == null) {\n117   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n118   \t\t}\n119   \t\tif (baseURI == null) {\n120   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n121   \t\t}\n122   \n123   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n124   \t\tinputSource.setSystemId(baseURI);\n125   \n126   \t\tparse(inputSource);\n127   \t}\n163   \tprivate void parse(InputSource inputStreamOrReader)\n164   \t\tthrows IOException, RDFParseException, RDFHandlerException\n165   \t{\n166   \t\tclear();\n167   \t\t\n168   \t\ttry {\n169   \t\t\tif (rdfHandler != null) {\n170   \t\t\t\trdfHandler.startRDF();\n171   \t\t\t}\n172   \n173   \t\t\tXMLReader xmlReader;\n174   \n175   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n176   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n177   \t\t\t}\n178   \t\t\telse {\n179   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n180   \t\t\t}\n181   \n182   \t\t\txmlReader.setErrorHandler(this);\n183   \n184   \t\t\tsaxParser = new SimpleSAXParser(xmlReader);\n185   \t\t\tsaxParser.setPreserveWhitespace(true);\n186   \t\t\tsaxParser.setListener(new TriXSAXHandler());\n187   \n188   \t\t\tsaxParser.parse(inputStreamOrReader);\n189   \t\t}\n190   \t\tcatch (SAXParseException e) {\n191   \t\t\tException wrappedExc = e.getException();\n192   \n193   \t\t\tif (wrappedExc == null) {\n194   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n195   \t\t\t}\n196   \t\t\telse {\n197   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n198   \t\t\t}\n199   \t\t}\n200   \t\tcatch (SAXException e) {\n201   \t\t\tException wrappedExc = e.getException();\n202   \n203   \t\t\tif (wrappedExc == null) {\n204   \t\t\t\treportFatalError(e);\n205   \t\t\t}\n206   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n207   \t\t\t\tthrow (RDFParseException)wrappedExc;\n208   \t\t\t}\n209   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n210   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n211   \t\t\t}\n212   \t\t\telse {\n213   \t\t\t\treportFatalError(wrappedExc);\n214   \t\t\t}\n215   \t\t}\n216   \t\tfinally {\n217   \t\t\tclear();\n218   \t\t}\n219   \n220   \t\tif (rdfHandler != null) {\n221   \t\t\trdfHandler.endRDF();\n222   \t\t}\n223   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java:\n 87   \tprivate void processBuffer()\n 88   \t\tthrows RDFHandlerException\n 89   \t{\n 90   \t\t// primary grouping per context.\n 91   \t\tfor (Resource context : contexts) {\n 92   \t\t\tSet<Resource> subjects = GraphUtil.getSubjects(bufferedStatements, null, null, context);\n 93   \t\t\tfor (Resource subject : subjects) {\n 94   \t\t\t\tSet<IRI> processedPredicates = new HashSet<IRI>();\n 95   \n 96   \t\t\t\t// give rdf:type preference over other predicates.\n 97   \t\t\t\tIterator<Statement> typeStatements = bufferedStatements.match(subject, RDF.TYPE, null,\n 98   \t\t\t\t\t\tcontext);\n 99   \t\t\t\twhile (typeStatements.hasNext()) {\n100   \t\t\t\t\tStatement typeStatement = typeStatements.next();\n101   \t\t\t\t\tsuper.handleStatement(typeStatement);\n102   \t\t\t\t}\n103   \n104   \t\t\t\tprocessedPredicates.add(RDF.TYPE);\n105   \n106   \t\t\t\t// retrieve other statement from this context with the same\n107   \t\t\t\t// subject, and output them grouped by predicate\n108   \t\t\t\tIterator<Statement> subjectStatements = bufferedStatements.match(subject, null, null,\n109   \t\t\t\t\t\tcontext);\n110   \t\t\t\twhile (subjectStatements.hasNext()) {\n111   \t\t\t\t\tStatement subjectStatement = subjectStatements.next();\n112   \t\t\t\t\tIRI predicate = subjectStatement.getPredicate();\n113   \t\t\t\t\tif (!processedPredicates.contains(predicate)) {\n114   \t\t\t\t\t\tIterator<Statement> toWrite = bufferedStatements.match(subject, predicate, null,\n115   \t\t\t\t\t\t\t\tcontext);\n116   \t\t\t\t\t\twhile (toWrite.hasNext()) {\n117   \t\t\t\t\t\t\tStatement toWriteSt = toWrite.next();\n118   \t\t\t\t\t\t\tsuper.handleStatement(toWriteSt);\n119   \t\t\t\t\t\t}\n120   \t\t\t\t\t\tprocessedPredicates.add(predicate);\n121   \t\t\t\t\t}\n122   \t\t\t\t}\n123   \t\t\t}\n124   \t\t}\n125   \t\tbufferedStatements.clear();\n126   \t\tcontexts.clear();\n127   \t}\n129   \t@Override\n130   \tpublic void endRDF()\n131   \t\tthrows RDFHandlerException\n132   \t{\n133   \t\tsynchronized (bufferLock) {\n134   \t\t\tprocessBuffer();\n135   \t\t}\n136   \t\tsuper.endRDF();\n137   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/RDFHandlerWrapper.java:\n77   \tpublic void handleStatement(Statement st)\n78   \t\tthrows RDFHandlerException\n79   \t{\n80   \t\tfor (RDFHandler rdfHandler : rdfHandlers) {\n81   \t\t\trdfHandler.handleStatement(st);\n82   \t\t}\n83   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFRemover.java:\n 96   \t@Override\n 97   \tpublic void handleStatement(Statement st)\n 98   \t\tthrows RDFHandlerException\n 99   \t{\n100   \t\ttry {\n101   \t\t\tif (enforceContext) {\n102   \t\t\t\t// Override supplied context info\n103   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), context);\n104   \t\t\t}\n105   \t\t\telse {\n106   \t\t\t\tcon.remove(st.getSubject(), st.getPredicate(), st.getObject(), st.getContext());\n107   \t\t\t}\n108   \t\t}\n109   \t\tcatch (RepositoryException e) {\n110   \t\t\tthrow new RDFHandlerException(e);\n111   \t\t}\n112   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/base/AbstractRepositoryConnection.java:\n580   \t@Override\n581   \tpublic void remove(Resource subject, IRI predicate, Value object, Resource... contexts)\n582   \t\tthrows RepositoryException\n583   \t{\n584   \t\tboolean localTransaction = startLocalTransaction();\n585   \n586   \t\tOpenRDFUtil.verifyContextNotNull(contexts);\n587   \t\tremoveWithoutCommit(subject, predicate, object, contexts);\n588   \n589   \t\tconditionalCommit(localTransaction);\n590   \t}\n\nsrc/rdf4j/repository/event/src/main/java/org/eclipse/rdf4j/repository/event/base/NotifyingRepositoryConnectionWrapper.java:\n173   \t@Override\n174   \tpublic void removeWithoutCommit(Resource subj, IRI pred, Value obj, Resource... ctx)\n175   \t\tthrows RepositoryException\n176   \t{\n177   \t\tif (activated && reportDeltas()) {\n178   \t\t\tRepositoryResult<Statement> stmts;\n179   \t\t\tstmts = getDelegate().getStatements(subj, pred, obj, false, ctx);\n180   \t\t\tList<Statement> list = new ArrayList<Statement>();\n181   \t\t\ttry {\n182   \t\t\t\twhile (stmts.hasNext()) {\n183   \t\t\t\t\tlist.add(stmts.next());\n184   \t\t\t\t}\n185   \t\t\t}\n186   \t\t\tfinally {\n187   \t\t\t\tstmts.close();\n188   \t\t\t}\n189   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n190   \t\t\tfor (RepositoryConnectionListener listener : listeners) {\n191   \t\t\t\tfor (Statement stmt : list) {\n192   \t\t\t\t\tResource s = stmt.getSubject();\n193   \t\t\t\t\tIRI p = stmt.getPredicate();\n194   \t\t\t\t\tValue o = stmt.getObject();\n195   \t\t\t\t\tResource c = stmt.getContext();\n196   \t\t\t\t\tlistener.remove(getDelegate(), s, p, o, c);\n197   \t\t\t\t}\n198   \t\t\t}\n199   \t\t}\n200   \t\telse if (activated) {\n201   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n202   \t\t\tfor (RepositoryConnectionListener listener : listeners) {\n203   \t\t\t\tlistener.remove(getDelegate(), subj, pred, obj, ctx);\n204   \t\t\t}\n205   \t\t}\n206   \t\telse {\n207   \t\t\tgetDelegate().remove(subj, pred, obj, ctx);\n208   \t\t}\n209   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/SPARQLConnection.java:\n 252   \tpublic RepositoryResult<Statement> getStatements(Resource subj, IRI pred, Value obj,\n 253   \t\t\tboolean includeInferred, Resource... contexts)\n 254   \t\tthrows RepositoryException\n 255   \t{\n 256   \t\ttry {\n 257   \t\t\tif (isQuadMode()) {\n 258   \t\t\t\treturn getStatementsQuadMode(subj, pred, obj, includeInferred, contexts);\n 259   \t\t\t}\n 260   \t\t\telse if (subj != null && pred != null && obj != null) {\n 261   \t\t\t\treturn getStatementsSingleTriple(subj, pred, obj, includeInferred, contexts);\n 262   \t\t\t}\n 263   \t\t\telse {\n 264   \t\t\t\treturn getStatementGeneral(subj, pred, obj, includeInferred, contexts);\n 265   \t\t\t}\n 266   \t\t}\n 267   \t\tcatch (MalformedQueryException e) {\n 268   \t\t\tthrow new RepositoryException(e);\n 269   \t\t}\n 270   \t\tcatch (QueryEvaluationException e) {\n 271   \t\t\tthrow new RepositoryException(e);\n 272   \t\t}\n 273   \t}\n 275   \tprivate RepositoryResult<Statement> getStatementsQuadMode(Resource subj, IRI pred, Value obj,\n 276   \t\t\tboolean includeInferred, Resource... contexts)\n 277   \t\tthrows MalformedQueryException, RepositoryException, QueryEvaluationException\n 278   \t{\n 279   \t\tTupleQueryResult qRes = null;\n 280   \t\tRepositoryResult<Statement> result = null;\n 281   \n 282   \t\tboolean allGood = false;\n 283   \t\ttry {\n 284   \t\t\tTupleQuery tupleQuery = prepareTupleQuery(SPARQL, EVERYTHING_WITH_GRAPH);\n 285   \t\t\tsetBindings(tupleQuery, subj, pred, obj, contexts);\n 286   \t\t\ttupleQuery.setIncludeInferred(includeInferred);\n 287   \t\t\tqRes = tupleQuery.evaluate();\n 288   \t\t\tresult = new RepositoryResult<Statement>(\n 289   \t\t\t\t\tnew ExceptionConvertingIteration<Statement, RepositoryException>(\n 290   \t\t\t\t\t\t\ttoStatementIteration(qRes, subj, pred, obj))\n 291   \t\t\t\t\t{\n 292   \n 293   \t\t\t\t\t\t@Override\n 294   \t\t\t\t\t\tprotected RepositoryException convert(Exception e) {\n 295   \t\t\t\t\t\t\treturn new RepositoryException(e);\n 296   \t\t\t\t\t\t}\n 297   \t\t\t\t\t});\n 298   \t\t\tallGood = true;\n 299   \t\t\treturn result;\n 300   \t\t}\n 301   \t\tfinally {\n 302   \t\t\tif (!allGood) {\n 303   \t\t\t\ttry {\n 304   \t\t\t\t\tif (result != null) {\n 305   \t\t\t\t\t\tresult.close();\n 306   \t\t\t\t\t}\n 307   \t\t\t\t}\n 308   \t\t\t\tfinally {\n 309   \t\t\t\t\tif (qRes != null) {\n 310   \t\t\t\t\t\tqRes.close();\n 311   \t\t\t\t\t}\n 312   \t\t\t\t}\n 313   \t\t\t}\n 314   \t\t}\n 315   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/SPARQLTupleQuery.java:\n37   \tpublic TupleQueryResult evaluate()\n38   \t\tthrows QueryEvaluationException\n39   \t{\n40   \n41   \t\tSPARQLProtocolSession client = getHttpClient();\n42   \t\ttry {\n43   \t\t\treturn client.sendTupleQuery(QueryLanguage.SPARQL, getQueryString(), baseURI, dataset,\n44   \t\t\t\t\tgetIncludeInferred(), getMaxExecutionTime(), getBindingsArray());\n45   \t\t}\n46   \t\tcatch (IOException e) {\n47   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n48   \t\t}\n49   \t\tcatch (RepositoryException e) {\n50   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n51   \t\t}\n52   \t\tcatch (MalformedQueryException e) {\n53   \t\t\tthrow new QueryEvaluationException(e.getMessage(), e);\n54   \t\t}\n55   \t}\n77   \tprivate String getQueryString() {\n78   \t\treturn QueryStringUtil.getTupleQueryString(queryString, getBindings());\n79   \t}\n\nsrc/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java:\n 54   \tpublic static String getTupleQueryString(String queryString, BindingSet bindings) {\n 55   \t\tif (bindings.size() == 0) {\n 56   \t\t\treturn queryString;\n 57   \t\t}\n 58   \n 59   \t\tString qry = queryString;\n 60   \t\tint b = qry.indexOf('{');\n 61   \t\tString select = qry.substring(0, b);\n 62   \t\tString where = qry.substring(b);\n 63   \t\tfor (String name : bindings.getBindingNames()) {\n 64   \t\t\tString replacement = valueToString(bindings.getValue(name));\n 65   \t\t\tif (replacement != null) {\n 66   \t\t\t\tString pattern = \"[\\\\?\\\\$]\" + name + \"(?=\\\\W)\";\n 67   \t\t\t\tselect = select.replaceAll(pattern,\n 68   \t\t\t\t\t\t\"(\" + Matcher.quoteReplacement(replacement) + \" as ?\" + name + \")\");\n 69   \n 70   \t\t\t\t// we use Matcher.quoteReplacement to make sure things like newlines\n 71   \t\t\t\t// in literal values\n 72   \t\t\t\t// are preserved\n 73   \t\t\t\twhere = where.replaceAll(pattern, Matcher.quoteReplacement(replacement));\n 74   \t\t\t}\n 75   \t\t}\n 76   \t\treturn select + where;\n 77   \t}\n",
            "cost": 0.104145,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java:73:30",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 4
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/trix/src/main/java/org/eclipse/rdf4j/rio/trix/TriXParser.java:\n112   \t@Override\n113   \tpublic void parse(InputStream in, String baseURI)\n114   \t\tthrows IOException, RDFParseException, RDFHandlerException\n115   \t{\n116   \t\tif (in == null) {\n117   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n118   \t\t}\n119   \t\tif (baseURI == null) {\n120   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n121   \t\t}\n122   \n123   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n124   \t\tinputSource.setSystemId(baseURI);\n125   \n126   \t\tparse(inputSource);\n127   \t}\n163   \tprivate void parse(InputSource inputStreamOrReader)\n164   \t\tthrows IOException, RDFParseException, RDFHandlerException\n165   \t{\n166   \t\tclear();\n167   \t\t\n168   \t\ttry {\n169   \t\t\tif (rdfHandler != null) {\n170   \t\t\t\trdfHandler.startRDF();\n171   \t\t\t}\n172   \n173   \t\t\tXMLReader xmlReader;\n174   \n175   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n176   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n177   \t\t\t}\n178   \t\t\telse {\n179   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n180   \t\t\t}\n181   \n182   \t\t\txmlReader.setErrorHandler(this);\n183   \n184   \t\t\tsaxParser = new SimpleSAXParser(xmlReader);\n185   \t\t\tsaxParser.setPreserveWhitespace(true);\n186   \t\t\tsaxParser.setListener(new TriXSAXHandler());\n187   \n188   \t\t\tsaxParser.parse(inputStreamOrReader);\n189   \t\t}\n190   \t\tcatch (SAXParseException e) {\n191   \t\t\tException wrappedExc = e.getException();\n192   \n193   \t\t\tif (wrappedExc == null) {\n194   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n195   \t\t\t}\n196   \t\t\telse {\n197   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n198   \t\t\t}\n199   \t\t}\n200   \t\tcatch (SAXException e) {\n201   \t\t\tException wrappedExc = e.getException();\n202   \n203   \t\t\tif (wrappedExc == null) {\n204   \t\t\t\treportFatalError(e);\n205   \t\t\t}\n206   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n207   \t\t\t\tthrow (RDFParseException)wrappedExc;\n208   \t\t\t}\n209   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n210   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n211   \t\t\t}\n212   \t\t\telse {\n213   \t\t\t\treportFatalError(wrappedExc);\n214   \t\t\t}\n215   \t\t}\n216   \t\tfinally {\n217   \t\t\tclear();\n218   \t\t}\n219   \n220   \t\tif (rdfHandler != null) {\n221   \t\t\trdfHandler.endRDF();\n222   \t\t}\n223   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/AbstractRDFInserter.java:\n136   \t@Override\n137   \tpublic void endRDF()\n138   \t\tthrows RDFHandlerException\n139   \t{\n140   \t\tfor (Map.Entry<String, String> entry : namespaceMap.entrySet()) {\n141   \t\t\tString prefix = entry.getKey();\n142   \t\t\tString name = entry.getValue();\n143   \n144   \t\t\ttry {\n145   \t\t\t\taddNamespace(prefix, name);\n146   \t\t\t}\n147   \t\t\tcatch (RDF4JException e) {\n148   \t\t\t\tthrow new RDFHandlerException(e);\n149   \t\t\t}\n150   \t\t}\n151   \n152   \t\tnamespaceMap.clear();\n153   \t\tbNodesMap.clear();\n154   \t}\n\nsrc/rdf4j/repository/api/src/main/java/org/eclipse/rdf4j/repository/util/RDFInserter.java:\n52   \t@Override\n53   \tprotected void addNamespace(String prefix, String name)\n54   \t\tthrows RDF4JException\n55   \t{\n56   \t\tif (con.getNamespace(prefix) == null) {\n57   \t\t\tcon.setNamespace(prefix, name);\n58   \t\t}\n59   \t}\n\nsrc/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPRepositoryConnection.java:\n769   \tpublic void setNamespace(String prefix, String name)\n770   \t\tthrows RepositoryException\n771   \t{\n772   \t\tif (prefix == null) {\n773   \t\t\tthrow new NullPointerException(\"prefix must not be null\");\n774   \t\t}\n775   \t\tif (name == null) {\n776   \t\t\tthrow new NullPointerException(\"name must not be null\");\n777   \t\t}\n778   \n779   \t\tif (this.getRepository().useCompatibleMode()) {\n780   \t\t\tboolean localTransaction = startLocalTransaction();\n781   \t\t\ttxn.add(new SetNamespaceOperation(prefix, name));\n782   \t\t\tconditionalCommit(localTransaction);\n783   \t\t\treturn;\n784   \t\t}\n785   \n786   \t\ttry {\n787   \t\t\tclient.setNamespacePrefix(prefix, name);\n788   \t\t}\n789   \t\tcatch (IOException e) {\n790   \t\t\tthrow new RepositoryException(e);\n791   \t\t}\n792   \t}\n\nsrc/rdf4j/repository/http/src/main/java/org/eclipse/rdf4j/repository/http/HTTPRepository.java:\n346   \tprotected RDF4JProtocolSession createHTTPClient() {\n347   \t\t// initialize HTTP client\n348   \t\tRDF4JProtocolSession httpClient = getHttpClientSessionManager().createRDF4JProtocolSession(serverURL);\n349   \t\thttpClient.setValueFactory(SimpleValueFactory.getInstance());\n350   \t\tif (repositoryURL != null) {\n351   \t\t\thttpClient.setRepository(repositoryURL);\n352   \t\t}\n353   \t\tif (tupleFormat != null) {\n354   \t\t\thttpClient.setPreferredTupleQueryResultFormat(tupleFormat);\n355   \t\t}\n356   \t\tif (rdfFormat != null) {\n357   \t\t\thttpClient.setPreferredRDFFormat(rdfFormat);\n358   \t\t}\n359   \t\tif (username != null) {\n360   \t\t\thttpClient.setUsernameAndPassword(username, password);\n361   \t\t}\n362   \t\thttpClient.setAdditionalHttpHeaders(additionalHttpHeaders);\n363   \t\treturn httpClient;\n364   \t}\n375   \tboolean useCompatibleMode() throws RepositoryException {\n376   \t\tBoolean result = compatibleMode;\n377   \t\tif (result == null) {\n378   \t\t\tsynchronized (this) {\n379   \t\t\t\tresult = compatibleMode;\n380   \t\t\t\tif (result == null) {\n381   \t\t\t\t\ttry (RDF4JProtocolSession client = createHTTPClient()) {\n382   \t\t\t\t\t\tfinal String serverProtocolVersion = client.getServerProtocol();\n383   \n384   \t\t\t\t\t\t// protocol version 7 supports the new transaction\n385   \t\t\t\t\t\t// handling. If the server is older, we need to run in\n386   \t\t\t\t\t\t// backward-compatible mode.\n387   \t\t\t\t\t\tresult = compatibleMode = (Integer.parseInt(serverProtocolVersion) < 7);\n388   \t\t\t\t\t}\n389   \t\t\t\t\tcatch (NumberFormatException e) {\n390   \t\t\t\t\t\tthrow new RepositoryException(\"could not read protocol version from server: \", e);\n391   \t\t\t\t\t}\n392   \t\t\t\t\tcatch (IOException e) {\n393   \t\t\t\t\t\tthrow new RepositoryException(\"could not read protocol version from server: \", e);\n394   \t\t\t\t\t}\n395   \t\t\t\t}\n396   \t\t\t}\n397   \t\t}\n398   \t\treturn result;\n399   \t}\n\nsrc/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/RDF4JProtocolSession.java:\n 153   \tpublic void setRepository(String repositoryURL) {\n 154   \t\t// Try to parse the server URL from the repository URL\n 155   \t\tPattern urlPattern = Pattern.compile(\"(.*)/\" + Protocol.REPOSITORIES + \"/[^/]*/?\");\n 156   \t\tMatcher matcher = urlPattern.matcher(repositoryURL);\n 157   \n 158   \t\tif (matcher.matches() && matcher.groupCount() == 1) {\n 159   \t\t\tsetServerURL(matcher.group(1));\n 160   \t\t}\n 161   \n 162   \t\tsetQueryURL(repositoryURL);\n 163   \t}\n",
            "cost": 0.06959,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/http/client/src/main/java/org/eclipse/rdf4j/http/client/RDF4JProtocolSession.java:155:40",
            "status": "corpus",
            "valid_path": "NO",
            "id": 5
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/trix/src/main/java/org/eclipse/rdf4j/rio/trix/TriXParser.java:\n112   \t@Override\n113   \tpublic void parse(InputStream in, String baseURI)\n114   \t\tthrows IOException, RDFParseException, RDFHandlerException\n115   \t{\n116   \t\tif (in == null) {\n117   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n118   \t\t}\n119   \t\tif (baseURI == null) {\n120   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n121   \t\t}\n122   \n123   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n124   \t\tinputSource.setSystemId(baseURI);\n125   \n126   \t\tparse(inputSource);\n127   \t}\n163   \tprivate void parse(InputSource inputStreamOrReader)\n164   \t\tthrows IOException, RDFParseException, RDFHandlerException\n165   \t{\n166   \t\tclear();\n167   \t\t\n168   \t\ttry {\n169   \t\t\tif (rdfHandler != null) {\n170   \t\t\t\trdfHandler.startRDF();\n171   \t\t\t}\n172   \n173   \t\t\tXMLReader xmlReader;\n174   \n175   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n176   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n177   \t\t\t}\n178   \t\t\telse {\n179   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n180   \t\t\t}\n181   \n182   \t\t\txmlReader.setErrorHandler(this);\n183   \n184   \t\t\tsaxParser = new SimpleSAXParser(xmlReader);\n185   \t\t\tsaxParser.setPreserveWhitespace(true);\n186   \t\t\tsaxParser.setListener(new TriXSAXHandler());\n187   \n188   \t\t\tsaxParser.parse(inputStreamOrReader);\n189   \t\t}\n190   \t\tcatch (SAXParseException e) {\n191   \t\t\tException wrappedExc = e.getException();\n192   \n193   \t\t\tif (wrappedExc == null) {\n194   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n195   \t\t\t}\n196   \t\t\telse {\n197   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n198   \t\t\t}\n199   \t\t}\n200   \t\tcatch (SAXException e) {\n201   \t\t\tException wrappedExc = e.getException();\n202   \n203   \t\t\tif (wrappedExc == null) {\n204   \t\t\t\treportFatalError(e);\n205   \t\t\t}\n206   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n207   \t\t\t\tthrow (RDFParseException)wrappedExc;\n208   \t\t\t}\n209   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n210   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n211   \t\t\t}\n212   \t\t\telse {\n213   \t\t\t\treportFatalError(wrappedExc);\n214   \t\t\t}\n215   \t\t}\n216   \t\tfinally {\n217   \t\t\tclear();\n218   \t\t}\n219   \n220   \t\tif (rdfHandler != null) {\n221   \t\t\trdfHandler.endRDF();\n222   \t\t}\n223   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/BufferedGroupingRDFHandler.java:\n 87   \tprivate void processBuffer()\n 88   \t\tthrows RDFHandlerException\n 89   \t{\n 90   \t\t// primary grouping per context.\n 91   \t\tfor (Resource context : contexts) {\n 92   \t\t\tSet<Resource> subjects = GraphUtil.getSubjects(bufferedStatements, null, null, context);\n 93   \t\t\tfor (Resource subject : subjects) {\n 94   \t\t\t\tSet<IRI> processedPredicates = new HashSet<IRI>();\n 95   \n 96   \t\t\t\t// give rdf:type preference over other predicates.\n 97   \t\t\t\tIterator<Statement> typeStatements = bufferedStatements.match(subject, RDF.TYPE, null,\n 98   \t\t\t\t\t\tcontext);\n 99   \t\t\t\twhile (typeStatements.hasNext()) {\n100   \t\t\t\t\tStatement typeStatement = typeStatements.next();\n101   \t\t\t\t\tsuper.handleStatement(typeStatement);\n102   \t\t\t\t}\n103   \n104   \t\t\t\tprocessedPredicates.add(RDF.TYPE);\n105   \n106   \t\t\t\t// retrieve other statement from this context with the same\n107   \t\t\t\t// subject, and output them grouped by predicate\n108   \t\t\t\tIterator<Statement> subjectStatements = bufferedStatements.match(subject, null, null,\n109   \t\t\t\t\t\tcontext);\n110   \t\t\t\twhile (subjectStatements.hasNext()) {\n111   \t\t\t\t\tStatement subjectStatement = subjectStatements.next();\n112   \t\t\t\t\tIRI predicate = subjectStatement.getPredicate();\n113   \t\t\t\t\tif (!processedPredicates.contains(predicate)) {\n114   \t\t\t\t\t\tIterator<Statement> toWrite = bufferedStatements.match(subject, predicate, null,\n115   \t\t\t\t\t\t\t\tcontext);\n116   \t\t\t\t\t\twhile (toWrite.hasNext()) {\n117   \t\t\t\t\t\t\tStatement toWriteSt = toWrite.next();\n118   \t\t\t\t\t\t\tsuper.handleStatement(toWriteSt);\n119   \t\t\t\t\t\t}\n120   \t\t\t\t\t\tprocessedPredicates.add(predicate);\n121   \t\t\t\t\t}\n122   \t\t\t\t}\n123   \t\t\t}\n124   \t\t}\n125   \t\tbufferedStatements.clear();\n126   \t\tcontexts.clear();\n127   \t}\n129   \t@Override\n130   \tpublic void endRDF()\n131   \t\tthrows RDFHandlerException\n132   \t{\n133   \t\tsynchronized (bufferLock) {\n134   \t\t\tprocessBuffer();\n135   \t\t}\n136   \t\tsuper.endRDF();\n137   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/RDFHandlerWrapper.java:\n77   \tpublic void handleStatement(Statement st)\n78   \t\tthrows RDFHandlerException\n79   \t{\n80   \t\tfor (RDFHandler rdfHandler : rdfHandlers) {\n81   \t\t\trdfHandler.handleStatement(st);\n82   \t\t}\n83   \t}\n\nsrc/rdf4j/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLWriter.java:\n249   \tpublic void handleStatement(Statement st)\n250   \t\tthrows RDFHandlerException\n251   \t{\n252   \t\tif (!writingStarted) {\n253   \t\t\tthrow new RDFHandlerException(\"Document writing has not yet been started\");\n254   \t\t}\n255   \n256   \t\tResource subj = st.getSubject();\n257   \t\tIRI pred = st.getPredicate();\n258   \t\tValue obj = st.getObject();\n259   \n260   \t\t// Verify that an XML namespace-qualified name can be created for the\n261   \t\t// predicate\n262   \t\tString predString = pred.toString();\n263   \t\tint predSplitIdx = XMLUtil.findURISplitIndex(predString);\n264   \t\tif (predSplitIdx == -1) {\n265   \t\t\tthrow new RDFHandlerException(\n266   \t\t\t\t\t\"Unable to create XML namespace-qualified name for predicate: \" + predString);\n267   \t\t}\n268   \n269   \t\tString predNamespace = predString.substring(0, predSplitIdx);\n270   \t\tString predLocalName = predString.substring(predSplitIdx);\n271   \n272   \t\ttry {\n273   \t\t\tif (!headerWritten) {\n274   \t\t\t\twriteHeader();\n275   \t\t\t}\n276   \n277   \t\t\t// SUBJECT\n278   \t\t\tif (!subj.equals(lastWrittenSubject)) {\n279   \t\t\t\tflushPendingStatements();\n280   \n281   \t\t\t\t// Write new subject:\n282   \t\t\t\twriteNewLine();\n283   \t\t\t\twriteStartOfStartTag(RDF.NAMESPACE, \"Description\");\n284   \t\t\t\tif (subj instanceof BNode) {\n285   \t\t\t\t\tBNode bNode = (BNode)subj;\n286   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"nodeID\", getValidNodeId(bNode));\n287   \t\t\t\t}\n288   \t\t\t\telse if (baseIRI != null) {\n289   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"about\", baseIRI.relativize(subj.stringValue()));\n290   \t\t\t\t}\n291   \t\t\t\telse {\n292   \t\t\t\t\tIRI uri = (IRI)subj;\n293   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"about\", uri.toString());\n294   \t\t\t\t}\n295   \t\t\t\twriteEndOfStartTag();\n296   \t\t\t\twriteNewLine();\n297   \n298   \t\t\t\tlastWrittenSubject = subj;\n299   \t\t\t}\n300   \n301   \t\t\t// PREDICATE\n302   \t\t\twriteIndent();\n303   \t\t\twriteStartOfStartTag(predNamespace, predLocalName);\n304   \n305   \t\t\t// OBJECT\n306   \t\t\tif (obj instanceof Resource) {\n307   \t\t\t\tResource objRes = (Resource)obj;\n308   \n309   \t\t\t\tif (objRes instanceof BNode) {\n310   \t\t\t\t\tBNode bNode = (BNode)objRes;\n311   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"nodeID\", getValidNodeId(bNode));\n312   \t\t\t\t}\n313   \t\t\t\telse if (baseIRI != null) {\n314   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"resource\", baseIRI.relativize(objRes.stringValue()));\n315   \t\t\t\t}\n316   \t\t\t\telse {\n317   \t\t\t\t\tIRI uri = (IRI)objRes;\n318   \t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"resource\", uri.toString());\n319   \t\t\t\t}\n320   \n321   \t\t\t\twriteEndOfEmptyTag();\n322   \t\t\t}\n323   \t\t\telse if (obj instanceof Literal) {\n324   \t\t\t\tLiteral objLit = (Literal)obj;\n325   \t\t\t\t// datatype attribute\n326   \t\t\t\tboolean isXMLLiteral = false;\n327   \n328   \t\t\t\t// language attribute\n329   \t\t\t\tif (Literals.isLanguageLiteral(objLit)) {\n330   \t\t\t\t\twriteAttribute(\"xml:lang\", objLit.getLanguage().get());\n331   \t\t\t\t}\n332   \t\t\t\telse {\n333   \t\t\t\t\tIRI datatype = objLit.getDatatype();\n334   \t\t\t\t\t// Check if datatype is rdf:XMLLiteral\n335   \t\t\t\t\tisXMLLiteral = datatype.equals(RDF.XMLLITERAL);\n336   \n337   \t\t\t\t\tif (isXMLLiteral) {\n338   \t\t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"parseType\", \"Literal\");\n339   \t\t\t\t\t}\n340   \t\t\t\t\telse if (!datatype.equals(XMLSchema.STRING)) {\n341   \t\t\t\t\t\twriteAttribute(RDF.NAMESPACE, \"datatype\", datatype.toString());\n342   \t\t\t\t\t}\n343   \t\t\t\t}\n344   \n345   \t\t\t\twriteEndOfStartTag();\n346   \n347   \t\t\t\t// label\n348   \t\t\t\tif (isXMLLiteral) {\n349   \t\t\t\t\t// Write XML literal as plain XML\n350   \t\t\t\t\twriter.write(objLit.getLabel());\n351   \t\t\t\t}\n352   \t\t\t\telse {\n353   \t\t\t\t\twriteCharacterData(objLit.getLabel());\n354   \t\t\t\t}\n355   \n356   \t\t\t\twriteEndTag(predNamespace, predLocalName);\n357   \t\t\t}\n358   \n359   \t\t\twriteNewLine();\n360   \n361   \t\t\t// Don't write </rdf:Description> yet, maybe the next statement\n362   \t\t\t// has the same subject.\n363   \t\t}\n364   \t\tcatch (IOException e) {\n365   \t\t\tthrow new RDFHandlerException(e);\n366   \t\t}\n367   \t}\n\nsrc/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java:\n 740   \tpublic String relativize(String iri) {\n 741   \t\treturn relativize(ParsedIRI.create(iri)).toString();\n 742   \t}\n 775   \tpublic ParsedIRI relativize(ParsedIRI absolute) {\n 776   \t\t// identity URI reference\n 777   \t\tString _frag = absolute.getFragment();\n 778   \t\tif (iri.equals(absolute.iri) && _frag == null)\n 779   \t\t\treturn new ParsedIRI(null, null, null, -1, \"\", null, null);\n 780   \t\t// different scheme or authority\n 781   \t\tif (absolute.getScheme() != null && !absolute.getScheme().equalsIgnoreCase(this.getScheme())) {\n 782   \t\t\treturn absolute;\n 783   \t\t}\n 784   \t\tif (absolute.getUserInfo() != null && !absolute.getUserInfo().equals(this.getUserInfo())) {\n 785   \t\t\treturn absolute;\n 786   \t\t}\n 787   \t\tif (absolute.getHost() != null && !absolute.getHost().equalsIgnoreCase(this.getHost())) {\n 788   \t\t\treturn absolute;\n 789   \t\t}\n 790   \t\tif (absolute.getPort() != this.getPort()) {\n 791   \t\t\treturn absolute;\n 792   \t\t}\n 793   \t\t// fragment URI reference\n 794   \t\tif (_frag != null) {\n 795   \t\t\tif (this.getFragment() == null) {\n 796   \t\t\t\tif (absolute.iri.startsWith(this.iri) && absolute.iri.charAt(iri.length()) == '#') {\n 797   \t\t\t\t\treturn new ParsedIRI(null, null, null, -1, \"\", null, _frag);\n 798   \t\t\t\t}\n 799   \t\t\t}\n 800   \t\t\telse {\n 801   \t\t\t\tint this_idx = iri.length() - this.getFragment().length();\n 802   \t\t\t\tint abs_idx = absolute.iri.length() - _frag.length();\n 803   \t\t\t\tif (iri.substring(0, this_idx).equals(absolute.iri.substring(0, abs_idx))) {\n 804   \t\t\t\t\treturn new ParsedIRI(null, null, null, -1, \"\", null, _frag);\n 805   \t\t\t\t}\n 806   \t\t\t}\n 807   \t\t}\n 808   \t\t// opaque IRI\n 809   \t\tif (this.isOpaque() || absolute.isOpaque())\n 810   \t\t\treturn absolute;\n 811   \t\t// query string URI reference\n 812   \t\tString _query = absolute.getQuery();\n 813   \t\tif (_query != null) {\n 814   \t\t\tif (this.getQuery() == null && this.getFragment() == null) {\n 815   \t\t\t\tif (absolute.iri.startsWith(this.iri) && absolute.iri.charAt(iri.length()) == '?') {\n 816   \t\t\t\t\treturn new ParsedIRI(null, null, null, -1, \"\", _query, _frag);\n 817   \t\t\t\t}\n 818   \t\t\t}\n 819   \t\t\telse {\n 820   \t\t\t\tint this_idx = this.getQuery() == null ? iri.indexOf('#') : iri.indexOf('?');\n 821   \t\t\t\tint abs_idx = absolute.iri.indexOf('?');\n 822   \t\t\t\tif (iri.substring(0, this_idx).equals(absolute.iri.substring(0, abs_idx))) {\n 823   \t\t\t\t\treturn new ParsedIRI(null, null, null, -1, \"\", _query, _frag);\n 824   \t\t\t\t}\n 825   \t\t\t}\n 826   \t\t}\n 827   \t\t// last path segment\n 828   \t\tString _path = absolute.getPath();\n 829   \t\tint this_idx = this.getPath().lastIndexOf('/');\n 830   \t\tint abs_idx = _path.lastIndexOf('/');\n 831   \t\tif (this_idx < 0 || abs_idx < 0) {\n 832   \t\t\treturn absolute;\n 833   \t\t}\n 834   \t\tif (_path.equals(this.getPath().substring(0, this_idx + 1))) {\n 835   \t\t\treturn new ParsedIRI(null, null, null, -1, \".\", _query, _frag);\n 836   \t\t}\n 837   \t\t// within last path segment\n 838   \t\tif (_path.startsWith(this.getPath().substring(0, this_idx + 1))) {\n 839   \t\t\treturn new ParsedIRI(null, null, null, -1, _path.substring(this_idx + 1), _query, _frag);\n 840   \t\t}\n 841   \t\treturn new ParsedIRI(null, null, null, -1, relativizePath(_path), _query, _frag);\n 842   \t}\n1413   \tprivate String relativizePath(String absolute) {\n1414   \t\tassert absolute.charAt(0) == '/';\n1415   \t\tString[] paths = path.split(\"/\", Integer.MAX_VALUE);\n1416   \t\tString[] seg = absolute.split(\"/\", Integer.MAX_VALUE);\n1417   \t\t// first segment is empty string\n1418   \t\tint same = 1;\n1419   \t\twhile (same < paths.length && same < seg.length - 1 && paths[same].equals(seg[same])) {\n1420   \t\t\tsame++;\n1421   \t\t}\n1422   \t\tif (same < 2) // no path segments in common\n1423   \t\t\treturn absolute;\n1424   \t\tStringBuilder sb = new StringBuilder();\n1425   \t\t// last segment is empty or file name\n1426   \t\tfor (int i = same; i < paths.length - 1; i++) {\n1427   \t\t\tsb.append(\"../\");\n1428   \t\t}\n1429   \t\tfor (int i = same; i < seg.length - 1; i++) {\n1430   \t\t\tsb.append(seg[i]).append('/');\n1431   \t\t}\n1432   \t\treturn sb.append(seg[seg.length - 1]).toString();\n1433   \t}\n",
            "cost": 0.101305,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java:1415:31",
            "status": "corpus",
            "valid_path": "NO",
            "id": 6
        },
        {
            "msg": "Not sure it can happen in real, but handle later.",
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java:1416:33",
            "status": "error",
            "id": 7
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java:\n 191   \t@Override\n 192   \tpublic synchronized void parse(InputStream in, String baseURI)\n 193   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 194   \t{\n 195   \t\tif (in == null) {\n 196   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n 197   \t\t}\n 198   \t\tif (baseURI == null) {\n 199   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n 200   \t\t}\n 201   \n 202   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n 203   \t\tinputSource.setSystemId(baseURI);\n 204   \n 205   \t\tparse(inputSource);\n 206   \t}\n 242   \tprivate void parse(InputSource inputSource)\n 243   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 244   \t{\n 245   \t\tclear();\n 246   \t\t\n 247   \t\ttry {\n 248   \t\t\tdocumentURI = inputSource.getSystemId();\n 249   \n 250   \t\t\tsaxFilter.setParseStandAloneDocuments(\n 251   \t\t\t\t\tgetParserConfig().get(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS));\n 252   \n 253   \t\t\t// saxFilter.clear();\n 254   \t\t\tsaxFilter.setDocumentURI(documentURI);\n 255   \n 256   \t\t\tXMLReader xmlReader;\n 257   \n 258   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n 259   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n 260   \t\t\t}\n 261   \t\t\telse {\n 262   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n 263   \t\t\t}\n 264   \n 265   \t\t\txmlReader.setContentHandler(saxFilter);\n 266   \t\t\txmlReader.setErrorHandler(this);\n 267   \n 268   \t\t\t// Set all compulsory feature settings, using the defaults if they are\n 269   \t\t\t// not explicitly set\n 270   \t\t\tfor (RioSetting<Boolean> aSetting : getCompulsoryXmlFeatureSettings()) {\n 271   \t\t\t\ttry {\n 272   \t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 273   \t\t\t\t}\n 274   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 275   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 276   \t\t\t\t}\n 277   \t\t\t\tcatch (SAXNotSupportedException e) {\n 278   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 279   \t\t\t\t}\n 280   \t\t\t}\n 281   \n 282   \t\t\t// Set all compulsory property settings, using the defaults if they are\n 283   \t\t\t// not explicitly set\n 284   \t\t\tfor (RioSetting<?> aSetting : getCompulsoryXmlPropertySettings()) {\n 285   \t\t\t\ttry {\n 286   \t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 287   \t\t\t\t}\n 288   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 289   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 290   \t\t\t\t}\n 291   \t\t\t\tcatch (SAXNotSupportedException e) {\n 292   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 293   \t\t\t\t}\n 294   \t\t\t}\n 295   \n 296   \t\t\t// Check for any optional feature settings that are explicitly set in\n 297   \t\t\t// the parser config\n 298   \t\t\tfor (RioSetting<Boolean> aSetting : getOptionalXmlFeatureSettings()) {\n 299   \t\t\t\ttry {\n 300   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 301   \t\t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 302   \t\t\t\t\t}\n 303   \t\t\t\t}\n 304   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 305   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 306   \t\t\t\t}\n 307   \t\t\t\tcatch (SAXNotSupportedException e) {\n 308   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 309   \t\t\t\t}\n 310   \t\t\t}\n 311   \n 312   \t\t\t// Check for any optional property settings that are explicitly set in\n 313   \t\t\t// the parser config\n 314   \t\t\tfor (RioSetting<?> aSetting : getOptionalXmlPropertySettings()) {\n 315   \t\t\t\ttry {\n 316   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 317   \t\t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 318   \t\t\t\t\t}\n 319   \t\t\t\t}\n 320   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 321   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 322   \t\t\t\t}\n 323   \t\t\t\tcatch (SAXNotSupportedException e) {\n 324   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 325   \t\t\t\t}\n 326   \t\t\t}\n 327   \n 328   \t\t\txmlReader.parse(inputSource);\n 329   \t\t}\n 330   \t\tcatch (SAXParseException e) {\n 331   \t\t\tException wrappedExc = e.getException();\n 332   \n 333   \t\t\tif (wrappedExc == null) {\n 334   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n 335   \t\t\t}\n 336   \t\t\telse {\n 337   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n 338   \t\t\t}\n 339   \t\t}\n 340   \t\tcatch (SAXException e) {\n 341   \t\t\tException wrappedExc = e.getException();\n 342   \n 343   \t\t\tif (wrappedExc == null) {\n 344   \t\t\t\treportFatalError(e);\n 345   \t\t\t}\n 346   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n 347   \t\t\t\tthrow (RDFParseException)wrappedExc;\n 348   \t\t\t}\n 349   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n 350   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n 351   \t\t\t}\n 352   \t\t\telse {\n 353   \t\t\t\treportFatalError(wrappedExc);\n 354   \t\t\t}\n 355   \t\t}\n 356   \t\tfinally {\n 357   \t\t\t// Clean up\n 358   \t\t\tsaxFilter.clear();\n 359   \t\t\txmlLang = null;\n 360   \t\t\telementStack.clear();\n 361   \t\t\tusedIDs.clear();\n 362   \t\t\tclear();\n 363   \t\t}\n 364   \t}\n\nsrc/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/AbstractRDFParser.java:\n350   \tprotected void clear() {\n351   \t\tbaseURI = null;\n352   \t\tnextBNodePrefix = createUniqueBNodePrefix();\n353   \t\tnamespaceTable.clear();\n354   \n355   \t\tinitializeNamespaceTableFromConfiguration();\n356   \t}\n786   \tprivate final String createUniqueBNodePrefix() {\n787   \t\treturn UUID.randomUUID().toString().replaceAll(\"-\", \"\") + \"-\";\n788   \t}\n",
            "cost": 0.06364500000000001,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/rio/api/src/main/java/org/eclipse/rdf4j/rio/helpers/AbstractRDFParser.java:787:50",
            "status": "corpus",
            "valid_path": "NO",
            "id": 8
        },
        {
            "blob": [
                ""
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n\nsrc/rdf4j/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/RDFXMLParser.java:\n 191   \t@Override\n 192   \tpublic synchronized void parse(InputStream in, String baseURI)\n 193   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 194   \t{\n 195   \t\tif (in == null) {\n 196   \t\t\tthrow new IllegalArgumentException(\"Input stream cannot be 'null'\");\n 197   \t\t}\n 198   \t\tif (baseURI == null) {\n 199   \t\t\tthrow new IllegalArgumentException(\"Base URI cannot be 'null'\");\n 200   \t\t}\n 201   \n 202   \t\tInputSource inputSource = new InputSource(new BOMInputStream(in, false));\n 203   \t\tinputSource.setSystemId(baseURI);\n 204   \n 205   \t\tparse(inputSource);\n 206   \t}\n 242   \tprivate void parse(InputSource inputSource)\n 243   \t\tthrows IOException, RDFParseException, RDFHandlerException\n 244   \t{\n 245   \t\tclear();\n 246   \t\t\n 247   \t\ttry {\n 248   \t\t\tdocumentURI = inputSource.getSystemId();\n 249   \n 250   \t\t\tsaxFilter.setParseStandAloneDocuments(\n 251   \t\t\t\t\tgetParserConfig().get(XMLParserSettings.PARSE_STANDALONE_DOCUMENTS));\n 252   \n 253   \t\t\t// saxFilter.clear();\n 254   \t\t\tsaxFilter.setDocumentURI(documentURI);\n 255   \n 256   \t\t\tXMLReader xmlReader;\n 257   \n 258   \t\t\tif (getParserConfig().isSet(XMLParserSettings.CUSTOM_XML_READER)) {\n 259   \t\t\t\txmlReader = getParserConfig().get(XMLParserSettings.CUSTOM_XML_READER);\n 260   \t\t\t}\n 261   \t\t\telse {\n 262   \t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n 263   \t\t\t}\n 264   \n 265   \t\t\txmlReader.setContentHandler(saxFilter);\n 266   \t\t\txmlReader.setErrorHandler(this);\n 267   \n 268   \t\t\t// Set all compulsory feature settings, using the defaults if they are\n 269   \t\t\t// not explicitly set\n 270   \t\t\tfor (RioSetting<Boolean> aSetting : getCompulsoryXmlFeatureSettings()) {\n 271   \t\t\t\ttry {\n 272   \t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 273   \t\t\t\t}\n 274   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 275   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 276   \t\t\t\t}\n 277   \t\t\t\tcatch (SAXNotSupportedException e) {\n 278   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 279   \t\t\t\t}\n 280   \t\t\t}\n 281   \n 282   \t\t\t// Set all compulsory property settings, using the defaults if they are\n 283   \t\t\t// not explicitly set\n 284   \t\t\tfor (RioSetting<?> aSetting : getCompulsoryXmlPropertySettings()) {\n 285   \t\t\t\ttry {\n 286   \t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 287   \t\t\t\t}\n 288   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 289   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 290   \t\t\t\t}\n 291   \t\t\t\tcatch (SAXNotSupportedException e) {\n 292   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 293   \t\t\t\t}\n 294   \t\t\t}\n 295   \n 296   \t\t\t// Check for any optional feature settings that are explicitly set in\n 297   \t\t\t// the parser config\n 298   \t\t\tfor (RioSetting<Boolean> aSetting : getOptionalXmlFeatureSettings()) {\n 299   \t\t\t\ttry {\n 300   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 301   \t\t\t\t\t\txmlReader.setFeature(aSetting.getKey(), getParserConfig().get(aSetting));\n 302   \t\t\t\t\t}\n 303   \t\t\t\t}\n 304   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 305   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX feature.\", aSetting.getKey()));\n 306   \t\t\t\t}\n 307   \t\t\t\tcatch (SAXNotSupportedException e) {\n 308   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX feature.\", aSetting.getKey()));\n 309   \t\t\t\t}\n 310   \t\t\t}\n 311   \n 312   \t\t\t// Check for any optional property settings that are explicitly set in\n 313   \t\t\t// the parser config\n 314   \t\t\tfor (RioSetting<?> aSetting : getOptionalXmlPropertySettings()) {\n 315   \t\t\t\ttry {\n 316   \t\t\t\t\tif (getParserConfig().isSet(aSetting)) {\n 317   \t\t\t\t\t\txmlReader.setProperty(aSetting.getKey(), getParserConfig().get(aSetting));\n 318   \t\t\t\t\t}\n 319   \t\t\t\t}\n 320   \t\t\t\tcatch (SAXNotRecognizedException e) {\n 321   \t\t\t\t\treportWarning(String.format(\"%s is not a recognized SAX property.\", aSetting.getKey()));\n 322   \t\t\t\t}\n 323   \t\t\t\tcatch (SAXNotSupportedException e) {\n 324   \t\t\t\t\treportWarning(String.format(\"%s is not a supported SAX property.\", aSetting.getKey()));\n 325   \t\t\t\t}\n 326   \t\t\t}\n 327   \n 328   \t\t\txmlReader.parse(inputSource);\n 329   \t\t}\n 330   \t\tcatch (SAXParseException e) {\n 331   \t\t\tException wrappedExc = e.getException();\n 332   \n 333   \t\t\tif (wrappedExc == null) {\n 334   \t\t\t\treportFatalError(e, e.getLineNumber(), e.getColumnNumber());\n 335   \t\t\t}\n 336   \t\t\telse {\n 337   \t\t\t\treportFatalError(wrappedExc, e.getLineNumber(), e.getColumnNumber());\n 338   \t\t\t}\n 339   \t\t}\n 340   \t\tcatch (SAXException e) {\n 341   \t\t\tException wrappedExc = e.getException();\n 342   \n 343   \t\t\tif (wrappedExc == null) {\n 344   \t\t\t\treportFatalError(e);\n 345   \t\t\t}\n 346   \t\t\telse if (wrappedExc instanceof RDFParseException) {\n 347   \t\t\t\tthrow (RDFParseException)wrappedExc;\n 348   \t\t\t}\n 349   \t\t\telse if (wrappedExc instanceof RDFHandlerException) {\n 350   \t\t\t\tthrow (RDFHandlerException)wrappedExc;\n 351   \t\t\t}\n 352   \t\t\telse {\n 353   \t\t\t\treportFatalError(wrappedExc);\n 354   \t\t\t}\n 355   \t\t}\n 356   \t\tfinally {\n 357   \t\t\t// Clean up\n 358   \t\t\tsaxFilter.clear();\n 359   \t\t\txmlLang = null;\n 360   \t\t\telementStack.clear();\n 361   \t\t\tusedIDs.clear();\n 362   \t\t\tclear();\n 363   \t\t}\n 364   \t}\n\nsrc/rdf4j/rio/rdfxml/src/main/java/org/eclipse/rdf4j/rio/rdfxml/SAXFilter.java:\n150   \tpublic void setDocumentURI(String documentURI) {\n151   \t\tthis.documentURI = createBaseURI(documentURI);\n152   \t}\n550   \tprivate ParsedIRI createBaseURI(String uriString) {\n551   \t\treturn ParsedIRI.create(uriString).normalize();\n552   \t}\n\nsrc/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java:\n 571   \tpublic ParsedIRI normalize() {\n 572   \t\tString _scheme = toLowerCase(scheme);\n 573   \t\tboolean optionalPort = isScheme(\"http\") && 80 == port || isScheme(\"https\") && 443 == port;\n 574   \t\tint _port = optionalPort ? -1 : port;\n 575   \t\tboolean localhost = isScheme(\"file\") && userInfo == null && -1 == port\n 576   \t\t\t\t&& (\"\".equals(host) || \"localhost\".equals(host));\n 577   \t\tString _host = localhost ? null\n 578   \t\t\t\t: host == null || host.length() == 0 ? host\n 579   \t\t\t\t\t\t: IDN.toUnicode(pctEncodingNormalization(toLowerCase(host)),\n 580   \t\t\t\t\t\t\t\tIDN.USE_STD3_ASCII_RULES | IDN.ALLOW_UNASSIGNED);\n 581   \t\tString _path = _scheme != null && path == null ? \"\" : normalizePath(path);\n 582   \t\tString _userInfo = pctEncodingNormalization(userInfo);\n 583   \t\tString _query = pctEncodingNormalization(query);\n 584   \t\tString _fragment = pctEncodingNormalization(fragment);\n 585   \t\tParsedIRI normalized = new ParsedIRI(_scheme, _userInfo, _host, _port, _path, _query, _fragment);\n 586   \t\tif (this.iri.equals(normalized.iri)) {\n 587   \t\t\treturn this;\n 588   \t\t}\n 589   \t\telse {\n 590   \t\t\treturn normalized;\n 591   \t\t}\n 592   \t}\n1195   \tprivate String normalizePath(String path) {\n1196   \t\tif (\"\".equals(path)) {\n1197   \t\t\treturn isScheme(\"http\") || isScheme(\"https\") ? \"/\" : \"\";\n1198   \t\t}\n1199   \t\telse if (isScheme(\"file\")) {\n1200   \t\t\tif (path.indexOf(\"%5C\") >= 0) {\n1201   \t\t\t\t// replace \"/c:\\path\\to\\file\" with \"/c:/path/to/file\"\n1202   \t\t\t\treturn normalizePath(path.replace(\"%5C\", \"/\"));\n1203   \t\t\t}\n1204   \t\t\telse if (!path.startsWith(\"/\") && isMember(ALPHA, path.codePointAt(0))\n1205   \t\t\t\t\t&& (':' == path.charAt(1) || path.length() >= 4 && \"%7C\".equals(path.substring(1, 4))))\n1206   \t\t\t{\n1207   \t\t\t\t// replace \"c:/path/to/file\" with \"/c:/path/to/file\"\n1208   \t\t\t\treturn normalizePath(\"/\" + path);\n1209   \t\t\t}\n1210   \t\t\telse if (path.length() >= 5 && \"%7C\".equals(path.substring(2, 5))\n1211   \t\t\t\t\t&& isMember(ALPHA, path.codePointAt(1)))\n1212   \t\t\t{\n1213   \t\t\t\t// replace \"/c|/path/to/file\" with \"/c:/path/to/file\"\n1214   \t\t\t\treturn normalizePath(path.substring(0, 2) + ':' + path.substring(5));\n1215   \t\t\t}\n1216   \t\t}\n1217   \t\treturn pctEncodingNormalization(pathSegmentNormalization(path));\n1218   \t}\n1309   \tprivate String pathSegmentNormalization(String _path) {\n1310   \t\tif (_path == null) {\n1311   \t\t\treturn null;\n1312   \t\t}\n1313   \n1314   \t\t// Remove any '.' segments:\n1315   \n1316   \t\t_path = StringUtil.gsub(\"/./\", \"/\", _path);\n1317   \n1318   \t\tif (_path.startsWith(\"./\")) {\n1319   \t\t\t// Remove both characters\n1320   \t\t\t_path = _path.substring(2);\n1321   \t\t}\n1322   \n1323   \t\tif (_path.endsWith(\"/.\")) {\n1324   \t\t\t// Remove only the last dot, not the slash!\n1325   \t\t\t_path = _path.substring(0, _path.length() - 1);\n1326   \t\t}\n1327   \n1328   \t\tif (_path.indexOf(\"/../\") == -1 && !_path.endsWith(\"/..\")) {\n1329   \t\t\t// There are no '..' segments that can be removed. We're done and\n1330   \t\t\t// don't have to execute the time-consuming code following this\n1331   \t\t\t// if-statement\n1332   \t\t\treturn _path;\n1333   \t\t}\n1334   \n1335   \t\t// Split the path into its segments\n1336   \n1337   \t\tLinkedList<String> segments = new LinkedList<String>(Arrays.asList(_path.split(\"/\")));\n1338   \t\tif (_path.startsWith(\"/\")) {\n1339   \t\t\tsegments.remove(0);\n1340   \t\t}\n1341   \n1342   \t\tboolean lastSegmentRemoved = false;\n1343   \n1344   \t\t// Remove all unnecessary '..' segments\n1345   \n1346   \t\tint i = 1;\n1347   \t\twhile (i < segments.size()) {\n1348   \t\t\tString segment = segments.get(i);\n1349   \n1350   \t\t\tif (segment.equals(\"..\")) {\n1351   \t\t\t\tString prevSegment = segments.get(i - 1);\n1352   \n1353   \t\t\t\tif (prevSegment.equals(\"..\")) {\n1354   \t\t\t\t\t// two consecutive '..' segments at position i-1 and i,\n1355   \t\t\t\t\t// continue at i + 2\n1356   \t\t\t\t\ti += 2;\n1357   \t\t\t\t}\n1358   \t\t\t\telse {\n1359   \t\t\t\t\t// Bingo! Remove these two segments...\n1360   \t\t\t\t\tif (i == segments.size() - 1) {\n1361   \t\t\t\t\t\tlastSegmentRemoved = true;\n1362   \t\t\t\t\t}\n1363   \n1364   \t\t\t\t\tsegments.remove(i);\n1365   \t\t\t\t\tsegments.remove(i - 1);\n1366   \n1367   \t\t\t\t\t// ...and continue at position (i + 1 - 2) == (i - 1)...\n1368   \n1369   \t\t\t\t\t// ...but only if i > 1, position 0 does not need to be\n1370   \t\t\t\t\t// checked.\n1371   \n1372   \t\t\t\t\tif (i > 1) {\n1373   \t\t\t\t\t\ti--;\n1374   \t\t\t\t\t}\n1375   \t\t\t\t}\n1376   \t\t\t}\n1377   \t\t\telse {\n1378   \t\t\t\t// Not a '..' segment, check next\n1379   \t\t\t\ti++;\n1380   \t\t\t}\n1381   \t\t}\n1382   \n1383   \t\twhile (!segments.isEmpty() && (segments.get(0).equals(\"..\") || segments.get(0).equals(\".\"))) {\n1384   \t\t\tsegments.remove(0);\n1385   \t\t}\n1386   \n1387   \t\t// Construct the normalized path\n1388   \n1389   \t\tStringBuilder newPath = new StringBuilder(_path.length());\n1390   \n1391   \t\tif (_path.startsWith(\"/\")) {\n1392   \t\t\tnewPath.append('/');\n1393   \t\t}\n1394   \n1395   \t\tint segmentCount = segments.size();\n1396   \t\tfor (i = 0; i < segmentCount - 1; i++) {\n1397   \t\t\tnewPath.append(segments.get(i));\n1398   \t\t\tnewPath.append('/');\n1399   \t\t}\n1400   \n1401   \t\tif (segmentCount > 0) {\n1402   \t\t\tString lastSegment = segments.get(segmentCount - 1);\n1403   \t\t\tnewPath.append(lastSegment);\n1404   \n1405   \t\t\tif (_path.endsWith(\"/\") || lastSegmentRemoved) {\n1406   \t\t\t\tnewPath.append('/');\n1407   \t\t\t}\n1408   \t\t}\n1409   \n1410   \t\treturn newPath.toString();\n1411   \t}\n",
            "cost": 0.09951,
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/net/ParsedIRI.java:1337:82",
            "status": "corpus",
            "valid_path": "NO",
            "id": 9
        },
        {
            "msg": "Not sure it can happen in real, but handle later.",
            "harness_id": "id_1",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/rdf4j/repository/sparql/src/main/java/org/eclipse/rdf4j/repository/sparql/query/QueryStringUtil.java:123:26",
            "status": "error",
            "id": 10
        },
        {
            "blob": [
                "AAAAAwAAAAEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2Fs"
            ],
            "code": "src/rdf4j-harnesses/rdf4j-harness-one/src/main/java/com/aixcc/rdf4j/harnesses/one/Rdf4jOne.java:\n23       public static void fuzzerTestOneInput(byte[] data) throws Throwable {\n24           new Rdf4jOne().fuzz(data);\n25       }\n27       public void fuzz(byte[] data) throws Throwable {\n28           if (data.length < Integer.BYTES + Integer.BYTES + 1) {\n29               return;\n30           }\n31   \n32           ByteBuffer buf = ByteBuffer.wrap(data);\n33           int picker = buf.getInt();\n34           int count = buf.getInt();\n35           byte[] whole = Arrays.copyOfRange(data, Integer.BYTES * 2, data.length);\n36           if (count > 255) {\n37               return;\n38           }\n39   \n40           for (int i = 0; i < count; i++) {\n41               try {\n42                   switch (picker) {\n43                       case 3:\n44                           extract(whole);\n45                           break;\n46                       case 5:\n47                           new RDFXMLParser().parse(new ByteArrayInputStream(whole), \"\");\n48                           break;\n49                       case 6:\n50                           new TriXParser().parse(new ByteArrayInputStream(whole), \"\");\n51                           break;\n52                       default:\n53                           throw new Exception(\"unsupported\");\n54                   }\n55               } catch (FuzzerSecurityIssueLow |\n56                        FuzzerSecurityIssueMedium |\n57                        FuzzerSecurityIssueHigh |\n58                        FuzzerSecurityIssueCritical e) {\n59                   throw e;\n60               } catch (Throwable e) {\n61               }\n62           }\n63       }\n65       public void extract(byte[] data) throws Throwable {\n66           Path dir = Paths.get(\"/tmp/rdf4j\");\n67           Files.createDirectories(dir);\n68   \n69           File f = new File(\"/tmp/rdf4j/testnotok.zip\");\n70   \t\ttry (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(f))) {\n71   \t\t\tZipEntry e = new ZipEntry(new String(data));\n72   \t\t\tout.putNextEntry(e);\n73   \t\t\tout.write(\"hello world\".getBytes());\n74   \t\t\tout.closeEntry();\n75   \t\t}\n76   \n77   \t\tZipFile zf = new ZipFile(f);\n78           Path extractDir = Paths.get(\"/tmp/rdf4j/extract\");\n79           Files.createDirectories(extractDir);\n80   \n81           ZipUtil.extract(zf, extractDir.toFile());\n82           Files.deleteIfExists(dir);\n83       }\n\nsrc/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/ZipUtil.java:\n 70   \tpublic static void extract(ZipFile zipFile, File destDir)\n 71   \t\tthrows IOException\n 72   \t{\n 73   \t\tassert destDir.isDirectory();\n 74   \n 75   \t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n 76   \t\twhile (entries.hasMoreElements()) {\n 77   \t\t\tZipEntry entry = entries.nextElement();\n 78   \t\t\twriteEntry(zipFile, entry, destDir);\n 79   \t\t}\n 80   \t}\n 94   \tpublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n 95   \t\tthrows IOException\n 96   \t{\n 97   \t\tFile outFile = new File(destDir, entry.getName());\n 98   \n 99   \t\tif (entry.isDirectory()) {\n100   \t\t\toutFile.mkdirs();\n101   \t\t}\n102   \t\telse {\n103   \t\t\toutFile.getParentFile().mkdirs();\n104   \n105   \t\t\tInputStream in = zipFile.getInputStream(entry);\n106   \t\t\ttry {\n107   \t\t\t\tIOUtil.writeStream(in, outFile);\n108   \t\t\t}\n109   \t\t\tfinally {\n110   \t\t\t\tin.close();\n111   \t\t\t}\n112   \t\t}\n113   \t}\n\nsrc/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java:\n384   \tpublic static void writeStream(InputStream in, File file)\n385   \t\tthrows IOException\n386   \t{\n387   \t\tFileOutputStream out = new FileOutputStream(file);\n388   \n389   \t\ttry {\n390   \t\t\ttransfer(in, out);\n391   \t\t}\n392   \t\tfinally {\n393   \t\t\ttry {\n394   \t\t\t\tout.flush();\n395   \t\t\t}\n396   \t\t\tfinally {\n397   \t\t\t\tout.close();\n398   \t\t\t}\n399   \t\t}\n400   \t}\n",
            "cost": 0.37757,
            "harness_id": "id_1",
            "sanitizer": "File read/write hook path",
            "sink": "src/rdf4j/util/src/main/java/org/eclipse/rdf4j/common/io/IOUtil.java:387:47",
            "status": "corpus",
            "valid_path": "YES",
            "id": 11
        }
    ],
    "result": [
        {
            "harness_id": "id_1",
            "blob": [
                "",
                "AAAAAwAAAAEuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2Fs"
            ]
        }
    ]
}