{
    "sinks": {
        "OS Command Injection": [
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java",
                "line": 239,
                "column": 27
            }
        ],
        "Server Side Request Forgery (SSRF)": [
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/EMail.java",
                "line": 121,
                "column": 36
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 207,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/url/UrlChecker.java",
                "line": 108,
                "column": 13
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1115,
                "column": 18
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/extent/MapRenderer.java",
                "line": 202,
                "column": 22
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/thredds/Harvester.java",
                "line": 721,
                "column": 31
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 205,
                "column": 27
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/wfsfeatures/Harvester.java",
                "line": 242,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/services/http/Get.java",
                "line": 93,
                "column": 27
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1109,
                "column": 31
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/extent/MapRenderer.java",
                "line": 199,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/services/http/Get.java",
                "line": 79,
                "column": 33
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/url/UrlChecker.java",
                "line": 105,
                "column": 41
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 202,
                "column": 39
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/es/EsHTTPProxy.java",
                "line": 465,
                "column": 31
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java",
                "line": 171,
                "column": 68
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java",
                "line": 182,
                "column": 72
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java",
                "line": 184,
                "column": 72
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java",
                "line": 196,
                "column": 68
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 482,
                "column": 62
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/geonetwork/map/wms/SLDUtil.java",
                "line": 56,
                "column": 58
            },
            {
                "path": "src/geonetwork/integration-test/src/main/java/methods/NavigateMethods.java",
                "line": 123,
                "column": 51
            },
            {
                "path": "src/geonetwork/integration-test/src/main/java/methods/NavigateMethods.java",
                "line": 185,
                "column": 56
            }
        ],
        "Remote Code Execution": [
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 384,
                "column": 53
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 461,
                "column": 61
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/converter/JpaConverterJson.java",
                "line": 44,
                "column": 43
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/csw/Aligner.java",
                "line": 361,
                "column": 67
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 299,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 312,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiapi/search/XsltResponseWriter.java",
                "line": 160,
                "column": 59
            }
        ],
        "SQL Injection": [
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/MetadataResourceDatabaseMigration.java",
                "line": 178,
                "column": 22
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/lib/DbLib.java",
                "line": 164,
                "column": 52
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/lib/DbLib.java",
                "line": 166,
                "column": 47
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 111,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 231,
                "column": 58
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 304,
                "column": 31
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 305,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/DatabaseMigration.java",
                "line": 347,
                "column": 57
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/DatabaseMigration.java",
                "line": 358,
                "column": 57
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 198,
                "column": 71
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 208,
                "column": 35
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 212,
                "column": 80
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 224,
                "column": 35
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 231,
                "column": 72
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/EncryptorInitializer.java",
                "line": 242,
                "column": 35
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 40,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 41,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 45,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 46,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 50,
                "column": 64
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 95,
                "column": 65
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 111,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 122,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 47,
                "column": 66
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 60,
                "column": 64
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 71,
                "column": 66
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 85,
                "column": 35
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 114,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 123,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 151,
                "column": 52
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 161,
                "column": 56
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 273,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 286,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 314,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 326,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 338,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v400/UpdateAllSequenceValueToMax.java",
                "line": 146,
                "column": 68
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 40,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 41,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 45,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v2110/MoveHarvesterSettings.java",
                "line": 46,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 50,
                "column": 64
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 95,
                "column": 65
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 111,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v280/MoveHarvesterSettingsToHigherNumber.java",
                "line": 122,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 47,
                "column": 66
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 60,
                "column": 64
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 71,
                "column": 66
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v300/SetSequenceValueToMaxOfMetadataAndStats.java",
                "line": 85,
                "column": 35
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 114,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 123,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 151,
                "column": 52
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 161,
                "column": 56
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 273,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 286,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 314,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 326,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 338,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v400/UpdateAllSequenceValueToMax.java",
                "line": 146,
                "column": 68
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/DiskbackedCache.java",
                "line": 137,
                "column": 31
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/DiskbackedCache.java",
                "line": 148,
                "column": 56
            }
        ],
        "LDAP Injection": [
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPSynchronizerJob.java",
                "line": 156,
                "column": 34
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPSynchronizerJob.java",
                "line": 156,
                "column": 54
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPSynchronizerJob.java",
                "line": 212,
                "column": 35
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPSynchronizerJob.java",
                "line": 212,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 100,
                "column": 42
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 100,
                "column": 59
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 159,
                "column": 42
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 159,
                "column": 60
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearchEnhanced.java",
                "line": 172,
                "column": 42
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearchEnhanced.java",
                "line": 172,
                "column": 71
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LdapUserDetailsManager.java",
                "line": 251,
                "column": 35
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LdapUserDetailsManager.java",
                "line": 251,
                "column": 52
            }
        ],
        "load arbitrary library": [
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/monitor/MonitorManager.java",
                "line": 242,
                "column": 45
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/JeevesEngine.java",
                "line": 412,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/dispatchers/ServiceManager.java",
                "line": 243,
                "column": 51
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/dispatchers/guiservices/Call.java",
                "line": 67,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/metadata/StatusActionsFactory.java",
                "line": 50,
                "column": 69
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/metadata/StatusActionsFactory.java",
                "line": 58,
                "column": 73
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 59,
                "column": 84
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 93,
                "column": 31
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/migration/MigrationApi.java",
                "line": 67,
                "column": 44
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/DatabaseMigration.java",
                "line": 88,
                "column": 31
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/DatabaseMigration.java",
                "line": 282,
                "column": 80
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v400/UpdateAllSequenceValueToMax.java",
                "line": 73,
                "column": 36
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v400/UpdateAllSequenceValueToMax.java",
                "line": 73,
                "column": 36
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/DiskbackedCache.java",
                "line": 75,
                "column": 27
            }
        ],
        "Regular Expression Injection": [
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/exceptions/JeevesException.java",
                "line": 81,
                "column": 41
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/BinaryFile.java",
                "line": 299,
                "column": 50
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/DateUtil.java",
                "line": 174,
                "column": 82
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/Version.java",
                "line": 30,
                "column": 45
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/Xml.java",
                "line": 474,
                "column": 60
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/Xml.java",
                "line": 1134,
                "column": 43
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlElementReader.java",
                "line": 326,
                "column": 42
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlElementReader.java",
                "line": 331,
                "column": 45
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlElementReader.java",
                "line": 406,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/JeevesContextLoaderListener.java",
                "line": 52,
                "column": 61
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/JeevesDelegatingFilterProxy.java",
                "line": 130,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/JeevesDelegatingFilterProxy.java",
                "line": 152,
                "column": 58
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/JeevesDispatcherServlet.java",
                "line": 79,
                "column": 53
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/local/LocalServiceRequest.java",
                "line": 125,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/local/LocalServiceRequest.java",
                "line": 150,
                "column": 39
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/local/LocalServiceRequest.java",
                "line": 157,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/local/LocalServiceRequest.java",
                "line": 163,
                "column": 39
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/local/LocalServiceRequest.java",
                "line": 204,
                "column": 28
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/sources/ServiceRequestFactory.java",
                "line": 344,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/sources/ServiceRequestFactory.java",
                "line": 347,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/services/RegExpReplace.java",
                "line": 73,
                "column": 42
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/services/db/Select.java",
                "line": 361,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 195,
                "column": 38
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 202,
                "column": 54
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 260,
                "column": 30
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java",
                "line": 422,
                "column": 62
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 129,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 500,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 504,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 508,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 512,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 516,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 520,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 525,
                "column": 90
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 543,
                "column": 94
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 547,
                "column": 94
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/S3Store.java",
                "line": 97,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/AccessManager.java",
                "line": 603,
                "column": 53
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 107,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 294,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 306,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 332,
                "column": 59
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 504,
                "column": 39
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/EditLib.java",
                "line": 703,
                "column": 69
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/KeywordBean.java",
                "line": 413,
                "column": 31
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/KeywordBean.java",
                "line": 437,
                "column": 41
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/KeywordBean.java",
                "line": 635,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchemaManager.java",
                "line": 1805,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java",
                "line": 111,
                "column": 61
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java",
                "line": 114,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java",
                "line": 117,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java",
                "line": 118,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java",
                "line": 571,
                "column": 101
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/oaipmh/services/ListMetadataFormats.java",
                "line": 92,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/rdf/KeywordResultInterpreter.java",
                "line": 89,
                "column": 39
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/schema/SimpleTypeEntry.java",
                "line": 137,
                "column": 60
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 57,
                "column": 38
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/TranslatorFactory.java",
                "line": 67,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/keycloak/KeycloakAuthenticationProcessingFilter.java",
                "line": 208,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/keycloak/KeycloakUserUtils.java",
                "line": 168,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/keycloak/KeycloakUserUtils.java",
                "line": 230,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/keycloak/KeycloakUtil.java",
                "line": 50,
                "column": 87
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/AbstractLDAPUserDetailsContextMapper.java",
                "line": 227,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPRoleConverterGroupNameParser.java",
                "line": 120,
                "column": 58
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPSynchronizerJob.java",
                "line": 215,
                "column": 66
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithPattern.java",
                "line": 107,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 257,
                "column": 58
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 275,
                "column": 22
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearch.java",
                "line": 316,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/ldap/LDAPUserDetailsContextMapperWithProfileSearchEnhanced.java",
                "line": 114,
                "column": 34
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/shibboleth/ShibbolethUserUtils.java",
                "line": 113,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/shibboleth/ShibbolethUserUtils.java",
                "line": 118,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/shibboleth/ShibbolethUserUtils.java",
                "line": 124,
                "column": 45
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/shibboleth/ShibbolethUserUtils.java",
                "line": 229,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/security/shibboleth/ShibbolethUserUtils.java",
                "line": 276,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/setting/SettingManager.java",
                "line": 133,
                "column": 53
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/lib/NetLib.java",
                "line": 247,
                "column": 41
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 407,
                "column": 52
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 283,
                "column": 52
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/security/web/csrf/GeonetworkCsrfSecurityRequestMatcher.java",
                "line": 41,
                "column": 54
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/services/util/z3950/GNSearchSessionFactory.java",
                "line": 109,
                "column": 41
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/services/util/z3950/GNXMLQuery.java",
                "line": 145,
                "column": 49
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/services/util/z3950/jzkitextensions/GNCQLString.java",
                "line": 145,
                "column": 43
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/WorkflowUtil.java",
                "line": 52,
                "column": 53
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 269,
                "column": 73
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 269,
                "column": 51
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 288,
                "column": 51
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 555,
                "column": 43
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 620,
                "column": 57
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 838,
                "column": 39
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 983,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1027,
                "column": 31
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1030,
                "column": 45
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1143,
                "column": 52
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1253,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1274,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 1299,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/XslUtil.java",
                "line": 984,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/CORSResponseFilter.java",
                "line": 74,
                "column": 71
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/CORSResponseFilter.java",
                "line": 100,
                "column": 75
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 268,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 270,
                "column": 30
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 272,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 274,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 276,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 278,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 280,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 282,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 284,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 286,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 288,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 290,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 292,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 294,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 296,
                "column": 37
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/web/LocaleRedirects.java",
                "line": 298,
                "column": 37
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/component/csw/GetDomain.java",
                "line": 409,
                "column": 36
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/csw/common/requests/CatalogRequest.java",
                "line": 149,
                "column": 43
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/csw/common/requests/CatalogRequest.java",
                "line": 151,
                "column": 44
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/kernel/csw/services/getrecords/es/CswFilter2Es.java",
                "line": 191,
                "column": 32
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/kernel/csw/services/getrecords/es/CswFilter2Es.java",
                "line": 199,
                "column": 32
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/kernel/csw/services/getrecords/es/CswFilter2Es.java",
                "line": 206,
                "column": 40
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/kernel/csw/services/getrecords/es/CswFilter2Es.java",
                "line": 210,
                "column": 40
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/kernel/csw/services/getrecords/es/CswFilter2Es.java",
                "line": 214,
                "column": 40
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/ISODate.java",
                "line": 379,
                "column": 44
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/UserSecurity.java",
                "line": 107,
                "column": 58
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java",
                "line": 142,
                "column": 36
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java",
                "line": 145,
                "column": 38
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/repository/SortUtils.java",
                "line": 53,
                "column": 56
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java",
                "line": 191,
                "column": 47
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java",
                "line": 193,
                "column": 76
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/HarvesterUtil.java",
                "line": 51,
                "column": 48
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/HarvesterUtil.java",
                "line": 55,
                "column": 58
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/HarvesterUtil.java",
                "line": 57,
                "column": 48
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java",
                "line": 238,
                "column": 91
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java",
                "line": 114,
                "column": 60
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/thredds/Harvester.java",
                "line": 1159,
                "column": 47
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/services/harvesting/notifier/GetNotificationSettings.java",
                "line": 71,
                "column": 47
            },
            {
                "path": "src/geonetwork/inspire-atom/src/main/java/org/fao/geonet/inspireatom/harvester/InspireAtomHarvester.java",
                "line": 445,
                "column": 47
            },
            {
                "path": "src/geonetwork/integration-test/src/main/java/env/Env.java",
                "line": 98,
                "column": 68
            },
            {
                "path": "src/geonetwork/listeners/src/main/java/org/fao/geonet/listener/security/CheckUsername.java",
                "line": 40,
                "column": 60
            },
            {
                "path": "src/geonetwork/listeners/src/main/java/org/fao/geonet/listener/security/CheckUsername.java",
                "line": 44,
                "column": 58
            },
            {
                "path": "src/geonetwork/listeners/src/main/java/org/fao/geonet/listener/security/CheckUsername.java",
                "line": 48,
                "column": 52
            },
            {
                "path": "src/geonetwork/listeners/src/main/java/org/fao/geonet/listener/security/CheckUsername.java",
                "line": 52,
                "column": 68
            },
            {
                "path": "src/geonetwork/oaipmh/src/main/java/org/fao/oaipmh/responses/GeonetworkResumptionToken.java",
                "line": 206,
                "column": 40
            },
            {
                "path": "src/geonetwork/schemas/schema-core/src/main/java/org/fao/geonet/kernel/schema/SavedQuery.java",
                "line": 48,
                "column": 61
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/AllRequestsInterceptor.java",
                "line": 64,
                "column": 33
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/ApiUtils.java",
                "line": 149,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/OpenApiConfig.java",
                "line": 67,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/cssstyle/CssStyleSettingsService.java",
                "line": 289,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/cssstyle/CssStyleSettingsService.java",
                "line": 295,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/cssstyle/CssStyleSettingsService.java",
                "line": 301,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/es/EsHTTPProxy.java",
                "line": 536,
                "column": 40
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/es/EsHTTPProxy.java",
                "line": 708,
                "column": 41
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/mapservers/MapServersApi.java",
                "line": 538,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/mapservers/MapServersApi.java",
                "line": 540,
                "column": 51
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/mapservers/MapServersApi.java",
                "line": 544,
                "column": 51
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/mapservers/MapServersApi.java",
                "line": 546,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/mapservers/MapServersApi.java",
                "line": 550,
                "column": 51
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MetadataSearchAndReplace.java",
                "line": 99,
                "column": 51
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 654,
                "column": 151
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 656,
                "column": 54
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 658,
                "column": 120
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 659,
                "column": 112
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 660,
                "column": 56
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 709,
                "column": 43
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/InspireValidationApi.java",
                "line": 205,
                "column": 29
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataApi.java",
                "line": 160,
                "column": 64
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataSavedQueryApi.java",
                "line": 169,
                "column": 42
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java",
                "line": 868,
                "column": 38
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/editing/AjaxEditUtils.java",
                "line": 555,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/editing/EditUtils.java",
                "line": 313,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/editing/InspireValidatorUtils.java",
                "line": 694,
                "column": 43
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/editing/InspireValidatorUtils.java",
                "line": 713,
                "column": 51
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/extent/MapRenderer.java",
                "line": 247,
                "column": 49
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java",
                "line": 147,
                "column": 76
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatType.java",
                "line": 54,
                "column": 64
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java",
                "line": 718,
                "column": 75
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 175,
                "column": 44
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 182,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 207,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 210,
                "column": 48
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ImageReplacedElementFactory.java",
                "line": 219,
                "column": 63
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Handlers.java",
                "line": 175,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Handlers.java",
                "line": 179,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Handlers.java",
                "line": 232,
                "column": 81
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Handlers.java",
                "line": 414,
                "column": 71
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/FilterCapitalize.java",
                "line": 38,
                "column": 42
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TNodeFactoryRepeat.java",
                "line": 59,
                "column": 44
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TNodeFactoryTransclude.java",
                "line": 70,
                "column": 52
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TNodeFactoryTransclude.java",
                "line": 71,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TNodeTranslate.java",
                "line": 45,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TextContentParser.java",
                "line": 62,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/util/AssociatedLink.java",
                "line": 57,
                "column": 42
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/util/Summary.java",
                "line": 140,
                "column": 28
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/regions/metadata/MetadataRegionSearchRequest.java",
                "line": 104,
                "column": 39
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/regions/metadata/MetadataRegionSearchRequest.java",
                "line": 280,
                "column": 96
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/CrsApi.java",
                "line": 114,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/DirectoryEntriesApi.java",
                "line": 154,
                "column": 49
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/DirectoryUtils.java",
                "line": 264,
                "column": 74
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 416,
                "column": 49
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 441,
                "column": 33
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 1131,
                "column": 72
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 1149,
                "column": 44
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/reports/ReportDownloads.java",
                "line": 83,
                "column": 24
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/reports/ReportInternalMetadata.java",
                "line": 72,
                "column": 62
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/reports/ReportUpdatedMetadata.java",
                "line": 74,
                "column": 62
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/reports/ReportUploads.java",
                "line": 83,
                "column": 24
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/reports/ReportUsers.java",
                "line": 79,
                "column": 62
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/LoggingApi.java",
                "line": 98,
                "column": 47
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 124,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 127,
                "column": 57
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 133,
                "column": 57
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/tools/i18n/TranslationPackBuilder.java",
                "line": 140,
                "column": 61
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/users/UsersApi.java",
                "line": 239,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/users/validation/PasswordValidationUtils.java",
                "line": 61,
                "column": 44
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 156,
                "column": 43
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 159,
                "column": 38
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 165,
                "column": 43
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 185,
                "column": 71
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 187,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 197,
                "column": 71
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiservices/versioning/MyLogEntryHandler.java",
                "line": 199,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/metadata/PrepareFileDownload.java",
                "line": 154,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/thesaurus/Add.java",
                "line": 69,
                "column": 41
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/thesaurus/AddElement.java",
                "line": 66,
                "column": 56
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/thesaurus/GetKeywordById.java",
                "line": 56,
                "column": 84
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/thesaurus/GetKeywordById.java",
                "line": 84,
                "column": 42
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/DatabaseMigration.java",
                "line": 390,
                "column": 45
            },
            {
                "path": "src/geonetwork/web/src/main/java/org/fao/geonet/i18n/UrlLocaleChangeInterceptor.java",
                "line": 74,
                "column": 48
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 351,
                "column": 62
            },
            {
                "path": "src/geonetwork/web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 360,
                "column": 62
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 351,
                "column": 62
            },
            {
                "path": "src/geonetwork/web/target/geonetwork/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java",
                "line": 360,
                "column": 62
            },
            {
                "path": "src/geonetwork/workers/wfsfeature-harvester/src/main/java/org/fao/geonet/harvester/wfsfeatures/worker/EsWFSFeatureIndexer.java",
                "line": 286,
                "column": 59
            },
            {
                "path": "src/geonetwork/workers/wfsfeature-harvester/src/main/java/org/fao/geonet/harvester/wfsfeatures/worker/EsWFSFeatureIndexer.java",
                "line": 290,
                "column": 63
            },
            {
                "path": "src/geonetwork/workers/wfsfeature-harvester/src/main/java/org/fao/geonet/harvester/wfsfeatures/worker/EsWFSFeatureIndexer.java",
                "line": 342,
                "column": 60
            },
            {
                "path": "src/geonetwork/workers/wfsfeature-harvester/src/main/java/org/fao/geonet/harvester/wfsfeatures/worker/WFSFeatureUtils.java",
                "line": 64,
                "column": 25
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/ClosureDependencyUriLocator.java",
                "line": 34,
                "column": 51
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/ClosureDependencyUriLocator.java",
                "line": 51,
                "column": 38
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 304,
                "column": 30
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 596,
                "column": 73
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 680,
                "column": 61
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/TemplatesUriLocator.java",
                "line": 93,
                "column": 46
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/TemplatesUriLocator.java",
                "line": 95,
                "column": 46
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/TemplatesUriLocator.java",
                "line": 99,
                "column": 46
            }
        ],
        "Script Engine Injection": [
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TNodeIf.java",
                "line": 158,
                "column": 43
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/ServerBeanPropertyUpdater.java",
                "line": 107,
                "column": 20
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/ServerBeanPropertyUpdater.java",
                "line": 107,
                "column": 38
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/ServerBeanPropertyUpdater.java",
                "line": 139,
                "column": 13
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/config/springutil/ServerBeanPropertyUpdater.java",
                "line": 139,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 125,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 125,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 127,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 127,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 129,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 129,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 131,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 131,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 133,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 133,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 135,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 135,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 137,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 137,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 139,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 139,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 146,
                "column": 56
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/DbDescTranslator.java",
                "line": 146,
                "column": 70
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java",
                "line": 103,
                "column": 60
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java",
                "line": 103,
                "column": 74
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java",
                "line": 128,
                "column": 32
            },
            {
                "path": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java",
                "line": 128,
                "column": 46
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Selectable.java",
                "line": 89,
                "column": 17
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/Selectable.java",
                "line": 89,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TRenderContext.java",
                "line": 209,
                "column": 21
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TRenderContext.java",
                "line": 209,
                "column": 35
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 403,
                "column": 39
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 403,
                "column": 53
            }
        ],
        "File read/write hook path": [
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/BinaryFile.java",
                "line": 272,
                "column": 50
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/FileSystemSpecificStreamHandler.java",
                "line": 94,
                "column": 50
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 333,
                "column": 83
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 335,
                "column": 41
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 342,
                "column": 81
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 344,
                "column": 44
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/Xml.java",
                "line": 559,
                "column": 55
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlResolver.java",
                "line": 193,
                "column": 113
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/debug/OpenResourceTracker.java",
                "line": 73,
                "column": 72
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/nio/NioPathAwareCatalogResolver.java",
                "line": 68,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/AbstractStore.java",
                "line": 174,
                "column": 77
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/StoreUtils.java",
                "line": 175,
                "column": 62
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchemaManager.java",
                "line": 1185,
                "column": 59
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/ThesaurusManager.java",
                "line": 211,
                "column": 79
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/ThesaurusManager.java",
                "line": 397,
                "column": 67
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 189,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 190,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 240,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 244,
                "column": 21
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 253,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Exporter.java",
                "line": 282,
                "column": 21
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFExporter.java",
                "line": 121,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFExporter.java",
                "line": 131,
                "column": 25
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/schema/MetadataSchema.java",
                "line": 421,
                "column": 77
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/EsSearchManager.java",
                "line": 283,
                "column": 64
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/thumbnail/ThumbnailMaker.java",
                "line": 89,
                "column": 55
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/thumbnail/ThumbnailMaker.java",
                "line": 163,
                "column": 55
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/lib/TextLib.java",
                "line": 64,
                "column": 58
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 309,
                "column": 84
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 477,
                "column": 63
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java",
                "line": 145,
                "column": 70
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 200,
                "column": 94
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/util/LangUtils.java",
                "line": 80,
                "column": 92
            },
            {
                "path": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/ogcwxs/Harvester.java",
                "line": 1014,
                "column": 62
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/ApiUtils.java",
                "line": 334,
                "column": 55
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/cssstyle/CssStyleSettingsService.java",
                "line": 174,
                "column": 21
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataUtils.java",
                "line": 461,
                "column": 58
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/attachments/AttachmentsApi.java",
                "line": 279,
                "column": 60
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java",
                "line": 96,
                "column": 74
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/EditFile.java",
                "line": 75,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java",
                "line": 721,
                "column": 102
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/PDF.java",
                "line": 62,
                "column": 54
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java",
                "line": 102,
                "column": 21
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java",
                "line": 200,
                "column": 74
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/UpdateFile.java",
                "line": 66,
                "column": 21
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 146,
                "column": 42
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 178,
                "column": 21
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 253,
                "column": 39
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/groovy/template/TemplateParser.java",
                "line": 67,
                "column": 57
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 919,
                "column": 53
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 1311,
                "column": 59
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 761,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 780,
                "column": 78
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 781,
                "column": 81
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/standards/StandardsApi.java",
                "line": 376,
                "column": 71
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/guiapi/search/XsltResponseWriter.java",
                "line": 148,
                "column": 61
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 211,
                "column": 67
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 255,
                "column": 63
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/handlers/DefaultResourceDownloadHandler.java",
                "line": 81,
                "column": 56
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetLessCompilerProcessor.java",
                "line": 220,
                "column": 66
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 172,
                "column": 34
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 194,
                "column": 30
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 365,
                "column": 30
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 392,
                "column": 34
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlRequest.java",
                "line": 146,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 573,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java",
                "line": 173,
                "column": 24
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java",
                "line": 249,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/S3Store.java",
                "line": 258,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/StoreUtils.java",
                "line": 177,
                "column": 41
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/backup/ArchiveAllMetadataJob.java",
                "line": 156,
                "column": 33
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 283,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 417,
                "column": 40
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java",
                "line": 290,
                "column": 61
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 183,
                "column": 44
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 289,
                "column": 54
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 192,
                "column": 41
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/LogosApi.java",
                "line": 167,
                "column": 48
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 787,
                "column": 58
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 788,
                "column": 58
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 268,
                "column": 36
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 294,
                "column": 49
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/BinaryFile.java",
                "line": 457,
                "column": 45
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/JeevesEngine.java",
                "line": 211,
                "column": 38
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/apps/MakeISO.java",
                "line": 51,
                "column": 50
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/apps/MakeISO.java",
                "line": 52,
                "column": 52
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java",
                "line": 302,
                "column": 59
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java",
                "line": 317,
                "column": 59
            },
            {
                "path": "src/geonetwork/healthmonitor/src/main/java/org/fao/geonet/monitor/service/LogConfig.java",
                "line": 128,
                "column": 42
            },
            {
                "path": "src/geonetwork/integration-test/src/main/java/env/Env.java",
                "line": 32,
                "column": 41
            },
            {
                "path": "src/geonetwork/integration-test/src/main/java/env/Env.java",
                "line": 100,
                "column": 25
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/languages/LanguagesApi.java",
                "line": 122,
                "column": 76
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/languages/LanguagesApi.java",
                "line": 184,
                "column": 76
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/CatalogApi.java",
                "line": 668,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/rdf/RdfOutputManager.java",
                "line": 117,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/rdf/RdfOutputManager.java",
                "line": 121,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/rdf/RdfOutputManager.java",
                "line": 179,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/rdf/RdfOutputManager.java",
                "line": 187,
                "column": 88
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/rdf/RdfOutputManager.java",
                "line": 192,
                "column": 88
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 571,
                "column": 95
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 882,
                "column": 65
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 1243,
                "column": 61
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/LoggingApi.java",
                "line": 187,
                "column": 42
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 121,
                "column": 58
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 253,
                "column": 81
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 257,
                "column": 81
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 264,
                "column": 89
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 272,
                "column": 89
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/GeonetWroModelFactory.java",
                "line": 318,
                "column": 68
            },
            {
                "path": "src/geonetwork/wro4j/src/main/java/org/fao/geonet/wro4j/TemplatesUriLocator.java",
                "line": 82,
                "column": 73
            },
            {
                "path": "src/geonetwork/csw-server/src/main/java/org/fao/geonet/component/csw/GetRecords.java",
                "line": 546,
                "column": 48
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/sources/ServiceRequestFactory.java",
                "line": 296,
                "column": 13
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/sources/ServiceRequestFactory.java",
                "line": 296,
                "column": 38
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/DirectoryApi.java",
                "line": 808,
                "column": 9
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/DirectoryApi.java",
                "line": 808,
                "column": 25
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 695,
                "column": 13
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 695,
                "column": 29
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 842,
                "column": 9
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/registries/vocabularies/KeywordsApi.java",
                "line": 842,
                "column": 25
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 172,
                "column": 28
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 365,
                "column": 24
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java",
                "line": 392,
                "column": 28
            },
            {
                "path": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/XmlRequest.java",
                "line": 146,
                "column": 24
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java",
                "line": 573,
                "column": 28
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java",
                "line": 173,
                "column": 20
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/S3Store.java",
                "line": 258,
                "column": 28
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/StoreUtils.java",
                "line": 177,
                "column": 28
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 283,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java",
                "line": 417,
                "column": 36
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java",
                "line": 71,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java",
                "line": 71,
                "column": 38
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java",
                "line": 290,
                "column": 46
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 183,
                "column": 32
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java",
                "line": 289,
                "column": 50
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataInsertDeleteApi.java",
                "line": 538,
                "column": 57
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/MetadataInsertDeleteApi.java",
                "line": 538,
                "column": 77
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/Resource.java",
                "line": 88,
                "column": 20
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/Resource.java",
                "line": 88,
                "column": 33
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/cache/FilesystemStore.java",
                "line": 192,
                "column": 28
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/LogosApi.java",
                "line": 167,
                "column": 28
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 787,
                "column": 40
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/api/site/SiteApi.java",
                "line": 788,
                "column": 40
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 268,
                "column": 28
            },
            {
                "path": "src/geonetwork/services/src/main/java/org/fao/geonet/services/resources/DownloadArchive.java",
                "line": 294,
                "column": 36
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/JeevesEngine.java",
                "line": 207,
                "column": 66
            },
            {
                "path": "src/geonetwork/core/src/main/java/jeeves/server/sources/http/ServletPathFinder.java",
                "line": 58,
                "column": 62
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/JSONLocCacheLoader.java",
                "line": 80,
                "column": 55
            },
            {
                "path": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/search/JSONLocCacheLoader.java",
                "line": 82,
                "column": 55
            }
        ]
    },
    "tasks": [
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n233       private void runBeforeScript() throws IOException, InterruptedException {\n234   \t\tif (StringUtils.isEmpty(params.beforeScript)) {\n235   \t\t\treturn;\n236   \t\t}\n237   \t\tlog.info(\"Running the before script: \" + params.beforeScript);\n238           List<String> args = new ArrayList<String>(Arrays.asList(params.beforeScript.split(\" \")));\n239           Process process = new ProcessBuilder(args).\n240   \t\t\t\tredirectError(ProcessBuilder.Redirect.INHERIT).\n241   \t\t\t\tredirectOutput(ProcessBuilder.Redirect.INHERIT).\n242   \t\t\t\tstart();\n243   \t\tint result = process.waitFor();\n244   \t\tif ( result != 0 ) {\n245   \t\t\tlog.warning(\"The beforeScript failed with exit value=\" + Integer.toString(result));\n246   \t\t\tthrow new RuntimeException(\"The beforeScript returned an error: \" + Integer.toString(result));\n247   \t\t}\n248   \t}\n",
            "cost": 0.04134,
            "harness_id": "GeonetworkOne",
            "sanitizer": "OS Command Injection",
            "sink": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:239:27",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 1
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 0.157885,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Server Side Request Forgery (SSRF)",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:202:39",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 2
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3QgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPG1ldGFkYXRhIHhsaW5rOmhyZWY9Imh0dHA6Ly9qYXp6ZXIuZXhhbXBsZS5jb20vdnVsbmVyYWJsZSIgeGxpbms6c2hvdz0icmVwbGFjZSI+CiAgICAgICAgPHV1aWQ+ZXhwbG9pdC11dWlkPC91dWlkPgogICAgICAgIDxzY2hlbWE+ZXhhbXBsZS1zY2hlbWE8L3NjaGVtYT4KICAgICAgICA8Y3JlYXRlRGF0ZT4yMDIzLTAxLTAxVDAwOjAwOjAwPC9jcmVhdGVEYXRlPgogICAgPC9tZXRhZGF0YT4KPC9yb290Pg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 1.10255,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Server Side Request Forgery (SSRF)",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:207:70",
            "status": "corpus",
            "valid_path": "YES",
            "id": 3
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/editing/InspireValidatorUtils.java:\n618       public String retrieveReport(ServiceContext context, String endPoint) throws Exception {\n619   \n620           HttpGet request = new HttpGet(endPoint);\n621   \n622           // add request header\n623           request.addHeader(\"User-Agent\", USER_AGENT);\n624           request.addHeader(\"Accept\", ACCEPT);\n625   \n626           try (ClientHttpResponse response = this.execute(context, request)) {\n627               return IOUtils.toString(response.getBody(), StandardCharsets.UTF_8.name());\n628           } catch (Exception e) {\n629               Log.warning(Log.SERVICE, \"Error calling INSPIRE service to retrieve the result report: \" + endPoint, e);\n630               throw e;\n631           }\n632       }\n736       private ClientHttpResponse execute(ServiceContext context, HttpUriRequest request) throws IOException {\n737   \n738           final Function<HttpClientBuilder, Void> proxyConfiguration = new Function<HttpClientBuilder, Void>() {\n739               @Nullable @Override public Void apply(@Nonnull HttpClientBuilder input) {\n740                   Lib.net.setupProxy(context, input, request.getURI().getHost());\n741                   return null;\n742               }\n743           };\n744           return requestFactory.execute(request, proxyConfiguration);\n745       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java:\n165       public ClientHttpResponse execute(HttpUriRequest request,\n166                                         Function<HttpClientBuilder, Void> configurator) throws IOException {\n167           final HttpClientBuilder clientBuilder = getDefaultHttpClientBuilder();\n168           configurator.apply(clientBuilder);\n169           CloseableHttpClient httpClient = clientBuilder.build();\n170   \n171           return new AdaptingResponse(httpClient, httpClient.execute(request));\n172       }\n",
            "cost": 0.12291,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Server Side Request Forgery (SSRF)",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/GeonetHttpRequestFactory.java:171:68",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 4
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n 93       public LocalFsHarvesterFileVisitor(AtomicBoolean cancelMonitor, ServiceContext context, LocalFilesystemParams params, LocalFilesystemHarvester harvester) throws Exception {\n 94           this.aligner = new LocalFileSytemAligner(cancelMonitor, params);\n 95           this.cancelMonitor = cancelMonitor;\n 96           this.context = context;\n 97           this.thisXslt = context.getAppPath().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n 98           if (!params.getImportXslt().equals(\"none\")) {\n 99               String xslPath = params.getImportXslt();\n100               if(!xslPath.endsWith(\".xsl\")) {\n101                   xslPath += \".xsl\";\n102               }\n103               thisXslt = thisXslt.resolve(xslPath);\n104               transformIt = true;\n105           }\n106           localCateg = new CategoryMapper(context);\n107           localGroups = new GroupMapper(context);\n108           this.params = params;\n109           this.dataMan = context.getBean(DataManager.class);\n110           this.harvester = harvester;\n111           this.repo = context.getBean(IMetadataUtils.class);\n112           this.startTime = System.currentTimeMillis();\n113   \n114           String harvesterName = params.getName().replaceAll(\"\\\\W+\", \"_\");\n115           LOGGER =  LoggerFactory.getLogger(harvesterName);\n116           LOGGER.debug(\"Start visiting files at {}.\", this.startTime);\n117       }\n",
            "cost": 0.0536,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:114:60",
            "status": "corpus",
            "valid_path": "NO",
            "id": 5
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/geonet/Aligner.java:\n720                           public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n721                               handleFile(id, file, MetadataResourceVisibility.PUBLIC, changeDate, is, publicFiles[index]);\n722                           }\n846       private void handleFile(String id, String file, MetadataResourceVisibility visibility, String changeDate,\n847                               InputStream is, Element files) throws Exception {\n848           if (files == null) {\n849               if (log.isDebugEnabled())\n850                   log.debug(\"  - No file found in info.xml. Cannot update file:\" + file);\n851           } else {\n852               final Store store = context.getBean(\"resourceStore\", Store.class);\n853               final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n854               final String metadataUuid = metadataUtils.getMetadataUuid(id);\n855               removeOldFile(store, metadataUuid, files, visibility);\n856               saveFile(store, metadataUuid, file, visibility, changeDate, is);\n857           }\n858       }\n860       private void removeOldFile(Store store, String metadataUuid, Element infoFiles, MetadataResourceVisibility visibility) throws Exception {\n861           final List<MetadataResource> resources = store.getResources(context, metadataUuid, visibility, null, true);\n862           for (MetadataResource resource: resources) {\n863               if (infoFiles != null && !existsFile(resource.getId(), infoFiles)) {\n864                   if (log.isDebugEnabled()) {\n865                       log.debug(\"  - Removing old \" + metadataUuid + \" file with name=\" + resource.getFilename());\n866                   }\n867                   store.delResource(context, metadataUuid, visibility, resource.getFilename(), true);\n868               }\n869           }\n870       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/S3Store.java:\n 58       @Override\n 59       public List<MetadataResource> getResources(final ServiceContext context, final String metadataUuid,\n 60               final MetadataResourceVisibility visibility, String filter, Boolean approved) throws Exception {\n 61           final int metadataId = canEdit(context, metadataUuid, approved);\n 62           final SettingManager settingManager = context.getBean(SettingManager.class);\n 63   \n 64           final String resourceTypeDir = getMetadataDir(metadataId) + \"/\" + visibility.toString();\n 65   \n 66           List<MetadataResource> resourceList = new ArrayList<>();\n 67           if (filter == null) {\n 68               filter = FilesystemStore.DEFAULT_FILTER;\n 69           }\n 70           PathMatcher matcher =\n 71                   FileSystems.getDefault().getPathMatcher(\"glob:\" + filter);\n 72   \n 73           final ListObjectsV2Result objects = s3.getClient().listObjectsV2(s3.getBucket(), resourceTypeDir);\n 74           for (S3ObjectSummary object: objects.getObjectSummaries()) {\n 75               final String key = object.getKey();\n 76               final String filename = getFilename(key);\n 77               Path keyPath = new File(filename).toPath().getFileName();\n 78               if (matcher.matches(keyPath)) {\n 79                   MetadataResource resource = createResourceDescription(settingManager, metadataUuid, visibility, filename, object.getSize(),\n 80                                                                         object.getLastModified(), metadataId, approved);\n 81                   resourceList.add(resource);\n 82               }\n 83           }\n 84   \n 85           resourceList.sort(MetadataResourceVisibility.sortByFileName);\n 86   \n 87           return resourceList;\n 88       }\n 96       private static String getFilename(final String key) {\n 97           final String[] splittedKey = key.split(\"/\");\n 98           return splittedKey[splittedKey.length - 1];\n 99       }\n",
            "cost": 0.16443000000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/S3Store.java:97:48",
            "status": "corpus",
            "valid_path": "NO",
            "id": 6
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3QgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3F1ZXJ5PS4qIj4KICAgICAgICA8c3ViZWxlbWVudD5UZXN0IFJlZ2V4IEluamVjdGlvbiBwb3NzaWJpbGl0eSB3aXRoIHRoaXMgc3ltYm9sOiAqPC9zdWJlbGVtZW50PgogICAgPC9lbGVtZW50Pgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 1.0113500000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:422:62",
            "status": "corpus",
            "valid_path": "YES",
            "id": 7
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n402           @Override\n403           public Path getPath() {\n404               if (path != null) {\n405                   return path;\n406               }\n407               final String[] splittedKey = key.split(CMISConfiguration.getFolderDelimiter());\n408               try {\n409                   // Preserve filename by putting the files into a temporary folder and using the same filename.\n410                   tempFolderPath = Files.createTempDirectory(\"gn-res-\" + splittedKey[splittedKey.length - 2] + \"-\");\n411                   tempFolderPath.toFile().deleteOnExit();\n412                   path = tempFolderPath.resolve(splittedKey[splittedKey.length - 1]);\n413   \n414                   try {\n415                       final CmisObject object = CMISConfiguration.getClient().getObjectByPath(key);\n416                       try (InputStream in = ((Document) object).getContentStream().getStream()) {\n417                           Files.copy(in, path,\n418                               StandardCopyOption.REPLACE_EXISTING);\n419                       }\n420                   } catch (CmisObjectNotFoundException e) {\n421                       // As there is no cmis file, we will also remove the path if it exists so that the current file does not get saved on close.\n422                       if (writeOnClose && Files.exists(path)) {\n423                           Files.delete(path);\n424                       }\n425                   }\n426               } catch (IOException e) {\n427                   Log.error(Geonet.RESOURCES, String.format(\n428                       \"Error getting path for resource '%s'.\", key), e);\n429                   throw new RuntimeException(e);\n430               }\n431   \n432               return path;\n433           }\n",
            "cost": 0.051155000000000006,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:407:52",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 8
        },
        {
            "blob": [
                "PG1ldGFkYXRhIHhtbG5zPSJodHRwOi8vZXhhbXBsZS5jb20vc2NoZW1hIj48dGVzdEVsZW1lbnQgeG1sbnM9Imh0dHA6Ly9leGFtcGxlLmNvbS9zY2hlbWEiPjxwYXR0ZXJuRWxlbWVudD4uKi4qLiouKi4qPC9wYXR0ZXJuRWxlbWVudD48L3Rlc3RFbGVtZW50PjwvbWV0YWRhdGE+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/DataManager.java:\n323       @Deprecated\n324       public @CheckForNull\n325       String autodetectSchema(Element md, String defaultSchema)\n326           throws SchemaMatchConflictException, NoSchemaMatchesException {\n327           return metadataSchemaUtils.autodetectSchema(md, defaultSchema);\n328       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataSchemaUtils.java:\n122       @Override\n123       public @CheckForNull\n124       String autodetectSchema(Element md, String defaultSchema)\n125           throws SchemaMatchConflictException, NoSchemaMatchesException {\n126   \n127           if (Log.isDebugEnabled(Geonet.DATA_MANAGER))\n128               Log.debug(Geonet.DATA_MANAGER,\n129                   \"Autodetect schema for metadata with :\\n * root element:'\" + md.getQualifiedName() + \"'\\n * with namespace:'\"\n130                       + md.getNamespace() + \"\\n * with additional namespaces:\" + md.getAdditionalNamespaces().toString());\n131           String schema = schemaManager.autodetectSchema(md, defaultSchema);\n132           if (Log.isDebugEnabled(Geonet.DATA_MANAGER))\n133               Log.debug(Geonet.DATA_MANAGER, \"Schema detected was \" + schema);\n134           return schema;\n135       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchemaManager.java:\n 705       public String autodetectSchema(Element md, String defaultSchema) throws SchemaMatchConflictException, NoSchemaMatchesException {\n 706   \n 707           beforeRead();\n 708           try {\n 709               String schema;\n 710   \n 711               // -- check the autodetect elements for all schemas with the most\n 712               // -- specific test first, then in order of increasing generality,\n 713               // -- first match wins\n 714               schema = compareElementsAndAttributes(md, MODE_ATTRIBUTEWITHVALUE);\n 715               if (schema != null) {\n 716                   if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n 717                       Log.debug(Geonet.SCHEMA_MANAGER, \"  => Found schema \" + schema + \" using AUTODETECT(attributes) examination\");\n 718               }\n 719   \n 720               if (schema == null) {\n 721                   schema = compareElementsAndAttributes(md, MODE_NEEDLEWITHVALUE);\n 722                   if (schema != null) {\n 723                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n 724                           Log.debug(Geonet.SCHEMA_MANAGER, \"  => Found schema \" + schema + \" using AUTODETECT(elements with value) examination\");\n 725                   }\n 726               }\n 727   \n 728               if (schema == null) {\n 729                   schema = compareElementsAndAttributes(md, MODE_NEEDLE);\n 730                   if (schema != null) {\n 731                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n 732                           Log.debug(Geonet.SCHEMA_MANAGER, \"  => Found schema \" + schema + \" using AUTODETECT(elements) examination\");\n 733                   }\n 734               }\n 735   \n 736               if (schema == null) {\n 737                   schema = compareElementsAndAttributes(md, MODE_ROOT);\n 738                   if (schema != null) {\n 739                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n 740                           Log.debug(Geonet.SCHEMA_MANAGER, \"  => Found schema \" + schema + \" using AUTODETECT(elements with root) examination\");\n 741                   }\n 742               }\n 743   \n 744               if (schema == null) {\n 745                   schema = compareElementsAndAttributes(md, MODE_NAMESPACE);\n 746                   if (schema != null) {\n 747                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n 748                           Log.debug(Geonet.SCHEMA_MANAGER, \"  => Found schema \" + schema + \" using AUTODETECT(namespaces) examination\");\n 749                   }\n 750               }\n 751   \n 752               // -- If nothing has matched by this point choose defaultSchema supplied\n 753               // -- as argument to this method as long as its reasonable\n 754               if (schema == null && defaultSchema != null) {\n 755                   String defaultSchemaOrDependencySchema = checkNamespace(md, defaultSchema);\n 756                   if (defaultSchemaOrDependencySchema != null) {\n 757                       Log.warning(Geonet.SCHEMA_MANAGER, \"  Autodetecting schema failed for \" + md.getName() + \" in namespace \" + md.getNamespace()\n 758                           + \". Using default schema or one of its dependency: \" + defaultSchemaOrDependencySchema);\n 759                       schema = defaultSchemaOrDependencySchema;\n 760                   }\n 761               }\n 762   \n 763               // -- if the default schema failed then throw an exception\n 764               if (schema == null) {\n 765                   throw new NoSchemaMatchesException(\"Autodetecting schema failed for metadata record with root element \" + md.getName() + \" in namespace \" + md.getNamespace() + \".\");\n 766               }\n 767   \n 768               return schema;\n 769           } finally {\n 770               afterRead();\n 771           }\n 772       }\n1607       private String compareElementsAndAttributes(Element md, int mode) throws SchemaMatchConflictException {\n1608           String returnVal = null;\n1609           Set<String> allSchemas = getSchemas();\n1610           List<String> matches = new ArrayList<>();\n1611   \n1612           if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1613               Log.debug(Geonet.SCHEMA_MANAGER, \"Schema autodetection starting on \" + md.getName() + \" (Namespace: \" + md.getNamespace() + \") using mode: \" + mode + \"...\");\n1614   \n1615           for (String schemaName : allSchemas) {\n1616               if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1617                   Log.debug(Geonet.SCHEMA_MANAGER, \"\tDoing schema \" + schemaName);\n1618               Schema schema = hmSchemas.get(schemaName);\n1619               List<Element> adElems = schema.getAutodetectElements();\n1620   \n1621               for (Element elem : adElems) {\n1622                   if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1623                       Log.debug(Geonet.SCHEMA_MANAGER, \"\t\tChecking autodetect element \" + Xml.getString(elem) + \" with name \" + elem.getName());\n1624   \n1625                   @SuppressWarnings(\"unchecked\")\n1626                   List<Element> elemKids = elem.getChildren();\n1627                   boolean match = false;\n1628   \n1629                   Attribute type = elem.getAttribute(\"type\");\n1630   \n1631                   // --- try and find the attribute and value in md\n1632                   if (mode == MODE_ATTRIBUTEWITHVALUE && elem.getName() == \"attributes\") {\n1633                       @SuppressWarnings(\"unchecked\")\n1634                       List<Attribute> atts = elem.getAttributes();\n1635                       for (Attribute searchAtt : atts) {\n1636                           if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1637                               Log.debug(Geonet.SCHEMA_MANAGER, \"\t\t\t\tFinding attribute \" + searchAtt.toString());\n1638   \n1639                           if (isMatchingAttributeInMetadata(searchAtt, md)) {\n1640                               match = true;\n1641                           } else {\n1642                               match = false;\n1643                               break;\n1644                           }\n1645                       }\n1646   \n1647                       // --- try and find the namespace in md\n1648                   } else if (mode == MODE_NAMESPACE && elem.getName().equals(\"namespaces\")) {\n1649                       @SuppressWarnings(\"unchecked\")\n1650                       List<Namespace> nss = elem.getAdditionalNamespaces();\n1651                       for (Namespace ns : nss) {\n1652                           if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1653                               Log.debug(Geonet.SCHEMA_MANAGER, \"\t\t\t\tFinding namespace \" + ns.toString());\n1654   \n1655                           if (isMatchingNamespaceInMetadata(ns, md)) {\n1656                               match = true;\n1657                           } else {\n1658                               match = false;\n1659                               break;\n1660                           }\n1661                       }\n1662                   } else {\n1663                       for (Element kid : elemKids) {\n1664   \n1665                           // --- is the kid the same as the root of the md\n1666                           if (mode == MODE_ROOT && type != null && \"root\".equals(type.getValue())) {\n1667                               if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1668                                   Log.debug(Geonet.SCHEMA_MANAGER, \"\t\t\t\tComparing \" + Xml.getString(kid) + \" with \" + md.getName() + \" with namespace \" + md.getNamespace() + \" : \" + (kid.getName().equals(md.getName()) && kid.getNamespace().equals(md.getNamespace())));\n1669                               if (kid.getName().equals(md.getName()) &&\n1670                                   kid.getNamespace().equals(md.getNamespace())) {\n1671                                   match = true;\n1672                                   break;\n1673                               } else {\n1674                                   match = false;\n1675                               }\n1676                               // --- try and find the kid in the md (kid only, not value)\n1677                           } else if (mode == MODE_NEEDLE && type != null && \"search\".equals(type.getValue())) {\n1678                               if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1679                                   Log.debug(Geonet.SCHEMA_MANAGER, \"\t\t\t\tComparing \" + Xml.getString(kid) + \" with \" + md.getName() + \" with namespace \" + md.getNamespace() + \" : \" + (kid.getName().equals(md.getName()) && kid.getNamespace().equals(md.getNamespace())));\n1680   \n1681                               if (isMatchingElementInMetadata(kid, md, false)) {\n1682                                   match = true;\n1683                               } else {\n1684                                   match = false;\n1685                                   break;\n1686                               }\n1687                               // --- try and find the kid in the md (kid + value)\n1688                           } else if (mode == MODE_NEEDLEWITHVALUE) {\n1689                               if (isMatchingElementInMetadata(kid, md, true)) {\n1690                                   match = true;\n1691                               } else {\n1692                                   match = false;\n1693                                   break;\n1694                               }\n1695                           }\n1696                       }\n1697                   }\n1698                   if (match && (!matches.contains(schemaName))) matches.add(schemaName);\n1699               }\n1700           }\n1701   \n1702           if (matches.size() > 1) {\n1703               throw new SchemaMatchConflictException(\"Metadata record with \" + md.getName() + \" (Namespace \" + md.getNamespace() + \" matches more than one schema - namely: \" + matches.toString() + \" - during schema autodetection mode \" + mode);\n1704           } else if (matches.size() == 1) {\n1705               returnVal = matches.get(0);\n1706           }\n1707   \n1708           return returnVal;\n1709       }\n1785       private boolean isMatchingElementInMetadata(Element needle, Element haystack, boolean checkValue) {\n1786           boolean returnVal = false;\n1787           @SuppressWarnings(\"unchecked\")\n1788           Iterator<Element> haystackIterator = haystack.getDescendants(new ElementFilter());\n1789   \n1790           String needleName = needle.getName();\n1791           Namespace needleNS = needle.getNamespace();\n1792           if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1793               Log.debug(Geonet.SCHEMA_MANAGER, \"Matching \" + Xml.getString(needle));\n1794   \n1795           while (haystackIterator.hasNext()) {\n1796               Element tempElement = haystackIterator.next();\n1797   \n1798               if (tempElement.getName().equals(needleName) && tempElement.getNamespace().equals(needleNS)) {\n1799                   if (checkValue) {\n1800                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER))\n1801                           Log.debug(Geonet.SCHEMA_MANAGER, \"  Searching value for element: \" + tempElement.getName());\n1802   \n1803                       String needleVal = StringUtils.deleteWhitespace(needle.getValue());\n1804                       String tempVal = StringUtils.deleteWhitespace(tempElement.getValue());\n1805                       returnVal = Pattern.matches(needleVal, tempVal);\n1806                       if (Log.isDebugEnabled(Geonet.SCHEMA_MANAGER)) {\n1807                           Log.debug(Geonet.SCHEMA_MANAGER, \"    Pattern \" + needleVal + \" applied to value \" + tempVal + \" match: \" + returnVal);\n1808                       }\n1809                       if (returnVal) {\n1810                           break;\n1811                       }\n1812                   } else {\n1813                       returnVal = true;\n1814                       break;\n1815                   }\n1816               }\n1817           }\n1818           return returnVal;\n1819       }\n",
            "cost": 0.81741,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchemaManager.java:1805:49",
            "status": "corpus",
            "valid_path": "YES",
            "id": 9
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:\n 62       public Object invoke(String uri) throws Exception {\n 63           MockHttpServletRequest request = prepareMockRequestFromUri(uri);\n 64           MockHttpServletResponse response = new MockHttpServletResponse();\n 65           return invoke(request, response);\n 66       }\n110       private MockHttpServletRequest prepareMockRequestFromUri(String uri) {\n111           String requestURI = uri.replace(\"local:/\",\"\").split(\"\\\\?\")[0];\n112           MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", requestURI);\n113           request.setSession(new MockHttpSession());\n114           String[] splits = uri.split(\"\\\\?\");\n115           if (splits.length > 1) {\n116               String params = splits[1];\n117               for (String param : params.split(\"&\")) {\n118                   String[] parts = param.split(\"=\");\n119                   String name = parts[0];\n120                   request.addParameter(name, parts.length == 2 ? parts[1] : \"\");\n121               }\n122           }\n123           return request;\n124       }\n",
            "cost": 0.165315,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:111:61",
            "status": "corpus",
            "valid_path": "NO",
            "id": 10
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:\n 62       public Object invoke(String uri) throws Exception {\n 63           MockHttpServletRequest request = prepareMockRequestFromUri(uri);\n 64           MockHttpServletResponse response = new MockHttpServletResponse();\n 65           return invoke(request, response);\n 66       }\n110       private MockHttpServletRequest prepareMockRequestFromUri(String uri) {\n111           String requestURI = uri.replace(\"local:/\",\"\").split(\"\\\\?\")[0];\n112           MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", requestURI);\n113           request.setSession(new MockHttpSession());\n114           String[] splits = uri.split(\"\\\\?\");\n115           if (splits.length > 1) {\n116               String params = splits[1];\n117               for (String param : params.split(\"&\")) {\n118                   String[] parts = param.split(\"=\");\n119                   String name = parts[0];\n120                   request.addParameter(name, parts.length == 2 ? parts[1] : \"\");\n121               }\n122           }\n123           return request;\n124       }\n",
            "cost": 0.167065,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:114:37",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 11
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:\n 62       public Object invoke(String uri) throws Exception {\n 63           MockHttpServletRequest request = prepareMockRequestFromUri(uri);\n 64           MockHttpServletResponse response = new MockHttpServletResponse();\n 65           return invoke(request, response);\n 66       }\n110       private MockHttpServletRequest prepareMockRequestFromUri(String uri) {\n111           String requestURI = uri.replace(\"local:/\",\"\").split(\"\\\\?\")[0];\n112           MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", requestURI);\n113           request.setSession(new MockHttpSession());\n114           String[] splits = uri.split(\"\\\\?\");\n115           if (splits.length > 1) {\n116               String params = splits[1];\n117               for (String param : params.split(\"&\")) {\n118                   String[] parts = param.split(\"=\");\n119                   String name = parts[0];\n120                   request.addParameter(name, parts.length == 2 ? parts[1] : \"\");\n121               }\n122           }\n123           return request;\n124       }\n",
            "cost": 0.16561499999999998,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:117:46",
            "status": "corpus",
            "valid_path": "NO",
            "id": 12
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:\n 62       public Object invoke(String uri) throws Exception {\n 63           MockHttpServletRequest request = prepareMockRequestFromUri(uri);\n 64           MockHttpServletResponse response = new MockHttpServletResponse();\n 65           return invoke(request, response);\n 66       }\n110       private MockHttpServletRequest prepareMockRequestFromUri(String uri) {\n111           String requestURI = uri.replace(\"local:/\",\"\").split(\"\\\\?\")[0];\n112           MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", requestURI);\n113           request.setSession(new MockHttpSession());\n114           String[] splits = uri.split(\"\\\\?\");\n115           if (splits.length > 1) {\n116               String params = splits[1];\n117               for (String param : params.split(\"&\")) {\n118                   String[] parts = param.split(\"=\");\n119                   String name = parts[0];\n120                   request.addParameter(name, parts.length == 2 ? parts[1] : \"\");\n121               }\n122           }\n123           return request;\n124       }\n",
            "cost": 0.16586499999999998,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/SpringLocalServiceInvoker.java:118:46",
            "status": "corpus",
            "valid_path": "NO",
            "id": 13
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n278           @Override\n279           public Path getPath() {\n280               if (path != null) {\n281                   return path;\n282               }\n283               final String[] splittedKey = key.split(\"/\");\n284               try {\n285                   path = java.nio.file.Files.createTempFile(\"\", splittedKey[splittedKey.length - 1]);\n286                   try {\n287                       final S3Object object = s3.getClient().getObject(s3.getBucket(), key);\n288                       try (S3ObjectInputStream in = object.getObjectContent()) {\n289                           java.nio.file.Files.copy(in, path,\n290                                                    StandardCopyOption.REPLACE_EXISTING);\n291                       }\n292                   } catch (AmazonServiceException e) {\n293                       if (e.getStatusCode() == HttpStatus.SC_NOT_FOUND && writeOnClose) {\n294                           Files.delete(path);\n295                       } else if (e.getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n296                           throw e;\n297                       }\n298                   }\n299               } catch (IOException e) {\n300                   throw new RuntimeException(e);\n301               }\n302   \n303               return path;\n304           }\n",
            "cost": 0.05419,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:283:52",
            "status": "corpus",
            "valid_path": "NO",
            "id": 14
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/oaipmh/OaiPmhParams.java:\n 82       public void create(Element node) throws BadInputEx {\n 83           super.create(node);\n 84   \n 85           Element site = node.getChild(\"site\");\n 86           Element searches = node.getChild(\"searches\");\n 87   \n 88           url = Util.getParam(site, \"url\", \"\");\n 89           icon = Util.getParam(site, \"icon\", \"\");\n 90           xslfilter = Util.getParam(site, \"xslfilter\", \"\");\n 91   \n 92           addSearches(searches);\n 93       }\n150       private void addSearches(Element searches) throws BadInputEx {\n151           alSearches.clear();\n152   \n153           if (searches == null)\n154               return;\n155   \n156           for (Object o : searches.getChildren(\"search\")) {\n157               Element search = (Element) o;\n158   \n159               alSearches.add(new Search(search));\n160           }\n161       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/oaipmh/Search.java:\n 67       public Search(Element search) throws BadInputEx {\n 68           from = Util.getParam(search, \"from\", \"\");\n 69           until = Util.getParam(search, \"until\", \"\");\n 70           set = Util.getParam(search, \"set\", \"\");\n 71           prefix = Util.getParam(search, \"prefix\", \"oai_dc\");\n 72           stylesheet = Util.getParam(search, \"stylesheet\", \"\");\n 73   \n 74           //--- check from parameter\n 75   \n 76           ISODate fromDate = null;\n 77           ISODate untilDate = null;\n 78   \n 79   \t\ttry {\n 80   \t\t    if (StringUtils.isNotEmpty(from) && !from.equalsIgnoreCase(\"Invalid Date\")) {\n 81   \t\t\t\tfromDate = new ISODate(from);\n 82   \t\t\t\tfrom     = fromDate.getDateAsString();\n 83   \t\t\t} else {\n 84   \t\t\t    from = \"\";\n 85   \t\t\t}\n 86   \n 87           } catch (Exception e) {\n 88               throw new BadParameterEx(\"from\", from);\n 89           }\n 90   \n 91           //--- check until parameter\n 92   \n 93   \t\ttry {\n 94   \t\t    if (StringUtils.isNotEmpty(until) && !until.equalsIgnoreCase(\"Invalid Date\")) {\n 95   \t\t\t\tuntilDate = new ISODate(until);\n 96   \t\t\t\tuntil     = untilDate.getDateAsString();\n 97   \t\t\t} else {\n 98   \t\t\t    until = \"\";\n 99               }\n100   \t\t} catch(Exception e) {\n101   \t\t\tthrow new BadParameterEx(\"until\", until);\n102   \t\t}\n103   \n104           //--- check from <= until\n105   \n106           if (fromDate != null && untilDate != null)\n107               if (fromDate.timeDifferenceInSeconds(untilDate) > 0)\n108                   throw new BadParameterEx(\"from greater than until\", from + \">\" + until);\n109       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/ISODate.java:\n122       public ISODate(@Nonnull final String isoDateString) {\n123           setDateAndTime(isoDateString);\n124       }\n218       public void setDateAndTime(String isoDate) {\n219   \n220           String timeAndDate = isoDate;\n221           if (timeAndDate == null) {\n222               throw new IllegalArgumentException(\"Date string is null\");\n223           }\n224   \n225           if (timeAndDate.indexOf('T') >= 0 && StringUtils.contains(timeAndDate, ':')) {\n226               timeAndDate = DateUtil.convertToISOZuluDateTime(timeAndDate);\n227   \n228               if (timeAndDate == null) {\n229                   throw new IllegalArgumentException(\"Not parsable date: \" + isoDate);\n230               }\n231               internalDateTime = ZonedDateTime.parse(timeAndDate, DateUtil.ISO_OFFSET_DATE_TIME_NANOSECONDS);\n232               return;\n233           }\n234   \n235           if (StringUtils.contains(timeAndDate, ':')) {\n236               // its a time\n237               try {\n238                   internalDateTime = DateUtil.parseTime(StringUtils.remove(StringUtils.remove(timeAndDate, 't'), 'T'));\n239                   _shortDate = false;\n240               } catch (Exception e) {\n241                   throw new IllegalArgumentException(\"Invalid ISO time: \" + isoDate, e);\n242               }\n243           } else {\n244               // its a date\n245               parseDate(StringUtils.remove(StringUtils.remove(timeAndDate, 't'), 'T'));\n246   \n247           }\n248       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/DateUtil.java:\n101       public static String convertToISOZuluDateTime(final String stringToParse) {\n102           if (StringUtils.trimToNull(stringToParse) == null) {\n103               return stringToParse;\n104           }\n105           try {\n106               String parsedDateTime = parseISODateTimes(StringUtils.trim(stringToParse), null);\n107               if (parsedDateTime.equals(DEFAULT_DATE_TIME)) {\n108                   return null;\n109               } else {\n110                   return parsedDateTime;\n111               }\n112           } catch (DateTimeParseException e) {\n113               return null;\n114           }\n115       }\n137       public static String parseISODateTimes(String dateTimeString, String durationOrDateTimeString) {\n138   \n139           ZonedDateTime odt1;\n140           String odt;\n141   \n142           // dateTimeString should be some sort of ISO time\n143           // eg. basic: 20080909, full: 2008-09-09T12:21:00 etc\n144           // convert everything to UTC so that we remove any timezone\n145           // problems\n146           try {\n147               ZonedDateTime idt = parseBasicOrFullDateTime(dateTimeString);\n148   \n149               odt1 = idt.withZoneSameInstant(ZoneOffset.UTC);\n150               odt = idt.withZoneSameInstant(ZoneOffset.UTC).format(ISO_OFFSET_DATE_TIME_NANOSECONDS);\n151           } catch (Exception e) {\n152               Log.error(\"geonetwork.domain\",\n153                   String.format(\"Error parsing ISO DateTimes '%s'. Error is: %s\",\n154                       dateTimeString, e.getMessage()), e);\n155               return DEFAULT_DATE_TIME;\n156           }\n157   \n158           if (StringUtils.isBlank(durationOrDateTimeString))\n159               return odt;\n160   \n161           // durationOrDateTimeString can be an ISO time as for dateTimeString but also an ISO time period\n162           // eg. -P3D or P3D - if an ISO time period then it must be added to the\n163           // DateTime generated for dateTimeString (odt1)\n164           // convert everything to UTC so that we remove any timezone\n165           // problems\n166           try {\n167               boolean minus = false;\n168               if (durationOrDateTimeString.startsWith(\"-P\")) {\n169                   durationOrDateTimeString = durationOrDateTimeString.substring(1);\n170                   minus = true;\n171               }\n172   \n173               if (durationOrDateTimeString.startsWith(\"P\")) {\n174                   String[] periodAndDurationArray = durationOrDateTimeString.split(\"T\");\n175                   String periodString = periodAndDurationArray[0];\n176                   String durationString = \"PT\" + periodAndDurationArray[1];\n177   \n178                   Period ip = Period.parse(periodString);\n179                   Duration duration = Duration.parse(durationString);\n180                   ZonedDateTime odt2;\n181                   if (!minus) {\n182                       odt2 = odt1.plus(ip).plus(duration);\n183                   } else {\n184                       odt2 = odt1.minus(ip).minus(duration);\n185                   }\n186                   odt = odt + \"|\" + odt2.toString();\n187               } else {\n188                   ZonedDateTime idt = parseBasicOrFullDateTime(durationOrDateTimeString);\n189                   ZonedDateTime odt2 = idt.withZoneSameInstant(ZoneOffset.UTC);\n190                   odt = odt + \"|\" + odt2.toString();\n191               }\n192           } catch (Exception e) {\n193               Log.error(\"geonetwork.domain\", \"Error parsing ISO DateTimes, error: \" + e.getMessage(), e);\n194               return odt + \"|\" + DEFAULT_DATE_TIME;\n195           }\n196   \n197           return odt;\n198       }\n",
            "cost": 0.0775,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/DateUtil.java:174:82",
            "status": "corpus",
            "valid_path": "NO",
            "id": 15
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/geonet/Aligner.java:\n720                           public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n721                               handleFile(id, file, MetadataResourceVisibility.PUBLIC, changeDate, is, publicFiles[index]);\n722                           }\n846       private void handleFile(String id, String file, MetadataResourceVisibility visibility, String changeDate,\n847                               InputStream is, Element files) throws Exception {\n848           if (files == null) {\n849               if (log.isDebugEnabled())\n850                   log.debug(\"  - No file found in info.xml. Cannot update file:\" + file);\n851           } else {\n852               final Store store = context.getBean(\"resourceStore\", Store.class);\n853               final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n854               final String metadataUuid = metadataUtils.getMetadataUuid(id);\n855               removeOldFile(store, metadataUuid, files, visibility);\n856               saveFile(store, metadataUuid, file, visibility, changeDate, is);\n857           }\n858       }\n860       private void removeOldFile(Store store, String metadataUuid, Element infoFiles, MetadataResourceVisibility visibility) throws Exception {\n861           final List<MetadataResource> resources = store.getResources(context, metadataUuid, visibility, null, true);\n862           for (MetadataResource resource: resources) {\n863               if (infoFiles != null && !existsFile(resource.getId(), infoFiles)) {\n864                   if (log.isDebugEnabled()) {\n865                       log.debug(\"  - Removing old \" + metadataUuid + \" file with name=\" + resource.getFilename());\n866                   }\n867                   store.delResource(context, metadataUuid, visibility, resource.getFilename(), true);\n868               }\n869           }\n870       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n 67       @Override\n 68       public List<MetadataResource> getResources(final ServiceContext context, final String metadataUuid,\n 69                                                  final MetadataResourceVisibility visibility, String filter, Boolean approved) throws Exception {\n 70           final int metadataId = canDownload(context, metadataUuid, visibility, approved);\n 71           final SettingManager settingManager = context.getBean(SettingManager.class);\n 72   \n 73           final String resourceTypeDir = getMetadataDir(context, metadataId) + CMISConfiguration.getFolderDelimiter() + visibility.toString();\n 74   \n 75           List<MetadataResource> resourceList = new ArrayList<>();\n 76           if (filter == null) {\n 77               filter = FilesystemStore.DEFAULT_FILTER;\n 78           }\n 79   \n 80           PathMatcher matcher =\n 81                   FileSystems.getDefault().getPathMatcher(\"glob:\" + filter);\n 82   \n 83           try {\n 84               Folder parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(resourceTypeDir);\n 85   \n 86               Map<String, Document> documentMap = getCmisObjectMap(parentFolder, null);\n 87               for (Map.Entry<String, Document> entry : documentMap.entrySet()) {\n 88                   Document object = entry.getValue();\n 89                   String cmisFilePath = entry.getKey();\n 90                   // Only add to the list if it is a document and it matches the filter.\n 91                   if (object instanceof Document) {\n 92                       Path keyPath = new File(cmisFilePath).toPath().getFileName();\n 93                       if (matcher.matches(keyPath)) {\n 94                           final String filename = getFilename(cmisFilePath);\n 95                           MetadataResource resource = createResourceDescription(context, settingManager, metadataUuid, visibility, filename, object.getContentStreamLength(),\n 96                                   object.getLastModificationDate().getTime(), object.getVersionLabel(), metadataId, approved);\n 97                           resourceList.add(resource);\n 98                       }\n 99                   }\n100               }\n101           } catch (CmisObjectNotFoundException e) {\n102               // ignore as it means that there is not data to list.\n103           }\n104   \n105   \n106           resourceList.sort(MetadataResourceVisibility.sortByFileName);\n107   \n108           return resourceList;\n109       }\n128       private static String getFilename(final String key) {\n129           final String[] splittedKey = key.split(\"/\");\n130           return splittedKey[splittedKey.length - 1];\n131       }\n",
            "cost": 0.16781,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:129:48",
            "status": "corpus",
            "valid_path": "NO",
            "id": 16
        },
        {
            "blob": [
                "PHJvb3Q+CiAgICAgICAgPHNpdGU+CiAgICAgICAgICAgIDx1cmw+aHR0cDovL2V4YW1wbGUuY29tPC91cmw+CiAgICAgICAgICAgIDxpY29uPmljb24ucG5nPC9pY29uPgogICAgICAgICAgICA8eHNsZmlsdGVyPmZpbHRlci54c2w8L3hzbGZpbHRlcj4KICAgICAgICA8L3NpdGU+CiAgICAgICAgPHNlYXJjaGVzPgogICAgICAgICAgICA8c2VhcmNoPgogICAgICAgICAgICAgICAgPGZyb20+MjAyMSoxMiozMTwvZnJvbT4KICAgICAgICAgICAgICAgIDx1bnRpbD4yMDIxKjEyKjMxPC91bnRpbD4KICAgICAgICAgICAgICAgIDxzZXQ+c2V0MTwvc2V0PgogICAgICAgICAgICAgICAgPHByZWZpeD5vYWlfZGM8L3ByZWZpeD4KICAgICAgICAgICAgICAgIDxzdHlsZXNoZWV0PnN0eWxlLnhzbDwvc3R5bGVzaGVldD4KICAgICAgICAgICAgPC9zZWFyY2g+CiAgICAgICAgPC9zZWFyY2hlcz4KICAgIDwvcm9vdD4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/oaipmh/OaiPmhParams.java:\n 82       public void create(Element node) throws BadInputEx {\n 83           super.create(node);\n 84   \n 85           Element site = node.getChild(\"site\");\n 86           Element searches = node.getChild(\"searches\");\n 87   \n 88           url = Util.getParam(site, \"url\", \"\");\n 89           icon = Util.getParam(site, \"icon\", \"\");\n 90           xslfilter = Util.getParam(site, \"xslfilter\", \"\");\n 91   \n 92           addSearches(searches);\n 93       }\n150       private void addSearches(Element searches) throws BadInputEx {\n151           alSearches.clear();\n152   \n153           if (searches == null)\n154               return;\n155   \n156           for (Object o : searches.getChildren(\"search\")) {\n157               Element search = (Element) o;\n158   \n159               alSearches.add(new Search(search));\n160           }\n161       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/oaipmh/Search.java:\n 67       public Search(Element search) throws BadInputEx {\n 68           from = Util.getParam(search, \"from\", \"\");\n 69           until = Util.getParam(search, \"until\", \"\");\n 70           set = Util.getParam(search, \"set\", \"\");\n 71           prefix = Util.getParam(search, \"prefix\", \"oai_dc\");\n 72           stylesheet = Util.getParam(search, \"stylesheet\", \"\");\n 73   \n 74           //--- check from parameter\n 75   \n 76           ISODate fromDate = null;\n 77           ISODate untilDate = null;\n 78   \n 79   \t\ttry {\n 80   \t\t    if (StringUtils.isNotEmpty(from) && !from.equalsIgnoreCase(\"Invalid Date\")) {\n 81   \t\t\t\tfromDate = new ISODate(from);\n 82   \t\t\t\tfrom     = fromDate.getDateAsString();\n 83   \t\t\t} else {\n 84   \t\t\t    from = \"\";\n 85   \t\t\t}\n 86   \n 87           } catch (Exception e) {\n 88               throw new BadParameterEx(\"from\", from);\n 89           }\n 90   \n 91           //--- check until parameter\n 92   \n 93   \t\ttry {\n 94   \t\t    if (StringUtils.isNotEmpty(until) && !until.equalsIgnoreCase(\"Invalid Date\")) {\n 95   \t\t\t\tuntilDate = new ISODate(until);\n 96   \t\t\t\tuntil     = untilDate.getDateAsString();\n 97   \t\t\t} else {\n 98   \t\t\t    until = \"\";\n 99               }\n100   \t\t} catch(Exception e) {\n101   \t\t\tthrow new BadParameterEx(\"until\", until);\n102   \t\t}\n103   \n104           //--- check from <= until\n105   \n106           if (fromDate != null && untilDate != null)\n107               if (fromDate.timeDifferenceInSeconds(untilDate) > 0)\n108                   throw new BadParameterEx(\"from greater than until\", from + \">\" + until);\n109       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/ISODate.java:\n122       public ISODate(@Nonnull final String isoDateString) {\n123           setDateAndTime(isoDateString);\n124       }\n218       public void setDateAndTime(String isoDate) {\n219   \n220           String timeAndDate = isoDate;\n221           if (timeAndDate == null) {\n222               throw new IllegalArgumentException(\"Date string is null\");\n223           }\n224   \n225           if (timeAndDate.indexOf('T') >= 0 && StringUtils.contains(timeAndDate, ':')) {\n226               timeAndDate = DateUtil.convertToISOZuluDateTime(timeAndDate);\n227   \n228               if (timeAndDate == null) {\n229                   throw new IllegalArgumentException(\"Not parsable date: \" + isoDate);\n230               }\n231               internalDateTime = ZonedDateTime.parse(timeAndDate, DateUtil.ISO_OFFSET_DATE_TIME_NANOSECONDS);\n232               return;\n233           }\n234   \n235           if (StringUtils.contains(timeAndDate, ':')) {\n236               // its a time\n237               try {\n238                   internalDateTime = DateUtil.parseTime(StringUtils.remove(StringUtils.remove(timeAndDate, 't'), 'T'));\n239                   _shortDate = false;\n240               } catch (Exception e) {\n241                   throw new IllegalArgumentException(\"Invalid ISO time: \" + isoDate, e);\n242               }\n243           } else {\n244               // its a date\n245               parseDate(StringUtils.remove(StringUtils.remove(timeAndDate, 't'), 'T'));\n246   \n247           }\n248       }\n377       private void parseDate(@Nonnull String isoDate) {\n378           try {\n379               String[] parts = isoDate.split(\"[-/]\");\n380               if ((parts.length == 0) || (parts.length > 3)) {\n381                   throw new IllegalArgumentException(\"Invalid ISO date: \" + isoDate);\n382               }\n383   \n384               _shortDate = (parts.length == 3);\n385               _shortDateYearMonth = (parts.length == 2);\n386               _shortDateYear = (parts.length == 1);\n387   \n388               int year;\n389               if (parts[0].length() < 4) {\n390                   int shortYear = Integer.parseInt(parts[0]);\n391                   String thisYear = String.valueOf(ZonedDateTime.now(ZoneOffset.UTC).getYear());\n392                   int century = Integer.parseInt(thisYear.substring(0, 2)) * 100;\n393                   int yearInCentury = Integer.parseInt(thisYear.substring(2));\n394   \n395                   if (shortYear <= yearInCentury) {\n396                       year = century + shortYear;\n397                   } else {\n398                       year = century - 100 + shortYear;\n399                   }\n400               } else {\n401                   year = Integer.parseInt(parts[0]);\n402               }\n403   \n404               int month;\n405               if (_shortDate || _shortDateYearMonth) {\n406                   month = Integer.parseInt(parts[1]);\n407               } else {\n408                   month = 12;\n409               }\n410   \n411               int day;\n412               ZoneId offset = ZoneId.systemDefault();\n413               if (_shortDate) {\n414   \n415                   if (parts[2].toLowerCase().endsWith(\"z\")) {\n416                       offset = ZoneOffset.UTC;\n417                       day = Integer.parseInt(parts[2].substring(0, parts[2].length() - 1));\n418                   } else {\n419                       day = Integer.parseInt(parts[2]);\n420                   }\n421               } else {\n422                   // Calculate the last day for the year/month\n423                   day = YearMonth.of(year, month).atEndOfMonth().getDayOfMonth();\n424               }\n425   \n426               _shortDate = true;\n427               internalDateTime = ZonedDateTime.now(offset).withYear(year).withMonth(month).withDayOfMonth(day).withHour(0).withMinute(0)\n428                       .withSecond(0).withNano(0);\n429               //..ZonedDateTime.of(year, month, day, hour, minute, second, 0, offset);\n430   \n431           } catch (Exception e) {\n432               throw new IllegalArgumentException(\"Invalid ISO date: \" + isoDate, e);\n433           }\n434       }\n",
            "cost": 0.5648,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/ISODate.java:379:44",
            "status": "corpus",
            "valid_path": "YES",
            "id": 17
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n 914       @Override\n 915       public Element updateFixedInfo(String schema, Optional<Integer> metadataId, String uuid, Element md, String parentUuid,\n 916                                      UpdateDatestamp updateDatestamp, ServiceContext context) throws Exception {\n 917           boolean autoFixing = settingManager.getValueAsBool(Settings.SYSTEM_AUTOFIXING_ENABLE, true);\n 918           if (autoFixing) {\n 919               LOGGER_DATA_MANAGER.debug(\"Autofixing is enabled, trying update-fixed-info (updateDatestamp: {})\", updateDatestamp.name());\n 920   \n 921               AbstractMetadata metadata = null;\n 922               if (metadataId.isPresent()) {\n 923                   metadata = metadataUtils.findOne(metadataId.get());\n 924               }\n 925   \n 926               String currentUuid = metadata != null ? metadata.getUuid() : null;\n 927               String id = metadata != null ? metadata.getId() + \"\" : null;\n 928               uuid = uuid == null ? currentUuid : uuid;\n 929   \n 930               // --- setup environment\n 931               Element env = new Element(\"env\");\n 932               env.addContent(new Element(\"id\").setText(id));\n 933               env.addContent(new Element(\"uuid\").setText(uuid));\n 934   \n 935               env.addContent(thesaurusManager.buildResultfromThTable(context));\n 936   \n 937               Element schemaLoc = new Element(\"schemaLocation\");\n 938               schemaLoc.setAttribute(schemaManager.getSchemaLocation(schema, context));\n 939               env.addContent(schemaLoc);\n 940   \n 941               if (updateDatestamp == UpdateDatestamp.YES) {\n 942                   String changeDate = new ISODate().toString();\n 943                   String createDate = \"\";\n 944                   if (metadata != null) {\n 945                       changeDate = metadata.getDataInfo().getChangeDate().getDateAndTime();\n 946                       createDate = metadata.getDataInfo().getCreateDate().getDateAndTime();\n 947                   }\n 948                   env.addContent(new Element(\"changeDate\").setText(changeDate));\n 949                   env.addContent(new Element(\"createDate\").setText(createDate));\n 950               }\n 951               if (parentUuid != null) {\n 952                   env.addContent(new Element(\"parentUuid\").setText(parentUuid));\n 953               }\n 954               if (metadataId.isPresent()) {\n 955                   final Path resourceDir = Lib.resource.getDir(Params.Access.PRIVATE, metadataId.get());\n 956                   env.addContent(new Element(\"datadir\").setText(resourceDir.toString()));\n 957               }\n 958   \n 959               // add user information to env if user is authenticated (should be)\n 960               Element elUser = new Element(\"user\");\n 961               UserSession usrSess = context.getUserSession();\n 962               if (usrSess.isAuthenticated()) {\n 963                   String myUserId = usrSess.getUserId();\n 964                   User user = getApplicationContext().getBean(UserRepository.class).findOne(myUserId);\n 965                   if (user != null) {\n 966                       Element elUserDetails = new Element(\"details\");\n 967                       elUserDetails.addContent(new Element(\"surname\").setText(user.getSurname()));\n 968                       elUserDetails.addContent(new Element(\"firstname\").setText(user.getName()));\n 969                       elUserDetails.addContent(new Element(\"organisation\").setText(user.getOrganisation()));\n 970                       elUserDetails.addContent(new Element(\"username\").setText(user.getUsername()));\n 971                       elUser.addContent(elUserDetails);\n 972                       env.addContent(elUser);\n 973                   }\n 974               }\n 975   \n 976               // add original metadata to result\n 977               Element result = new Element(\"root\");\n 978               // Remove the 'geonet' namespace to avoid adding it to the\n 979               // processed elements in updated-fixed-info\n 980               md.removeNamespaceDeclaration(Geonet.Namespaces.GEONET);\n 981               result.addContent(md);\n 982               // add 'environment' to result\n 983               env.addContent(new Element(\"siteURL\").setText(settingManager.getSiteURL(context)));\n 984               env.addContent(new Element(\"nodeURL\").setText(settingManager.getNodeURL()));\n 985               env.addContent(new Element(\"node\").setText(context.getNodeId()));\n 986   \n 987               // Settings were defined as an XML starting with root named config\n 988               // Only second level elements are defined (under system).\n 989               List<?> config = settingManager.getAllAsXML(true).cloneContent();\n 990               for (Object c : config) {\n 991                   Element settings = (Element) c;\n 992                   env.addContent(settings);\n 993               }\n 994   \n 995               result.addContent(env);\n 996               // apply update-fixed-info.xsl\n 997               Path styleSheet = metadataSchemaUtils.getSchemaDir(schema).resolve(\n 998                   metadata != null\n 999                       && (\n1000                           metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE\n1001                           || metadata.getDataInfo().getType() == MetadataType.TEMPLATE_OF_SUB_TEMPLATE)?\n1002                       Geonet.File.UPDATE_FIXED_INFO_SUBTEMPLATE :\n1003                       Geonet.File.UPDATE_FIXED_INFO);\n1004               result = Xml.transform(result, styleSheet);\n1005               return result;\n1006           } else {\n1007               LOGGER_DATA_MANAGER.debug(\"Autofixing is disabled, not applying update-fixed-info\");\n1008               return md;\n1009           }\n1010       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/setting/SettingManager.java:\n110       public Element getAllAsXML(boolean asTree) {\n111           Element env = new Element(\"settings\");\n112           List<Setting> settings = repo.findAll(SortUtils.createSort(Setting_.name));\n113   \n114           Map<String, Element> pathElements = new HashMap<String, Element>();\n115   \n116           for (Setting setting : settings) {\n117               if (asTree) {\n118                   buildXmlTree(env, pathElements, setting);\n119               } else {\n120                   Element settingEl = new Element(\"setting\");\n121                   settingEl.setAttribute(\"name\", setting.getName());\n122                   settingEl.setAttribute(\"position\", String.valueOf(setting.getPosition()));\n123                   settingEl.setAttribute(\"datatype\", String.valueOf(setting.getDataType()));\n124                   settingEl.setAttribute(\"internal\", String.valueOf(setting.isInternal()));\n125                   settingEl.setText(setting.getValue());\n126                   env.addContent(settingEl);\n127               }\n128           }\n129           return env;\n130       }\n132       private void buildXmlTree(Element env, Map<String, Element> pathElements, Setting setting) {\n133           String[] segments = setting.getName().split(\"/\");\n134           Element parent = env;\n135           StringBuilder path = new StringBuilder();\n136           for (int i = 0; i < segments.length; i++) {\n137               String segment = segments[i];\n138               path.append(\"/\").append(segment);\n139               Element currentElement = pathElements.get(path.toString());\n140               if (currentElement == null) {\n141                   try {\n142                       currentElement = new Element(segment);\n143                       currentElement.setAttribute(\"name\", path.substring(1));\n144                       currentElement.setAttribute(\"position\", String.valueOf(setting.getPosition()));\n145                       if (i == segments.length - 1) {\n146                           final SettingDataType dataType;\n147                           if (setting.getDataType() != null) {\n148                               dataType = setting.getDataType();\n149                           } else {\n150                               dataType = SettingDataType.STRING;\n151                           }\n152                           currentElement.setAttribute(\"datatype\", String.valueOf(dataType.ordinal()));\n153                           currentElement.setAttribute(\"datatypeName\", dataType.name());\n154   \n155                           if (setting.getValue() != null)\n156                               currentElement.setText(xmlContentEscaper().escape(setting.getValue()));\n157                       } else {\n158                           currentElement.setText(\"\");\n159                       }\n160                       parent.addContent(currentElement);\n161                       pathElements.put(path.toString(), currentElement);\n162                   } catch (Exception e) {\n163                       Log.error(\"Settings table has an illegal setting: \" + path, e);\n164                   }\n165               }\n166   \n167               parent = currentElement;\n168           }\n169       }\n",
            "cost": 0.12290000000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/setting/SettingManager.java:133:53",
            "status": "corpus",
            "valid_path": "NO",
            "id": 18
        },
        {
            "blob": [
                "CiAgICA8cm9vdD4KICAgICAgICA8c2V0dGluZ3M+CiAgICAgICAgICAgIDxzZXR0aW5nPgogICAgICAgICAgICAgICAgPGtleT5TZXR0aW5ncy5NRVRBREFUQV9XT1JLRkxPV19EUkFGVF9XSEVOX0lOX0dST1VQPC9rZXk+CiAgICAgICAgICAgICAgICA8dmFsdWU+Lio8L3ZhbHVlPiA8IS0tIEEgcmVnZXggcGF0dGVybiBpbnRlbmRlZCB0byBtYXRjaCBhbnkgaW5wdXQgLS0+CiAgICAgICAgICAgIDwvc2V0dGluZz4KICAgICAgICA8L3NldHRpbmdzPgogICAgICAgIDxncm91cD4KICAgICAgICAgICAgPG5hbWU+YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYSo8L25hbWU+CiAgICAgICAgPC9ncm91cD4KICAgIDwvcm9vdD4KICAgIA=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n489       public static void importRecord(String uuid, MEFLib.UuidAction uuidAction, List<Element> md, String schema, int index, String source,\n490           String sourceName, Map<String, String> sourceTranslations, ServiceContext context, List<String> id, String createDate,\n491           String changeDate, String groupId, MetadataType isTemplate) throws Exception {\n492   \n493           GeonetContext gc = (GeonetContext) context.getHandlerContext(Geonet.CONTEXT_NAME);\n494           DataManager dm = gc.getBean(DataManager.class);\n495           IMetadataManager metadataManager = gc.getBean(IMetadataManager.class);\n496   \n497           if (uuid == null || uuid.equals(\"\") || uuidAction == MEFLib.UuidAction.GENERATEUUID) {\n498               String newuuid = UUID.randomUUID().toString();\n499               source = null;\n500   \n501               Log.debug(Geonet.MEF, \"Replacing UUID \" + uuid + \" with \" + newuuid);\n502               uuid = newuuid;\n503   \n504               // --- set uuid inside metadata\n505               md.add(index, dm.setUUID(schema, uuid, md.get(index)));\n506           } else {\n507               if (sourceName == null)\n508                   sourceName = \"???\";\n509   \n510               if (source == null || source.trim().length() == 0)\n511                   throw new Exception(\"Missing siteId parameter from info.xml file\");\n512   \n513               // --- only update sources table if source is not current site\n514               SourceRepository sourceRepository = context.getBean(SourceRepository.class);\n515               Source sourceObject = sourceRepository.findOneByUuid(source);\n516               if (sourceObject == null || (!source.equals(gc.getBean(SettingManager.class).getSiteId())\n517                   && SourceType.harvester != sourceObject.getType())) {\n518                   Source source1 = new Source(source, sourceName, sourceTranslations, SourceType.externalportal);\n519                   context.getBean(SourceRepository.class).save(source1);\n520               }\n521           }\n522   \n523           try {\n524               if (dm.existsMetadataUuid(uuid) && uuidAction != MEFLib.UuidAction.NOTHING) {\n525                   // user has privileges to replace the existing metadata\n526                   if (dm.getAccessManager().canEdit(context, dm.getMetadataId(uuid))) {\n527                       if (Log.isDebugEnabled(Geonet.MEF)) {\n528                           Log.debug(Geonet.MEF, \"Deleting existing metadata with UUID : \" + uuid);\n529                       }\n530                       metadataManager.deleteMetadata(context, dm.getMetadataId(uuid));\n531                       metadataManager.flush();\n532                   }\n533                   // user does not hav privileges to replace the existing metadata\n534                   else {\n535                       throw new UnAuthorizedException(\"User has no privilege to replace existing metadata\", null);\n536                   }\n537               }\n538           } catch (Exception e) {\n539               throw new Exception(\" Existing metadata with UUID \" + uuid + \" could not be deleted. Error is: \" + e.getMessage());\n540           }\n541   \n542           if (Log.isDebugEnabled(Geonet.MEF))\n543               Log.debug(Geonet.MEF, \"Adding metadata with uuid:\" + uuid);\n544   \n545           //\n546           // insert metadata\n547           //\n548           int userid = context.getUserSession().getUserIdAsInt();\n549           String docType = null, category = null;\n550           boolean ufo = false, indexImmediate = false;\n551   \n552           String metadataId = metadataManager\n553               .insertMetadata(context, schema, md.get(index), uuid, userid, groupId, source, isTemplate.codeString, docType, category,\n554                   createDate, changeDate, ufo, indexImmediate);\n555   \n556           dm.activateWorkflowIfConfigured(context, metadataId, groupId);\n557   \n558           id.add(index, metadataId);\n559   \n560       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEF2Visitor.java:\n 51       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 52           handleXml(mefFile, v);\n 53       }\n 59       public Element handleXml(Path mefFile, IMEFVisitor v) throws Exception {\n 60   \n 61           Logger log = Log.createLogger(Geonet.MEF);\n 62   \n 63           int nbMetadata = 0;\n 64           Element fc;\n 65   \n 66           Element info = new Element(\"info\");\n 67   \n 68   \n 69           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n 70               Path root = zipFs.getRootDirectories().iterator().next();\n 71               // Get the metadata depth\n 72               if (IO.isEmptyDir(root)) {\n 73                   log.debug(\"Metadata folder is directly under the unzip temporary folder.\");\n 74               } else {\n 75                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 76                       for (Path file : paths) {\n 77                           if (Files.isDirectory(file)) {\n 78                               // Handle metadata file\n 79                               Path metadataDir = file.resolve(\"metadata\");\n 80   \n 81                               if (IO.isEmptyDir(metadataDir)) {\n 82                                   throw new BadFormatEx(\n 83                                       \"Missing XML document in metadata folder \" + metadataDir + \"in MEF file \"\n 84                                           + mefFile + \".\");\n 85                               }\n 86   \n 87                               // Handle feature catalog\n 88                               Path fcFile = getFeatureCalalogFile(file);\n 89                               if (fcFile != null) {\n 90                                   fc = Xml.loadFile(fcFile);\n 91                               } else {\n 92                                   fc = null;\n 93                               }\n 94   \n 95                               // Handle info file\n 96                               Path fileInfo = file.resolve(FILE_INFO);\n 97                               if (Files.exists(fileInfo)) {\n 98                                   info = Xml.loadFile(fileInfo);\n 99                               }\n100   \n101                               try (DirectoryStream<Path> xmlFiles = Files.newDirectoryStream(metadataDir)) {\n102                                   v.handleMetadataFiles(xmlFiles, info, nbMetadata);\n103                               }\n104                               v.handleFeatureCat(fc, nbMetadata);\n105                               v.handleInfo(info, nbMetadata);\n106   \n107                               // Handle binaries\n108                               handleBin(file, v, info, nbMetadata);\n109   \n110                               nbMetadata++;\n111                           }\n112                       }\n113                   }\n114               }\n115           }\n116   \n117           return info;\n118       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/DataManager.java:\n537       @Deprecated\n538       public void activateWorkflowIfConfigured(ServiceContext context, String newId, String groupOwner) throws Exception {\n539           metadataStatus.activateWorkflowIfConfigured(context, newId, groupOwner);\n540       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataStatus.java:\n177       @Override\n178       public void activateWorkflowIfConfigured(ServiceContext context, String newId, String groupOwner) throws Exception {\n179           if (StringUtils.isEmpty(groupOwner)) {\n180               return;\n181           }\n182   \n183           final Optional<Group> group = groupRepository.findById(Integer.valueOf(groupOwner));\n184           String groupName = \"\";\n185           if (group.isPresent()) {\n186               groupName = group.get().getName();\n187           }\n188   \n189           if (WorkflowUtil.isGroupWithEnabledWorkflow(groupName)) {\n190               setStatus(context, Integer.valueOf(newId), Integer.valueOf(StatusValue.Status.DRAFT), new ISODate(),\n191                       String.format(\"Workflow automatically enabled for record in group '%s'. Record status is set to %s.\",\n192                               groupName, StatusValue.Status.DRAFT));\n193           }\n194       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/util/WorkflowUtil.java:\n46       public static boolean isGroupWithEnabledWorkflow(String groupName) {\n47           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n48   \n49           String groupMatchingRegex = settingManager.getValue(Settings.METADATA_WORKFLOW_DRAFT_WHEN_IN_GROUP);\n50   \n51           if (!StringUtils.isEmpty(groupMatchingRegex)) {\n52               final Pattern pattern = Pattern.compile(groupMatchingRegex);\n53               final Matcher matcher = pattern.matcher(groupName);\n54               return matcher.find();\n55           } else {\n56               return false;\n57           }\n58       }\n",
            "cost": 1.1246800000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/util/WorkflowUtil.java:52:53",
            "status": "corpus",
            "valid_path": "YES",
            "id": 19
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n140       void updateMetadata(Element xml, final String id, GroupMapper localGroups, final CategoryMapper localCateg,\n141           String changeDate, BaseAligner<LocalFilesystemParams> aligner,\n142           boolean force) throws Exception {\n143   \n144           log.debug(\"  - Updating metadata with id: \" + id);\n145   \n146           String language = context.getLanguage();\n147   \n148           final AbstractMetadata metadata = metadataManager.updateMetadata(context, id, xml, false, false, false, language, changeDate,\n149               true);\n150   \n151           if (force) {\n152               //change ownership of metadata to new harvester (Used in OVERRIDE option)\n153               log.debug(String.format(\"  - Changing source of metadata id %s to '%s' harvester\", id, params.getName()));\n154   \n155               metadata.getHarvestInfo().setUuid(params.getUuid());\n156               metadata.getSourceInfo().setSourceId(params.getUuid());\n157               metadataManager.save(metadata);\n158           }\n159   \n160           OperationAllowedRepository repository = context.getBean(OperationAllowedRepository.class);\n161           repository.deleteAllByMetadataId(Integer.parseInt(id));\n162           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n163   \n164           metadata.getCategories().clear();\n165           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, true);\n166   \n167           metadataManager.flush();\n168   \n169           dataMan.indexMetadata(id, true);\n170       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n273       private void updateMetadata(Path file, Path filePath, Element xml, String schema, String id,\n274           AbstractMetadata metadata, boolean force)\n275           throws Exception {\n276           // Check last modified date of the file with the record change date\n277           // to check if an update is required\n278           if (params.checkFileLastModifiedForUpdate) {\n279               Date fileDate = new Date(Files.getLastModifiedTime(file).toMillis());\n280   \n281               ISODate modified = new ISODate();\n282               if (metadata.getDataInfo() != null) {\n283                   modified = metadata.getDataInfo().getChangeDate();\n284               }\n285   \n286               Date recordDate = modified.toDate();\n287   \n288               String changeDate = new ISODate(fileDate.getTime(), false).getDateAndTime();\n289   \n290               LOGGER.debug(\" File date is: {} / record date is: {}\", filePath, modified);\n291   \n292               if (DateUtils.truncate(recordDate, Calendar.SECOND)\n293                   .before(DateUtils.truncate(fileDate, Calendar.SECOND))) {\n294                   LOGGER.debug(\"  Db record is older than file. Updating record with id: {}\", id);\n295                   updateMedata(xml, id, changeDate, force);\n296               } else {\n297                   LOGGER.debug(\"  Db record is not older than last modified date of file. No need for update.\");\n298                   result.unchangedMetadata++;\n299               }\n300           } else {\n301               LOGGER.debug(\"  updating existing metadata, id is: \" + id);\n302   \n303               String changeDate;\n304   \n305               try {\n306                   changeDate = dataMan.extractDateModified(schema, xml);\n307               } catch (Exception ex) {\n308                   LOGGER.error(\"LocalFilesystemHarvester - updateMetadata - can't get metadata modified date for \" +\n309                       \"metadata id= {}, using current date for modified date\", id);\n310                   changeDate = new ISODate().toString();\n311               }\n312   \n313               updateMedata(xml, id, changeDate, force);\n314           }\n315       }\n405       private void updateMedata(Element xml, String id, String changeDate, boolean force) throws Exception {\n406           harvester.updateMetadata(xml, id, localGroups, localCateg, changeDate, aligner, force);\n407           listOfRecordsToIndex.add(Integer.valueOf(id));\n408           result.updatedMetadata++;\n409       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 715       @Override\n 716       public synchronized AbstractMetadata updateMetadata(final ServiceContext context, final String metadataId, final Element md,\n 717                                                           final boolean validate, final boolean ufo, final boolean index, final String lang, final String changeDate,\n 718                                                           final boolean updateDateStamp) throws Exception {\n 719           Log.trace(Geonet.DATA_MANAGER, \"Update record with id \" + metadataId);\n 720   \n 721           Element metadataXml = md;\n 722   \n 723           // when invoked from harvesters, session is null?\n 724           UserSession session = context.getUserSession();\n 725           if (session != null) {\n 726               session.removeProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n 727           }\n 728           String schema = metadataSchemaUtils.getMetadataSchema(metadataId);\n 729           if (ufo) {\n 730               String parentUuid = null;\n 731               Integer intId = Integer.valueOf(metadataId);\n 732   \n 733               final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 734   \n 735               String uuid = findUuid(metadataXml, schema, metadata);\n 736   \n 737               metadataXml = updateFixedInfo(schema, Optional.of(intId), uuid, metadataXml, parentUuid,\n 738                   (updateDateStamp ? UpdateDatestamp.YES : UpdateDatestamp.NO), context);\n 739           }\n 740   \n 741           // --- force namespace prefix for iso19139 metadata\n 742           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 743   \n 744           // Notifies the metadata change to metatada notifier service\n 745           final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 746   \n 747           String uuid = findUuid(metadataXml, schema, metadata);\n 748   \n 749           metadataUtils.checkMetadataWithSameUuidExist(uuid, metadata.getId());\n 750   \n 751           // --- write metadata to dbms\n 752           getXmlSerializer().update(metadataId, metadataXml, changeDate, updateDateStamp, uuid, context);\n 753   \n 754           try {\n 755               // --- do the validation last - it throws exceptions\n 756               if (session != null && validate) {\n 757                   metadataValidator.doValidate(session, schema, metadataId, metadataXml, lang, false);\n 758               }\n 759           } finally {\n 760               if (index) {\n 761                   // --- update search criteria\n 762                   metadataIndexer.indexMetadata(metadataId, true);\n 763               }\n 764           }\n 765   \n 766           if (metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE) {\n 767               if (!index) {\n 768                   metadataIndexer.indexMetadata(metadataId, true);\n 769               }\n 770   //\t\t\tTODOES\n 771   //            MetaSearcher searcher = searcherForReferencingMetadata(context, metadata);\n 772   //            Map<Integer, AbstractMetadata> result = ((LuceneSearcher) searcher).getAllMdInfo(context, 500);\n 773   //            for (Integer id : result.keySet()) {\n 774   //                IndexingList list = context.getBean(IndexingList.class);\n 775   //                list.add(id);\n 776   //            }\n 777           }\n 778   \n 779           Log.trace(Geonet.DATA_MANAGER, \"Finishing update of record with id \" + metadataId);\n 780           // Return an up to date metadata record\n 781           return metadataUtils.findOne(metadataId);\n 782       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataValidator.java:\n284       private Element getXSDXmlReport(String schema, Element md, boolean forEditing) {\n285           // NOTE: this method assumes that enumerateTree has NOT been run on the metadata\n286           XmlErrorHandler errorHandler;\n287           if (forEditing) {\n288               errorHandler = new BaseErrorHandlerAttachingErrorToElem();\n289               ((BaseErrorHandlerAttachingErrorToElem) errorHandler).setElementDecorator(this);\n290           } else {\n291               errorHandler = new XmlErrorHandler();\n292           }\n293           errorHandler.setNs(Edit.NAMESPACE);\n294           try {\n295               Element xsdErrors = validateInfo(schema, md, errorHandler);\n296               if (forEditing) {\n297                   ((BaseErrorHandlerAttachingErrorToElem) errorHandler).attachReports();\n298               }\n299               return xsdErrors;\n300           } catch (Exception e) {\n301               return JeevesException.toElement(e);\n302           }\n303       }\n434       @Override\n435       public Pair<Element, String> doValidate(UserSession session, String schema, String metadataId, Element md, String lang,\n436                                               boolean forEditing) throws Exception {\n437           int intMetadataId = Integer.parseInt(metadataId);\n438           String version = null;\n439           LOGGER.debug(\"Creating validation report for record #{} [schema: {}].\", metadataId, schema);\n440   \n441           Element sessionReport = (Element) session.getProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n442           if (sessionReport != null && !forEditing) {\n443               LOGGER.debug(\"  Validation report available in session.\");\n444               sessionReport.detach();\n445               return Pair.read(sessionReport, version);\n446           }\n447   \n448           List<MetadataValidation> validations = new ArrayList<>();\n449           Element errorReport = new Element(\"report\", Edit.NAMESPACE);\n450           errorReport.setAttribute(\"id\", metadataId, Edit.NAMESPACE);\n451   \n452           // -- get an XSD validation report and add results to the metadata\n453           // -- as geonet:xsderror attributes on the affected elements\n454           Element xsdErrors = getXSDXmlReport(schema, md, forEditing);\n455           int xsdErrorCount = 0;\n456           if (xsdErrors != null) {\n457               xsdErrorCount = xsdErrors.getContent().size();\n458           }\n459           if (xsdErrorCount > 0) {\n460               errorReport.addContent(xsdErrors);\n461               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n462                   .setStatus(MetadataValidationStatus.INVALID).setRequired(true).setNumTests(xsdErrorCount)\n463                   .setNumFailures(xsdErrorCount));\n464               if (LOGGER.isDebugEnabled()) {\n465                   LOGGER.debug(\"  - XSD error: {}\", Xml.getString(xsdErrors));\n466               }\n467           } else {\n468               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n469                   .setStatus(MetadataValidationStatus.VALID).setRequired(true).setNumTests(1).setNumFailures(0));\n470               LOGGER.trace(\"Valid.\");\n471           }\n472   \n473           // ...then schematrons\n474           Element error = null;\n475           if (forEditing) {\n476               LOGGER.debug(\"  - Schematron in editing mode.\");\n477               // -- now expand the elements and add the geonet: elements\n478               metadataManager.getEditLib().expandElements(schema, md);\n479               version = metadataManager.getEditLib().getVersionForEditing(schema, metadataId, md);\n480   \n481               error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n482           } else {\n483               // enumerate the metadata xml so that we can report any problems found by the schematron_xml script to the geonetwork editor\n484               metadataManager.getEditLib().enumerateTree(md);\n485               try {\n486                   error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n487               } catch (Exception e) {\n488                   LOGGER.error(\"Could not run schematron validation on metadata {}.\", metadataId);\n489                   LOGGER.error(\"Could not run schematron validation on metadata, exception.\", e);\n490               } finally {\n491                   // remove editing info added by enumerateTree\n492                   metadataManager.getEditLib().removeEditingInfo(md);\n493               }\n494           }\n495   \n496           if (error != null) {\n497               errorReport.addContent(error);\n498           }\n499   \n500           saveValidationStatus(intMetadataId, validations);\n501   \n502           session.setProperty(Geonet.Session.VALIDATION_REPORT + metadataId, errorReport);\n503   \n504           return Pair.read(errorReport, version);\n505       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/exceptions/JeevesException.java:\n 65       public static Element toElement(Throwable t) {\n 66           String msg = t.getMessage();\n 67           String cls = t.getClass().getSimpleName();\n 68           String id = Constants.ERROR;\n 69           Object obj = null;\n 70   \n 71           if (t instanceof JeevesException) {\n 72               JeevesException je = (JeevesException) t;\n 73   \n 74               id = je.getId();\n 75               obj = je.getObject();\n 76           }\n 77   \n 78           Element error = new Element(Constants.ERROR)\n 79               .addContent(new Element(\"message\").setText(\n 80                   msg == null ? \n 81                       \"\" : msg.replaceAll(XML10_ILLEGAL_CHAR_PATTERN, \"\")))\n 82               .addContent(new Element(\"class\").setText(cls))\n 83               .addContent(getStackTrace(t, 10));\n 84   \n 85           error.setAttribute(\"id\", id);\n 86   \n 87           if (obj != null) {\n 88               Element elObj = new Element(\"object\");\n 89   \n 90               if (obj instanceof Element) elObj.addContent(((Element) obj).detach());\n 91               else elObj.setText(obj.toString());\n 92   \n 93               error.addContent(elObj);\n 94           }\n 95   \n 96           return error;\n 97       }\n",
            "cost": 0.12071,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/exceptions/JeevesException.java:81:41",
            "status": "corpus",
            "valid_path": "NO",
            "id": 20
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxyb290IHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgICAgICA8ZWxlbWVudCB4bGluazpocmVmPSJodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/cGFyYW09KiZhbm90aGVycGFyYW09dmFsdWUiIC8+CiAgICAgICAgPGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3BhcmFtMT12YWx1ZTEmcGFyYW0yPSomcGFyYW0zPXZhbHVlMyIgLz4KICAgICAgICA8ZWxlbWVudCB4bGluazpocmVmPSJodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/cGFyYW09KiZhbm90aGVycGFyYW09KiIgLz4KICAgIDwvcm9vdD4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 1.072225,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:195:38",
            "status": "corpus",
            "valid_path": "YES",
            "id": 21
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n181       private static Element resolveXLink(String uri, String idSearch, ServiceContext srvContext) throws IOException, JDOMException, CacheException {\n182   \n183           Element remoteFragment = null;\n184           try {\n185               // TODO-API: Support local protocol on /api/registries/\n186               if (uri.startsWith(XLink.LOCAL_PROTOCOL)) {\n187                   SpringLocalServiceInvoker springLocalServiceInvoker = srvContext.getBean(SpringLocalServiceInvoker.class);\n188                   remoteFragment = (Element)springLocalServiceInvoker.invoke(uri);\n189               } else {\n190                   // Avoid references to filesystem\n191                   if (uri.toLowerCase().startsWith(\"file://\")) {\n192                       return null;\n193                   }\n194   \n195                   uri = uri.replaceAll(\"&+\", \"&\");\n196                   String mappedURI = mapURI(uri);\n197   \n198                   JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n199                   remoteFragment = (Element) xlinkCache.getFromGroup(uri.toLowerCase(), mappedURI);\n200                   if (remoteFragment == null) {\n201                       Log.info(Log.XLINK_PROCESSOR, \"cache MISS on \" + uri.toLowerCase());\n202                       URL url = new URL(uri.replaceAll(\"&amp;\", \"&\"));\n203   \n204                       URLConnection conn = url.openConnection();\n205                       conn.setConnectTimeout(1000);\n206   \n207                       BufferedInputStream in = new BufferedInputStream(conn.getInputStream());\n208                       try {\n209                           remoteFragment = Xml.loadStream(in);\n210                           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n211                               Log.debug(Log.XLINK_PROCESSOR, \"Read:\\n\" + Xml.getString(remoteFragment));\n212                       } finally {\n213                           in.close();\n214                       }\n215                   } else {\n216                       Log.debug(Log.XLINK_PROCESSOR, \"cache HIT on \" + uri.toLowerCase());\n217                   }\n218   \n219                   if (remoteFragment != null && !remoteFragment.getName().equalsIgnoreCase(\"error\")) {\n220                       xlinkCache.putInGroup(uri.toLowerCase(), mappedURI, remoteFragment);\n221                       if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n222                           Log.debug(Log.XLINK_PROCESSOR, \"cache miss for \" + uri);\n223                   } else {\n224                       return null;\n225                   }\n226   \n227               }\n228           } catch (Exception e) {    // MalformedURLException, IOException\n229               Log.error(Log.XLINK_PROCESSOR, \"Failed on \" + uri, e);\n230           }\n231   \n232           // search for and return only the xml fragment that has @id=idSearch\n233   \n234           Element res = null;\n235           if (idSearch != null) {\n236               String xpath = \"*//*[@id='\" + idSearch + \"']\";\n237               try {\n238                   res = Xml.selectElement(remoteFragment, xpath);\n239                   if (res != null) {\n240                       res = (Element) res.clone();\n241                       res.removeAttribute(\"id\");\n242                   }\n243               } catch (Exception e) {\n244                   Log.warning(Log.XLINK_PROCESSOR, \"Failed to search for remote fragment using \" + xpath + \", error\" + e.getMessage());\n245                   return null;\n246               }\n247           } else {\n248               if (remoteFragment == null) {\n249                   return null;\n250               } else {\n251                   res = (Element) remoteFragment.clone();\n252               }\n253           }\n254           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n255               Log.debug(Log.XLINK_PROCESSOR, \"Read:\" + Xml.getString(res));\n256           return res;\n257       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 0.16708499999999998,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:202:54",
            "status": "corpus",
            "valid_path": "NO",
            "id": 22
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n140       void updateMetadata(Element xml, final String id, GroupMapper localGroups, final CategoryMapper localCateg,\n141           String changeDate, BaseAligner<LocalFilesystemParams> aligner,\n142           boolean force) throws Exception {\n143   \n144           log.debug(\"  - Updating metadata with id: \" + id);\n145   \n146           String language = context.getLanguage();\n147   \n148           final AbstractMetadata metadata = metadataManager.updateMetadata(context, id, xml, false, false, false, language, changeDate,\n149               true);\n150   \n151           if (force) {\n152               //change ownership of metadata to new harvester (Used in OVERRIDE option)\n153               log.debug(String.format(\"  - Changing source of metadata id %s to '%s' harvester\", id, params.getName()));\n154   \n155               metadata.getHarvestInfo().setUuid(params.getUuid());\n156               metadata.getSourceInfo().setSourceId(params.getUuid());\n157               metadataManager.save(metadata);\n158           }\n159   \n160           OperationAllowedRepository repository = context.getBean(OperationAllowedRepository.class);\n161           repository.deleteAllByMetadataId(Integer.parseInt(id));\n162           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n163   \n164           metadata.getCategories().clear();\n165           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, true);\n166   \n167           metadataManager.flush();\n168   \n169           dataMan.indexMetadata(id, true);\n170       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n273       private void updateMetadata(Path file, Path filePath, Element xml, String schema, String id,\n274           AbstractMetadata metadata, boolean force)\n275           throws Exception {\n276           // Check last modified date of the file with the record change date\n277           // to check if an update is required\n278           if (params.checkFileLastModifiedForUpdate) {\n279               Date fileDate = new Date(Files.getLastModifiedTime(file).toMillis());\n280   \n281               ISODate modified = new ISODate();\n282               if (metadata.getDataInfo() != null) {\n283                   modified = metadata.getDataInfo().getChangeDate();\n284               }\n285   \n286               Date recordDate = modified.toDate();\n287   \n288               String changeDate = new ISODate(fileDate.getTime(), false).getDateAndTime();\n289   \n290               LOGGER.debug(\" File date is: {} / record date is: {}\", filePath, modified);\n291   \n292               if (DateUtils.truncate(recordDate, Calendar.SECOND)\n293                   .before(DateUtils.truncate(fileDate, Calendar.SECOND))) {\n294                   LOGGER.debug(\"  Db record is older than file. Updating record with id: {}\", id);\n295                   updateMedata(xml, id, changeDate, force);\n296               } else {\n297                   LOGGER.debug(\"  Db record is not older than last modified date of file. No need for update.\");\n298                   result.unchangedMetadata++;\n299               }\n300           } else {\n301               LOGGER.debug(\"  updating existing metadata, id is: \" + id);\n302   \n303               String changeDate;\n304   \n305               try {\n306                   changeDate = dataMan.extractDateModified(schema, xml);\n307               } catch (Exception ex) {\n308                   LOGGER.error(\"LocalFilesystemHarvester - updateMetadata - can't get metadata modified date for \" +\n309                       \"metadata id= {}, using current date for modified date\", id);\n310                   changeDate = new ISODate().toString();\n311               }\n312   \n313               updateMedata(xml, id, changeDate, force);\n314           }\n315       }\n405       private void updateMedata(Element xml, String id, String changeDate, boolean force) throws Exception {\n406           harvester.updateMetadata(xml, id, localGroups, localCateg, changeDate, aligner, force);\n407           listOfRecordsToIndex.add(Integer.valueOf(id));\n408           result.updatedMetadata++;\n409       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 715       @Override\n 716       public synchronized AbstractMetadata updateMetadata(final ServiceContext context, final String metadataId, final Element md,\n 717                                                           final boolean validate, final boolean ufo, final boolean index, final String lang, final String changeDate,\n 718                                                           final boolean updateDateStamp) throws Exception {\n 719           Log.trace(Geonet.DATA_MANAGER, \"Update record with id \" + metadataId);\n 720   \n 721           Element metadataXml = md;\n 722   \n 723           // when invoked from harvesters, session is null?\n 724           UserSession session = context.getUserSession();\n 725           if (session != null) {\n 726               session.removeProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n 727           }\n 728           String schema = metadataSchemaUtils.getMetadataSchema(metadataId);\n 729           if (ufo) {\n 730               String parentUuid = null;\n 731               Integer intId = Integer.valueOf(metadataId);\n 732   \n 733               final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 734   \n 735               String uuid = findUuid(metadataXml, schema, metadata);\n 736   \n 737               metadataXml = updateFixedInfo(schema, Optional.of(intId), uuid, metadataXml, parentUuid,\n 738                   (updateDateStamp ? UpdateDatestamp.YES : UpdateDatestamp.NO), context);\n 739           }\n 740   \n 741           // --- force namespace prefix for iso19139 metadata\n 742           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 743   \n 744           // Notifies the metadata change to metatada notifier service\n 745           final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 746   \n 747           String uuid = findUuid(metadataXml, schema, metadata);\n 748   \n 749           metadataUtils.checkMetadataWithSameUuidExist(uuid, metadata.getId());\n 750   \n 751           // --- write metadata to dbms\n 752           getXmlSerializer().update(metadataId, metadataXml, changeDate, updateDateStamp, uuid, context);\n 753   \n 754           try {\n 755               // --- do the validation last - it throws exceptions\n 756               if (session != null && validate) {\n 757                   metadataValidator.doValidate(session, schema, metadataId, metadataXml, lang, false);\n 758               }\n 759           } finally {\n 760               if (index) {\n 761                   // --- update search criteria\n 762                   metadataIndexer.indexMetadata(metadataId, true);\n 763               }\n 764           }\n 765   \n 766           if (metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE) {\n 767               if (!index) {\n 768                   metadataIndexer.indexMetadata(metadataId, true);\n 769               }\n 770   //\t\t\tTODOES\n 771   //            MetaSearcher searcher = searcherForReferencingMetadata(context, metadata);\n 772   //            Map<Integer, AbstractMetadata> result = ((LuceneSearcher) searcher).getAllMdInfo(context, 500);\n 773   //            for (Integer id : result.keySet()) {\n 774   //                IndexingList list = context.getBean(IndexingList.class);\n 775   //                list.add(id);\n 776   //            }\n 777           }\n 778   \n 779           Log.trace(Geonet.DATA_MANAGER, \"Finishing update of record with id \" + metadataId);\n 780           // Return an up to date metadata record\n 781           return metadataUtils.findOne(metadataId);\n 782       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataValidator.java:\n434       @Override\n435       public Pair<Element, String> doValidate(UserSession session, String schema, String metadataId, Element md, String lang,\n436                                               boolean forEditing) throws Exception {\n437           int intMetadataId = Integer.parseInt(metadataId);\n438           String version = null;\n439           LOGGER.debug(\"Creating validation report for record #{} [schema: {}].\", metadataId, schema);\n440   \n441           Element sessionReport = (Element) session.getProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n442           if (sessionReport != null && !forEditing) {\n443               LOGGER.debug(\"  Validation report available in session.\");\n444               sessionReport.detach();\n445               return Pair.read(sessionReport, version);\n446           }\n447   \n448           List<MetadataValidation> validations = new ArrayList<>();\n449           Element errorReport = new Element(\"report\", Edit.NAMESPACE);\n450           errorReport.setAttribute(\"id\", metadataId, Edit.NAMESPACE);\n451   \n452           // -- get an XSD validation report and add results to the metadata\n453           // -- as geonet:xsderror attributes on the affected elements\n454           Element xsdErrors = getXSDXmlReport(schema, md, forEditing);\n455           int xsdErrorCount = 0;\n456           if (xsdErrors != null) {\n457               xsdErrorCount = xsdErrors.getContent().size();\n458           }\n459           if (xsdErrorCount > 0) {\n460               errorReport.addContent(xsdErrors);\n461               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n462                   .setStatus(MetadataValidationStatus.INVALID).setRequired(true).setNumTests(xsdErrorCount)\n463                   .setNumFailures(xsdErrorCount));\n464               if (LOGGER.isDebugEnabled()) {\n465                   LOGGER.debug(\"  - XSD error: {}\", Xml.getString(xsdErrors));\n466               }\n467           } else {\n468               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n469                   .setStatus(MetadataValidationStatus.VALID).setRequired(true).setNumTests(1).setNumFailures(0));\n470               LOGGER.trace(\"Valid.\");\n471           }\n472   \n473           // ...then schematrons\n474           Element error = null;\n475           if (forEditing) {\n476               LOGGER.debug(\"  - Schematron in editing mode.\");\n477               // -- now expand the elements and add the geonet: elements\n478               metadataManager.getEditLib().expandElements(schema, md);\n479               version = metadataManager.getEditLib().getVersionForEditing(schema, metadataId, md);\n480   \n481               error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n482           } else {\n483               // enumerate the metadata xml so that we can report any problems found by the schematron_xml script to the geonetwork editor\n484               metadataManager.getEditLib().enumerateTree(md);\n485               try {\n486                   error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n487               } catch (Exception e) {\n488                   LOGGER.error(\"Could not run schematron validation on metadata {}.\", metadataId);\n489                   LOGGER.error(\"Could not run schematron validation on metadata, exception.\", e);\n490               } finally {\n491                   // remove editing info added by enumerateTree\n492                   metadataManager.getEditLib().removeEditingInfo(md);\n493               }\n494           }\n495   \n496           if (error != null) {\n497               errorReport.addContent(error);\n498           }\n499   \n500           saveValidationStatus(intMetadataId, validations);\n501   \n502           session.setProperty(Geonet.Session.VALIDATION_REPORT + metadataId, errorReport);\n503   \n504           return Pair.read(errorReport, version);\n505       }\n513       @Override\n514       public Element applyCustomSchematronRules(String schema, int metadataId, Element md, String lang,\n515                                                 List<MetadataValidation> validations) {\n516           return schematronValidator.applyCustomSchematronRules(schema, metadataId, md, lang, validations);\n517       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchematronValidator.java:\n 53       public Element applyCustomSchematronRules(String schema, int metadataId, Element md,\n 54                                                 String lang, List<MetadataValidation> validations) {\n 55           SchemaManager schemaManager = ApplicationContextHolder.get().getBean(SchemaManager.class);\n 56   \n 57           MetadataSchema metadataSchema = schemaManager.getSchema(schema);\n 58           final Path schemaDir = schemaManager.getSchemaDir(schema);\n 59   \n 60           Element schemaTronXmlOut = new Element(\"schematronerrors\", Edit.NAMESPACE);\n 61           try {\n 62               List<ApplicableSchematron> applicableSchematron = getApplicableSchematronList(metadataId, md, metadataSchema);\n 63   \n 64               for (ApplicableSchematron applicable : applicableSchematron) {\n 65                   runSchematron(lang, schemaDir, validations, schemaTronXmlOut, metadataId, md, applicable);\n 66               }\n 67           } catch (Throwable e) {\n 68               Element errorReport = new Element(\"schematronVerificationError\", Edit.NAMESPACE);\n 69               errorReport.addContent(\"Schematron error occurred, rules could not be verified: \" + e.getMessage());\n 70               schemaTronXmlOut.addContent(errorReport);\n 71           }\n 72   \n 73           if (schemaTronXmlOut.getChildren().isEmpty()) {\n 74               schemaTronXmlOut = null;\n 75           }\n 76   \n 77           return schemaTronXmlOut;\n 78       }\n 81       public List<ApplicableSchematron> getApplicableSchematronList(final int metadataId,\n 82                                                              final Element md,\n 83                                                              final MetadataSchema metadataSchema) {\n 84           List<ApplicableSchematron> applicableSchematron = Lists.newArrayList();\n 85           SchematronRepository schematronRepository = ApplicationContextHolder.get().getBean(SchematronRepository.class);\n 86   \n 87           final List<Schematron> schematronList = schematronRepository.findAllBySchemaName(metadataSchema.getName());\n 88   \n 89           Collections.sort(schematronList, Schematron.DISPLAY_PRIORITY_COMPARATOR);\n 90   \n 91           //Loop through all xsl files\n 92           for (Schematron schematron : schematronList) {\n 93               final ApplicableSchematron applicable = getApplicableSchematron(metadataId, md, metadataSchema, schematron);\n 94   \n 95   \n 96               if (applicable.requirement != SchematronRequirement.DISABLED) {\n 97                   if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n 98                       Log.debug(Geonet.DATA_MANAGER, \" - rule:\" + schematron.getRuleName());\n 99                   }\n100   \n101                   applicableSchematron.add(applicable);\n102               }\n103           }\n104           return applicableSchematron;\n105       }\n108       public ApplicableSchematron getApplicableSchematron(final int metadataId,\n109                                                    final Element md,\n110                                                    final MetadataSchema metadataSchema,\n111                                                    final Schematron schematron) {\n112           //it contains absolute path to the xsl file\n113           final ConfigurableApplicationContext applicationContext = ApplicationContextHolder.get();\n114           SchematronCriteriaGroupRepository criteriaGroupRepository = applicationContext.getBean(SchematronCriteriaGroupRepository.class);\n115   \n116           List<SchematronCriteriaGroup> criteriaGroups = criteriaGroupRepository.findAllById_SchematronId(schematron.getId());\n117   \n118           //Loop through all criteria to see if apply schematron\n119           //if any criteria does not apply, do not apply at all (AND)\n120           SchematronRequirement requirement = SchematronRequirement.DISABLED;\n121           for (SchematronCriteriaGroup criteriaGroup : criteriaGroups) {\n122               List<SchematronCriteria> criteriaList = criteriaGroup.getCriteria();\n123               boolean apply = false;\n124               for (SchematronCriteria criteria : criteriaList) {\n125                   apply = criteria.accepts(applicationContext, metadataId, md, metadataSchema.getSchemaNS());\n126                   if (!apply) {\n127                       break;\n128                   }\n129               }\n130   \n131               if (apply) {\n132                   if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n133                       Log.debug(Geonet.DATA_MANAGER, \" - Schematron group is accepted:\" + criteriaGroup.getId().getName() +\n134                           \" for schematron: \" + schematron.getRuleName());\n135                   }\n136                   requirement = requirement.highestRequirement(criteriaGroup.getRequirement());\n137               } else {\n138                   requirement = requirement.highestRequirement(SchematronRequirement.DISABLED);\n139               }\n140           }\n141           return new ApplicableSchematron(requirement, schematron);\n142       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/SchematronCriteria.java:\n169       public boolean accepts(ApplicationContext applicationContext, int metadataId, Element metadata, List<Namespace> metadataNamespaces) {\n170           return getType().accepts(applicationContext, getValue(), metadataId, metadata, metadataNamespaces);\n171       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/SchematronCriteriaType.java:\n155       public boolean accepts(ApplicationContext applicationContext, String value, int metadataId, Element metadata,\n156                              List<Namespace> metadataNamespaces) {\n157           return evaluator.accepts(applicationContext, value, metadataId, metadata, metadataNamespaces);\n158       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java:\n140       @Override\n141       public boolean accepts(ApplicationContext applicationContext, String value, int metadataId, Element metadata, List<Namespace> metadataNamespaces) {\n142           String[] ors = value.split(OR);\n143           boolean orAccepts = false;\n144           for (String or : ors) {\n145               String[] ands = or.split(AND);\n146   \n147               boolean andAccepts = true;\n148               for (String and : ands) {\n149                   andAccepts = doAccept(and, metadata, metadataNamespaces);\n150                   if (!andAccepts) {\n151                       break;\n152                   }\n153               }\n154   \n155               orAccepts = andAccepts;\n156   \n157               if (orAccepts) {\n158                   break;\n159               }\n160           }\n161   \n162           return orAccepts;\n163   \n164       }\n",
            "cost": 0.14827,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java:142:36",
            "status": "corpus",
            "valid_path": "NO",
            "id": 23
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n140       void updateMetadata(Element xml, final String id, GroupMapper localGroups, final CategoryMapper localCateg,\n141           String changeDate, BaseAligner<LocalFilesystemParams> aligner,\n142           boolean force) throws Exception {\n143   \n144           log.debug(\"  - Updating metadata with id: \" + id);\n145   \n146           String language = context.getLanguage();\n147   \n148           final AbstractMetadata metadata = metadataManager.updateMetadata(context, id, xml, false, false, false, language, changeDate,\n149               true);\n150   \n151           if (force) {\n152               //change ownership of metadata to new harvester (Used in OVERRIDE option)\n153               log.debug(String.format(\"  - Changing source of metadata id %s to '%s' harvester\", id, params.getName()));\n154   \n155               metadata.getHarvestInfo().setUuid(params.getUuid());\n156               metadata.getSourceInfo().setSourceId(params.getUuid());\n157               metadataManager.save(metadata);\n158           }\n159   \n160           OperationAllowedRepository repository = context.getBean(OperationAllowedRepository.class);\n161           repository.deleteAllByMetadataId(Integer.parseInt(id));\n162           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n163   \n164           metadata.getCategories().clear();\n165           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, true);\n166   \n167           metadataManager.flush();\n168   \n169           dataMan.indexMetadata(id, true);\n170       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n273       private void updateMetadata(Path file, Path filePath, Element xml, String schema, String id,\n274           AbstractMetadata metadata, boolean force)\n275           throws Exception {\n276           // Check last modified date of the file with the record change date\n277           // to check if an update is required\n278           if (params.checkFileLastModifiedForUpdate) {\n279               Date fileDate = new Date(Files.getLastModifiedTime(file).toMillis());\n280   \n281               ISODate modified = new ISODate();\n282               if (metadata.getDataInfo() != null) {\n283                   modified = metadata.getDataInfo().getChangeDate();\n284               }\n285   \n286               Date recordDate = modified.toDate();\n287   \n288               String changeDate = new ISODate(fileDate.getTime(), false).getDateAndTime();\n289   \n290               LOGGER.debug(\" File date is: {} / record date is: {}\", filePath, modified);\n291   \n292               if (DateUtils.truncate(recordDate, Calendar.SECOND)\n293                   .before(DateUtils.truncate(fileDate, Calendar.SECOND))) {\n294                   LOGGER.debug(\"  Db record is older than file. Updating record with id: {}\", id);\n295                   updateMedata(xml, id, changeDate, force);\n296               } else {\n297                   LOGGER.debug(\"  Db record is not older than last modified date of file. No need for update.\");\n298                   result.unchangedMetadata++;\n299               }\n300           } else {\n301               LOGGER.debug(\"  updating existing metadata, id is: \" + id);\n302   \n303               String changeDate;\n304   \n305               try {\n306                   changeDate = dataMan.extractDateModified(schema, xml);\n307               } catch (Exception ex) {\n308                   LOGGER.error(\"LocalFilesystemHarvester - updateMetadata - can't get metadata modified date for \" +\n309                       \"metadata id= {}, using current date for modified date\", id);\n310                   changeDate = new ISODate().toString();\n311               }\n312   \n313               updateMedata(xml, id, changeDate, force);\n314           }\n315       }\n405       private void updateMedata(Element xml, String id, String changeDate, boolean force) throws Exception {\n406           harvester.updateMetadata(xml, id, localGroups, localCateg, changeDate, aligner, force);\n407           listOfRecordsToIndex.add(Integer.valueOf(id));\n408           result.updatedMetadata++;\n409       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 715       @Override\n 716       public synchronized AbstractMetadata updateMetadata(final ServiceContext context, final String metadataId, final Element md,\n 717                                                           final boolean validate, final boolean ufo, final boolean index, final String lang, final String changeDate,\n 718                                                           final boolean updateDateStamp) throws Exception {\n 719           Log.trace(Geonet.DATA_MANAGER, \"Update record with id \" + metadataId);\n 720   \n 721           Element metadataXml = md;\n 722   \n 723           // when invoked from harvesters, session is null?\n 724           UserSession session = context.getUserSession();\n 725           if (session != null) {\n 726               session.removeProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n 727           }\n 728           String schema = metadataSchemaUtils.getMetadataSchema(metadataId);\n 729           if (ufo) {\n 730               String parentUuid = null;\n 731               Integer intId = Integer.valueOf(metadataId);\n 732   \n 733               final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 734   \n 735               String uuid = findUuid(metadataXml, schema, metadata);\n 736   \n 737               metadataXml = updateFixedInfo(schema, Optional.of(intId), uuid, metadataXml, parentUuid,\n 738                   (updateDateStamp ? UpdateDatestamp.YES : UpdateDatestamp.NO), context);\n 739           }\n 740   \n 741           // --- force namespace prefix for iso19139 metadata\n 742           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 743   \n 744           // Notifies the metadata change to metatada notifier service\n 745           final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 746   \n 747           String uuid = findUuid(metadataXml, schema, metadata);\n 748   \n 749           metadataUtils.checkMetadataWithSameUuidExist(uuid, metadata.getId());\n 750   \n 751           // --- write metadata to dbms\n 752           getXmlSerializer().update(metadataId, metadataXml, changeDate, updateDateStamp, uuid, context);\n 753   \n 754           try {\n 755               // --- do the validation last - it throws exceptions\n 756               if (session != null && validate) {\n 757                   metadataValidator.doValidate(session, schema, metadataId, metadataXml, lang, false);\n 758               }\n 759           } finally {\n 760               if (index) {\n 761                   // --- update search criteria\n 762                   metadataIndexer.indexMetadata(metadataId, true);\n 763               }\n 764           }\n 765   \n 766           if (metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE) {\n 767               if (!index) {\n 768                   metadataIndexer.indexMetadata(metadataId, true);\n 769               }\n 770   //\t\t\tTODOES\n 771   //            MetaSearcher searcher = searcherForReferencingMetadata(context, metadata);\n 772   //            Map<Integer, AbstractMetadata> result = ((LuceneSearcher) searcher).getAllMdInfo(context, 500);\n 773   //            for (Integer id : result.keySet()) {\n 774   //                IndexingList list = context.getBean(IndexingList.class);\n 775   //                list.add(id);\n 776   //            }\n 777           }\n 778   \n 779           Log.trace(Geonet.DATA_MANAGER, \"Finishing update of record with id \" + metadataId);\n 780           // Return an up to date metadata record\n 781           return metadataUtils.findOne(metadataId);\n 782       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataValidator.java:\n434       @Override\n435       public Pair<Element, String> doValidate(UserSession session, String schema, String metadataId, Element md, String lang,\n436                                               boolean forEditing) throws Exception {\n437           int intMetadataId = Integer.parseInt(metadataId);\n438           String version = null;\n439           LOGGER.debug(\"Creating validation report for record #{} [schema: {}].\", metadataId, schema);\n440   \n441           Element sessionReport = (Element) session.getProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n442           if (sessionReport != null && !forEditing) {\n443               LOGGER.debug(\"  Validation report available in session.\");\n444               sessionReport.detach();\n445               return Pair.read(sessionReport, version);\n446           }\n447   \n448           List<MetadataValidation> validations = new ArrayList<>();\n449           Element errorReport = new Element(\"report\", Edit.NAMESPACE);\n450           errorReport.setAttribute(\"id\", metadataId, Edit.NAMESPACE);\n451   \n452           // -- get an XSD validation report and add results to the metadata\n453           // -- as geonet:xsderror attributes on the affected elements\n454           Element xsdErrors = getXSDXmlReport(schema, md, forEditing);\n455           int xsdErrorCount = 0;\n456           if (xsdErrors != null) {\n457               xsdErrorCount = xsdErrors.getContent().size();\n458           }\n459           if (xsdErrorCount > 0) {\n460               errorReport.addContent(xsdErrors);\n461               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n462                   .setStatus(MetadataValidationStatus.INVALID).setRequired(true).setNumTests(xsdErrorCount)\n463                   .setNumFailures(xsdErrorCount));\n464               if (LOGGER.isDebugEnabled()) {\n465                   LOGGER.debug(\"  - XSD error: {}\", Xml.getString(xsdErrors));\n466               }\n467           } else {\n468               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n469                   .setStatus(MetadataValidationStatus.VALID).setRequired(true).setNumTests(1).setNumFailures(0));\n470               LOGGER.trace(\"Valid.\");\n471           }\n472   \n473           // ...then schematrons\n474           Element error = null;\n475           if (forEditing) {\n476               LOGGER.debug(\"  - Schematron in editing mode.\");\n477               // -- now expand the elements and add the geonet: elements\n478               metadataManager.getEditLib().expandElements(schema, md);\n479               version = metadataManager.getEditLib().getVersionForEditing(schema, metadataId, md);\n480   \n481               error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n482           } else {\n483               // enumerate the metadata xml so that we can report any problems found by the schematron_xml script to the geonetwork editor\n484               metadataManager.getEditLib().enumerateTree(md);\n485               try {\n486                   error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n487               } catch (Exception e) {\n488                   LOGGER.error(\"Could not run schematron validation on metadata {}.\", metadataId);\n489                   LOGGER.error(\"Could not run schematron validation on metadata, exception.\", e);\n490               } finally {\n491                   // remove editing info added by enumerateTree\n492                   metadataManager.getEditLib().removeEditingInfo(md);\n493               }\n494           }\n495   \n496           if (error != null) {\n497               errorReport.addContent(error);\n498           }\n499   \n500           saveValidationStatus(intMetadataId, validations);\n501   \n502           session.setProperty(Geonet.Session.VALIDATION_REPORT + metadataId, errorReport);\n503   \n504           return Pair.read(errorReport, version);\n505       }\n513       @Override\n514       public Element applyCustomSchematronRules(String schema, int metadataId, Element md, String lang,\n515                                                 List<MetadataValidation> validations) {\n516           return schematronValidator.applyCustomSchematronRules(schema, metadataId, md, lang, validations);\n517       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/SchematronValidator.java:\n 53       public Element applyCustomSchematronRules(String schema, int metadataId, Element md,\n 54                                                 String lang, List<MetadataValidation> validations) {\n 55           SchemaManager schemaManager = ApplicationContextHolder.get().getBean(SchemaManager.class);\n 56   \n 57           MetadataSchema metadataSchema = schemaManager.getSchema(schema);\n 58           final Path schemaDir = schemaManager.getSchemaDir(schema);\n 59   \n 60           Element schemaTronXmlOut = new Element(\"schematronerrors\", Edit.NAMESPACE);\n 61           try {\n 62               List<ApplicableSchematron> applicableSchematron = getApplicableSchematronList(metadataId, md, metadataSchema);\n 63   \n 64               for (ApplicableSchematron applicable : applicableSchematron) {\n 65                   runSchematron(lang, schemaDir, validations, schemaTronXmlOut, metadataId, md, applicable);\n 66               }\n 67           } catch (Throwable e) {\n 68               Element errorReport = new Element(\"schematronVerificationError\", Edit.NAMESPACE);\n 69               errorReport.addContent(\"Schematron error occurred, rules could not be verified: \" + e.getMessage());\n 70               schemaTronXmlOut.addContent(errorReport);\n 71           }\n 72   \n 73           if (schemaTronXmlOut.getChildren().isEmpty()) {\n 74               schemaTronXmlOut = null;\n 75           }\n 76   \n 77           return schemaTronXmlOut;\n 78       }\n 81       public List<ApplicableSchematron> getApplicableSchematronList(final int metadataId,\n 82                                                              final Element md,\n 83                                                              final MetadataSchema metadataSchema) {\n 84           List<ApplicableSchematron> applicableSchematron = Lists.newArrayList();\n 85           SchematronRepository schematronRepository = ApplicationContextHolder.get().getBean(SchematronRepository.class);\n 86   \n 87           final List<Schematron> schematronList = schematronRepository.findAllBySchemaName(metadataSchema.getName());\n 88   \n 89           Collections.sort(schematronList, Schematron.DISPLAY_PRIORITY_COMPARATOR);\n 90   \n 91           //Loop through all xsl files\n 92           for (Schematron schematron : schematronList) {\n 93               final ApplicableSchematron applicable = getApplicableSchematron(metadataId, md, metadataSchema, schematron);\n 94   \n 95   \n 96               if (applicable.requirement != SchematronRequirement.DISABLED) {\n 97                   if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n 98                       Log.debug(Geonet.DATA_MANAGER, \" - rule:\" + schematron.getRuleName());\n 99                   }\n100   \n101                   applicableSchematron.add(applicable);\n102               }\n103           }\n104           return applicableSchematron;\n105       }\n108       public ApplicableSchematron getApplicableSchematron(final int metadataId,\n109                                                    final Element md,\n110                                                    final MetadataSchema metadataSchema,\n111                                                    final Schematron schematron) {\n112           //it contains absolute path to the xsl file\n113           final ConfigurableApplicationContext applicationContext = ApplicationContextHolder.get();\n114           SchematronCriteriaGroupRepository criteriaGroupRepository = applicationContext.getBean(SchematronCriteriaGroupRepository.class);\n115   \n116           List<SchematronCriteriaGroup> criteriaGroups = criteriaGroupRepository.findAllById_SchematronId(schematron.getId());\n117   \n118           //Loop through all criteria to see if apply schematron\n119           //if any criteria does not apply, do not apply at all (AND)\n120           SchematronRequirement requirement = SchematronRequirement.DISABLED;\n121           for (SchematronCriteriaGroup criteriaGroup : criteriaGroups) {\n122               List<SchematronCriteria> criteriaList = criteriaGroup.getCriteria();\n123               boolean apply = false;\n124               for (SchematronCriteria criteria : criteriaList) {\n125                   apply = criteria.accepts(applicationContext, metadataId, md, metadataSchema.getSchemaNS());\n126                   if (!apply) {\n127                       break;\n128                   }\n129               }\n130   \n131               if (apply) {\n132                   if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n133                       Log.debug(Geonet.DATA_MANAGER, \" - Schematron group is accepted:\" + criteriaGroup.getId().getName() +\n134                           \" for schematron: \" + schematron.getRuleName());\n135                   }\n136                   requirement = requirement.highestRequirement(criteriaGroup.getRequirement());\n137               } else {\n138                   requirement = requirement.highestRequirement(SchematronRequirement.DISABLED);\n139               }\n140           }\n141           return new ApplicableSchematron(requirement, schematron);\n142       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/SchematronCriteria.java:\n169       public boolean accepts(ApplicationContext applicationContext, int metadataId, Element metadata, List<Namespace> metadataNamespaces) {\n170           return getType().accepts(applicationContext, getValue(), metadataId, metadata, metadataNamespaces);\n171       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/SchematronCriteriaType.java:\n155       public boolean accepts(ApplicationContext applicationContext, String value, int metadataId, Element metadata,\n156                              List<Namespace> metadataNamespaces) {\n157           return evaluator.accepts(applicationContext, value, metadataId, metadata, metadataNamespaces);\n158       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java:\n140       @Override\n141       public boolean accepts(ApplicationContext applicationContext, String value, int metadataId, Element metadata, List<Namespace> metadataNamespaces) {\n142           String[] ors = value.split(OR);\n143           boolean orAccepts = false;\n144           for (String or : ors) {\n145               String[] ands = or.split(AND);\n146   \n147               boolean andAccepts = true;\n148               for (String and : ands) {\n149                   andAccepts = doAccept(and, metadata, metadataNamespaces);\n150                   if (!andAccepts) {\n151                       break;\n152                   }\n153               }\n154   \n155               orAccepts = andAccepts;\n156   \n157               if (orAccepts) {\n158                   break;\n159               }\n160           }\n161   \n162           return orAccepts;\n163   \n164       }\n",
            "cost": 0.14367000000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/XPathCriteriaEvaluator.java:145:38",
            "status": "corpus",
            "valid_path": "NO",
            "id": 24
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java:\n146       private List<String> toList(String schemasToLoad) {\n147           List<String> schemasToLoadList = Arrays.asList(schemasToLoad.split(\",\"));\n148           List<String> tmp = new ArrayList<String>(schemasToLoadList.size());\n149           for (String string : schemasToLoadList) {\n150               tmp.add(string.trim().toLowerCase());\n151           }\n152   \n153           schemasToLoadList = tmp;\n154           return schemasToLoadList;\n155       }\n167       @Nonnull\n168       public List<String> listOfSchemasToLoad() {\n169           return toList(schemasToLoad());\n170       }\n",
            "cost": 0.142005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java:147:76",
            "status": "corpus",
            "valid_path": "NO",
            "id": 25
        },
        {
            "blob": [
                "PHJvb3Q+PGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3BhcmFtPSYmJiYiLz48L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:\n139       public static Element detachXLink(Element xml, ServiceContext context) {\n140           searchXLink(xml, ACTION_DETACH, context);\n141           searchLocalXLink(xml, ACTION_DETACH);\n142           return xml;\n143       }\n259       public static String mapURI(String uri) {\n260           uri = uri.replaceAll(\"&+\", \"&\").toLowerCase();\n261           for (URIMapper mapper : uriMapper) {\n262               uri = mapper.map(uri);\n263           }\n264           return uri;\n265       }\n273       public static void uncacheXLinkUri(String uri) throws CacheException {\n274           JeevesJCS xlinkCache = JeevesJCS.getInstance(XLINK_JCS);\n275           String mappedURI = mapURI(uri);\n276           Set groupKeys = xlinkCache.getGroupKeys(mappedURI);\n277           if (groupKeys == null || groupKeys.isEmpty()) {\n278               xlinkCache.remove(uri);\n279           } else {\n280               for (Object key : groupKeys) {\n281                   xlinkCache.remove(key, mappedURI);\n282               }\n283           }\n284       }\n317       private static Set<String> searchXLink(Element md, String action, ServiceContext srvContext) {\n318           List<Attribute> xlinks = getXLinksWithXPath(md, \"*//@xlink:href\");\n319   \n320           if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n321               Log.debug(Log.XLINK_PROCESSOR, \"returned \" + xlinks.size() + \" elements\");\n322   \n323           Set<String> errors = Sets.newHashSet();\n324           // process remote xlinks, skip local xlinks for later\n325           for (Attribute xlink : xlinks) {\n326               String hrefUri = xlink.getValue();\n327               if (Log.isDebugEnabled(Log.XLINK_PROCESSOR))\n328                   Log.debug(Log.XLINK_PROCESSOR, \"will resolve href '\" + hrefUri + \"'\");\n329               String idSearch = null;\n330   \n331               String error = doXLink(hrefUri, idSearch, xlink, action, srvContext);\n332               if (error != null) {\n333                   errors.add(error);\n334               }\n335   \n336           }\n337   \n338           return errors;\n339       }\n414       private static String doXLink(String hrefUri, String idSearch, Attribute xlink, String action, ServiceContext srvContext) {\n415           Element element = xlink.getParent();\n416   \n417           // Don't process XLink for configured elements\n418           List<String> excludedXlinkElements = new ArrayList<String>();\n419           SettingManager sm = ApplicationContextHolder.get().getBean(SettingManager.class);\n420           String xlinkElementNamesToIgnore = sm.getValue(Settings.SYSTEM_XLINK_RESOLVER_IGNORE);\n421           if (StringUtils.isNotEmpty(xlinkElementNamesToIgnore)) {\n422               for (String el : xlinkElementNamesToIgnore.split(\",\")) {\n423                   excludedXlinkElements.add(el.trim());\n424               }\n425           }\n426   \n427           if (excludedXlinkElements.contains(element.getName())) {\n428               return null;\n429           }\n430   \n431           if (!hrefUri.equals(\"\")) {\n432               String show = element.getAttributeValue(XLink.SHOW, XLink.NAMESPACE_XLINK);\n433               if (show == null || show.equals(\"\")) show = XLink.SHOW_EMBED;\n434               if (show.equalsIgnoreCase(XLink.SHOW_EMBED) || show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n435                   if (action.equals(ACTION_REMOVE)) {\n436                       element.removeContent();\n437                   } else if (action.equals(ACTION_UNCACHE)) {\n438                       try {\n439                           uncacheXLinkUri(hrefUri);\n440                       } catch (Exception e) {\n441                           Log.error(Log.XLINK_PROCESSOR, \"Uncaching failed: \" + e.getMessage(), e);\n442                       }\n443                   } else {\n444                       try {\n445                           Element remoteFragment = resolveXLink(hrefUri, idSearch, srvContext);\n446   \n447                           // Not resolved in cache or using href\n448                           if (remoteFragment == null)\n449                               return hrefUri;\n450   \n451                           searchXLink(remoteFragment, action, srvContext);\n452   \n453                           if (show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n454                               // replace this element with the fragment\n455                               if (!action.equals(ACTION_DETACH) && show.equalsIgnoreCase(XLink.SHOW_REPLACE)) {\n456                                   remoteFragment.setAttribute((Attribute) xlink.clone());\n457                                   remoteFragment.setAttribute(new Attribute(XLink.SHOW, XLink.SHOW_REPLACE, XLink.NAMESPACE_XLINK));\n458                               }\n459                               Element parent = element.getParentElement();\n460                               int index = parent.indexOf(element);\n461                               parent.setContent(index, remoteFragment);\n462                           } else { // show = XLink.SHOW_EMBED\n463                               // replace children of this element with the fragment\n464                               element.removeContent();\n465                               element.addContent(remoteFragment);\n466                           }\n467                       } catch (Exception e) {\n468                           Log.error(Log.XLINK_PROCESSOR, \"doXLink \" + action + \" failed: \" + e.getMessage(), e);\n469                       }\n470                   }\n471                   cleanXLinkAttributes(element, action);\n472               } else {\n473                   Log.error(Log.XLINK_PROCESSOR, \"Invalid xlink:show attribute '\" + show + \"'\");\n474               }\n475           }\n476   \n477           return null;\n478       }\n",
            "cost": 3.2505999999999995,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/jeeves/xlink/Processor.java:260:30",
            "status": "corpus",
            "valid_path": "YES",
            "id": 26
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n233       private void runBeforeScript() throws IOException, InterruptedException {\n234   \t\tif (StringUtils.isEmpty(params.beforeScript)) {\n235   \t\t\treturn;\n236   \t\t}\n237   \t\tlog.info(\"Running the before script: \" + params.beforeScript);\n238           List<String> args = new ArrayList<String>(Arrays.asList(params.beforeScript.split(\" \")));\n239           Process process = new ProcessBuilder(args).\n240   \t\t\t\tredirectError(ProcessBuilder.Redirect.INHERIT).\n241   \t\t\t\tredirectOutput(ProcessBuilder.Redirect.INHERIT).\n242   \t\t\t\tstart();\n243   \t\tint result = process.waitFor();\n244   \t\tif ( result != 0 ) {\n245   \t\t\tlog.warning(\"The beforeScript failed with exit value=\" + Integer.toString(result));\n246   \t\t\tthrow new RuntimeException(\"The beforeScript returned an error: \" + Integer.toString(result));\n247   \t\t}\n248   \t}\n",
            "cost": 0.038290000000000005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:238:91",
            "status": "corpus",
            "valid_path": "NO",
            "id": 27
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataIndexer.java:\n322       @Override\n323       public void indexMetadata(final String metadataId, final boolean forceRefreshReaders)\n324           throws Exception {\n325           AbstractMetadata fullMd;\n326   \n327           try {\n328               Multimap<String, Object> fields = ArrayListMultimap.create();\n329               int id$ = Integer.parseInt(metadataId);\n330   \n331               // get metadata, extracting and indexing any xlinks\n332               Element md = getXmlSerializer().selectNoXLinkResolver(metadataId, true, false);\n333               final ServiceContext serviceContext = getServiceContext();\n334               if (getXmlSerializer().resolveXLinks()) {\n335                   List<Attribute> xlinks = Processor.getXLinks(md);\n336                   if (xlinks.size() > 0) {\n337                       fields.put(Geonet.IndexFieldNames.HASXLINKS, true);\n338                       StringBuilder sb = new StringBuilder();\n339                       for (Attribute xlink : xlinks) {\n340                           fields.put(Geonet.IndexFieldNames.XLINK, xlink.getValue());\n341                       }\n342                       Processor.detachXLink(md, getServiceContext());\n343                   } else {\n344                       fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n345                   }\n346               } else {\n347                   fields.put(Geonet.IndexFieldNames.HASXLINKS, false);\n348               }\n349   \n350               fullMd = metadataUtils.findOne(id$);\n351   \n352               final String schema = fullMd.getDataInfo().getSchemaId();\n353               final String createDate = fullMd.getDataInfo().getCreateDate().getDateAndTime();\n354               final String changeDate = fullMd.getDataInfo().getChangeDate().getDateAndTime();\n355               final String source = fullMd.getSourceInfo().getSourceId();\n356               final MetadataType metadataType = fullMd.getDataInfo().getType();\n357               final String root = fullMd.getDataInfo().getRoot();\n358               final String uuid = fullMd.getUuid();\n359               String indexKey = uuid;\n360               if (fullMd instanceof MetadataDraft) {\n361                   indexKey += \"-draft\";\n362               }\n363   \n364               final String extra = fullMd.getDataInfo().getExtra();\n365               final boolean isHarvested = fullMd.getHarvestInfo().isHarvested();\n366               final String owner = String.valueOf(fullMd.getSourceInfo().getOwner());\n367               final Integer groupOwner = fullMd.getSourceInfo().getGroupOwner();\n368               final String popularity = String.valueOf(fullMd.getDataInfo().getPopularity());\n369               final String rating = String.valueOf(fullMd.getDataInfo().getRating());\n370               final String displayOrder = fullMd.getDataInfo().getDisplayOrder() == null ? null\n371                   : String.valueOf(fullMd.getDataInfo().getDisplayOrder());\n372   \n373               if (Log.isDebugEnabled(Geonet.DATA_MANAGER)) {\n374                   Log.debug(Geonet.DATA_MANAGER, \"record schema (\" + schema + \")\"); // DEBUG\n375                   Log.debug(Geonet.DATA_MANAGER, \"record createDate (\" + createDate + \")\"); // DEBUG\n376               }\n377   \n378               fields.put(Geonet.IndexFieldNames.ROOT, root);\n379               fields.put(Geonet.IndexFieldNames.SCHEMA, schema);\n380               fields.put(Geonet.IndexFieldNames.RECORDLINKFLAG, \"record\");\n381               fields.put(Geonet.IndexFieldNames.DATABASE_CREATE_DATE, createDate);\n382               fields.put(Geonet.IndexFieldNames.DATABASE_CHANGE_DATE, changeDate);\n383               fields.put(Geonet.IndexFieldNames.SOURCE, source);\n384               fields.put(Geonet.IndexFieldNames.IS_TEMPLATE, metadataType.codeString);\n385               fields.put(Geonet.IndexFieldNames.UUID, uuid);\n386               fields.put(Geonet.IndexFieldNames.ID, metadataId);\n387               fields.put(Geonet.IndexFieldNames.FEATUREOFRECORD, \"record\");\n388               fields.put(Geonet.IndexFieldNames.IS_HARVESTED, isHarvested);\n389               if (isHarvested) {\n390                   fields.put(Geonet.IndexFieldNames.HARVESTUUID, fullMd.getHarvestInfo().getUuid());\n391               }\n392               fields.put(Geonet.IndexFieldNames.OWNER, owner);\n393   \n394   \n395               if (!schemaManager.existsSchema(schema)) {\n396                   fields.put(IndexFields.DRAFT, \"n\");\n397                   fields.put(IndexFields.INDEXING_ERROR_FIELD, true);\n398                   fields.put(IndexFields.INDEXING_ERROR_MSG, String.format(\n399                       \"Schema '%s' is not registerd in this catalog. Install it or remove those records\",\n400                       schema\n401                   ));\n402                   searchManager.index(null, md, indexKey, fields, metadataType, root, forceRefreshReaders);\n403                   Log.error(Geonet.DATA_MANAGER, String.format(\n404                       \"Record %s / Schema '%s' is not registerd in this catalog. Install it or remove those records. Record is indexed indexing error flag.\",\n405                       metadataId, schema));\n406               } else {\n407   \n408                   fields.put(Geonet.IndexFieldNames.POPULARITY, popularity);\n409                   fields.put(Geonet.IndexFieldNames.RATING, rating);\n410   \n411                   if (RatingsSetting.ADVANCED.equals(settingManager.getValue(Settings.SYSTEM_LOCALRATING_ENABLE))) {\n412                       int nbOfFeedback = userFeedbackRepository.findByMetadata_Uuid(uuid).size();\n413                       fields.put(Geonet.IndexFieldNames.FEEDBACKCOUNT, nbOfFeedback);\n414                   }\n415   \n416                   fields.put(Geonet.IndexFieldNames.DISPLAY_ORDER, displayOrder);\n417                   fields.put(Geonet.IndexFieldNames.EXTRA, extra);\n418   \n419                   // If the metadata has an atom document, index related information\n420                   InspireAtomFeed feed = inspireAtomFeedRepository.findByMetadataId(id$);\n421   \n422                   if ((feed != null) && StringUtils.isNotEmpty(feed.getAtom())) {\n423                       fields.put(\"has_atom\", \"y\");\n424                       fields.put(\"any\", feed.getAtom());\n425                   }\n426   \n427                   if (owner != null) {\n428                       Optional<User> userOpt = userRepository.findById(fullMd.getSourceInfo().getOwner());\n429                       if (userOpt.isPresent()) {\n430                           User user = userOpt.get();\n431                           fields.put(Geonet.IndexFieldNames.USERINFO, user.getUsername() + \"|\" + user.getSurname() + \"|\" + user\n432                               .getName() + \"|\" + user.getProfile());\n433                           fields.put(Geonet.IndexFieldNames.OWNERNAME, user.getName() + \" \" + user.getSurname());\n434                       }\n435                   }\n436   \n437                   String logoUUID = null;\n438                   if (groupOwner != null) {\n439                       final Optional<Group> groupOpt = groupRepository.findById(groupOwner);\n440                       if (groupOpt.isPresent()) {\n441                           Group group = groupOpt.get();\n442                           fields.put(Geonet.IndexFieldNames.GROUP_OWNER, String.valueOf(groupOwner));\n443                           final boolean preferGroup = settingManager.getValueAsBool(Settings.SYSTEM_PREFER_GROUP_LOGO, true);\n444                           if (group.getWebsite() != null && !group.getWebsite().isEmpty() && preferGroup) {\n445                               fields.put(Geonet.IndexFieldNames.GROUP_WEBSITE, group.getWebsite());\n446                           }\n447                           if (group.getLogo() != null && preferGroup) {\n448                               logoUUID = group.getLogo();\n449                           }\n450                       }\n451                   }\n452   \n453                   // Group logo are in the harvester folder and contains extension in file name\n454                   boolean added = false;\n455                   if (StringUtils.isNotEmpty(logoUUID)) {\n456                       final Path harvesterLogosDir = resources.locateHarvesterLogosDir(getServiceContext());\n457                       try (Resources.ResourceHolder logo = resources.getImage(getServiceContext(), logoUUID, harvesterLogosDir)) {\n458                           if (logo != null) {\n459                               added = true;\n460                               fields.put(Geonet.IndexFieldNames.LOGO,\n461                                   \"/images/harvesting/\" + logo.getPath().getFileName());\n462                           }\n463                       }\n464                   }\n465   \n466                   // If not available, use the local catalog logo\n467                   if (!added) {\n468                       logoUUID = source + \".png\";\n469                       final Path logosDir = resources.locateLogosDir(getServiceContext());\n470                       try (Resources.ResourceHolder image = resources.getImage(getServiceContext(), logoUUID, logosDir)) {\n471                           if (image != null) {\n472                               fields.put(Geonet.IndexFieldNames.LOGO,\n473                                   \"/images/logos/\" + logoUUID);\n474                           }\n475                       }\n476                   }\n477   \n478                   fields.putAll(buildFieldsForPrivileges(id$));\n479   \n480                   for (MetadataCategory category : fullMd.getCategories()) {\n481                       fields.put(Geonet.IndexFieldNames.CAT, category.getName());\n482                   }\n483   \n484                   // get status\n485                   Sort statusSort = Sort.by(Sort.Direction.DESC,\n486                       MetadataStatus_.changeDate.getName());\n487                   List<MetadataStatus> statuses = statusRepository.findAllByMetadataIdAndByType(id$, StatusValueType.workflow, statusSort);\n488                   if (!statuses.isEmpty()) {\n489                       MetadataStatus stat = statuses.get(0);\n490                       String status = String.valueOf(stat.getStatusValue().getId());\n491                       fields.put(Geonet.IndexFieldNames.STATUS, status);\n492                       String statusChangeDate = stat.getChangeDate().getDateAndTime();\n493                       fields.put(Geonet.IndexFieldNames.STATUS_CHANGE_DATE, statusChangeDate);\n494                   }\n495   \n496                   // getValidationInfo\n497                   // -1 : not evaluated\n498                   // 0 : invalid\n499                   // 1 : valid\n500                   List<MetadataValidation> validationInfo = metadataValidationRepository.findAllById_MetadataId(id$);\n501                   if (validationInfo.isEmpty()) {\n502                       fields.put(Geonet.IndexFieldNames.VALID, \"-1\");\n503                   } else {\n504                       String isValid = \"1\";\n505                       boolean hasInspireValidation = false;\n506                       for (MetadataValidation vi : validationInfo) {\n507                           String type = vi.getId().getValidationType();\n508                           MetadataValidationStatus status = vi.getStatus();\n509   \n510                           // TODO: Check if ignore INSPIRE validation?\n511                           if (!type.equalsIgnoreCase(\"inspire\")) {\n512                               if (status == MetadataValidationStatus.INVALID && vi.isRequired()) {\n513                                   isValid = \"0\";\n514                               }\n515                           } else {\n516                               hasInspireValidation = true;\n517                               fields.put(Geonet.IndexFieldNames.INSPIRE_REPORT_URL, vi.getReportUrl());\n518                               fields.put(Geonet.IndexFieldNames.INSPIRE_VALIDATION_DATE, vi.getValidationDate().getDateAndTime());\n519                           }\n520                           fields.put(Geonet.IndexFieldNames.VALID + \"_\" + type, status.getCode());\n521                       }\n522                       fields.put(Geonet.IndexFieldNames.VALID, isValid);\n523   \n524                       if (!hasInspireValidation) {\n525                           fields.put(Geonet.IndexFieldNames.VALID_INSPIRE, \"-1\");\n526                       }\n527                   }\n528   \n529                   fields.putAll(addExtraFields(fullMd));\n530   \n531                   searchManager.index(schemaManager.getSchemaDir(schema), md, indexKey, fields, metadataType, root, forceRefreshReaders);\n532               }\n533           } catch (Exception x) {\n534               Log.error(Geonet.DATA_MANAGER, \"The metadata document index with id=\" + metadataId\n535                   + \" is corrupt/invalid - ignoring it. Error: \" + x.getMessage(), x);\n536               fullMd = null;\n537           }\n538           if (fullMd != null) {\n539               this.publisher.publishEvent(new MetadataIndexCompleted(fullMd));\n540           }\n541       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/XmlSerializerDb.java:\n55       public Element selectNoXLinkResolver(String id, boolean isIndexingTask, boolean applyOperationsFilters) throws Exception {\n56           return internalSelect(id, isIndexingTask, applyOperationsFilters);\n57       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/XmlSerializer.java:\n161       protected Element internalSelect(String id, boolean isIndexingTask, boolean applyOperationsFilters) throws Exception {\n162           IMetadataUtils _metadataUtils = ApplicationContextHolder.get().getBean(IMetadataUtils.class);\n163   \n164           AbstractMetadata metadata = _metadataUtils.findOne(Integer.parseInt(id));\n165   \n166           if (metadata == null)\n167               return null;\n168   \n169           return removeHiddenElements(isIndexingTask, metadata, applyOperationsFilters);\n170       }\n172       public Element removeHiddenElements(boolean isIndexingTask, AbstractMetadata metadata, boolean applyOperationsFilters) throws Exception {\n173           AccessManager accessManager = ApplicationContextHolder.get().getBean(AccessManager.class);\n174           DataManager _dataManager = ApplicationContextHolder.get().getBean(DataManager.class);\n175   \n176           String id = String.valueOf(metadata.getId());\n177           Element metadataXml = metadata.getXmlData(false);\n178           if (!isIndexingTask && applyOperationsFilters) {\n179               ServiceContext context = ServiceContext.get();\n180               MetadataSchema mds = _dataManager.getSchema(metadata.getDataInfo().getSchemaId());\n181   \n182               // Check if a filter is defined for this schema\n183               // for the editing operation ie. user who can not edit\n184               // will not see those elements.\n185               Pair<String, Element> editXpathFilter = mds.getOperationFilter(ReservedOperation.editing);\n186               boolean filterEditOperationElements = editXpathFilter != null;\n187               List<Namespace> namespaces = mds.getNamespaces();\n188               if (context != null) {\n189                   if (editXpathFilter != null) {\n190                       boolean canEdit = accessManager.canEdit(context, id);\n191                       if (canEdit) {\n192                           filterEditOperationElements = false;\n193                       }\n194                   }\n195                   Pair<String, Element> downloadXpathFilter = mds.getOperationFilter(ReservedOperation.download);\n196                   if (downloadXpathFilter != null) {\n197                       boolean canDownload = accessManager.canDownload(context, id);\n198                       if (!canDownload) {\n199                           removeFilteredElement(metadataXml, downloadXpathFilter, namespaces);\n200                       }\n201                   }\n202                   Pair<String, Element> dynamicXpathFilter = mds.getOperationFilter(ReservedOperation.dynamic);\n203                   if (dynamicXpathFilter != null) {\n204                       boolean canDynamic = accessManager.canDynamic(context, id);\n205                       if (!canDynamic) {\n206                           removeFilteredElement(metadataXml, dynamicXpathFilter, namespaces);\n207                       }\n208                   }\n209               }\n210               if (filterEditOperationElements || (getThreadLocal(false) != null && getThreadLocal(false).forceFilterEditOperation)) {\n211                   removeFilteredElement(metadataXml, editXpathFilter, namespaces);\n212               }\n213           }\n214           return metadataXml;\n215       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/AccessManager.java:\n103       public Set<Operation> getOperations(ServiceContext context, String mdId, String ip) throws Exception {\n104           return getOperations(context, mdId, ip, null);\n105       }\n110       public Set<Operation> getOperations(ServiceContext context, String mdId, String ip, Collection<Operation> operations) throws Exception {\n111           Set<Operation> results;\n112           // if user is an administrator OR is the owner of the record then allow all operations\n113           if (isOwner(context, mdId)) {\n114               results = new HashSet<>(operationRepository.findAll());\n115           } else {\n116               if (operations == null) {\n117                   results = new HashSet<>(getAllOperations(context, mdId, ip));\n118               } else {\n119                   results = new HashSet<>(operations);\n120               }\n121   \n122               UserSession us = context.getUserSession();\n123               if ((us != null) && us.isAuthenticated() && us.getProfile() == Profile.Editor && us.getProfile() == Profile.Reviewer) {\n124                   results.add(operationRepository.findReservedOperation(ReservedOperation.view));\n125               }\n126           }\n127   \n128           return results;\n129       }\n144       public Set<Operation> getAllOperations(ServiceContext context, String mdId, String ip) throws Exception {\n145           HashSet<Operation> operations = new HashSet<Operation>();\n146           Set<Integer> groups = getUserGroups(context.getUserSession(),\n147               ip, false);\n148           for (OperationAllowed opAllow : operationAllowedRepository.findByMetadataId(mdId)) {\n149               if (groups.contains(opAllow.getId().getGroupId())) {\n150                   operations.add(operationRepository.findById(opAllow.getId().getOperationId()).get());\n151               }\n152           }\n153           return operations;\n154       }\n161       public Set<Integer> getUserGroups(UserSession usrSess, String ip, boolean editingGroupsOnly) throws Exception {\n162           final ConfigurableApplicationContext applicationContext = ApplicationContextHolder.get();\n163   \n164           Set<Integer> hs = new HashSet<Integer>();\n165   \n166           // add All (1) network group\n167           hs.add(ReservedGroup.all.getId());\n168   \n169           if (ip != null && isIntranet(ip))\n170               hs.add(ReservedGroup.intranet.getId());\n171   \n172           // get other groups\n173           if ((usrSess != null) && usrSess.isAuthenticated()) {\n174               // add (-1) GUEST group\n175               hs.add(ReservedGroup.guest.getId());\n176   \n177               if (Profile.Administrator == usrSess.getProfile()) {\n178                   List<Integer> allGroupIds = groupRepository.findIds();\n179   \n180                   hs.addAll(allGroupIds);\n181               } else {\n182                   Specification<UserGroup> spec = UserGroupSpecs.hasUserId(usrSess.getUserIdAsInt());\n183                   if (editingGroupsOnly) {\n184                       spec = Specification.where(spec).and(UserGroupSpecs.hasProfile(Profile.Editor));\n185                   }\n186   \n187                   hs.addAll(userGroupRepository.findGroupIds(spec));\n188               }\n189           }\n190           return hs;\n191       }\n415       public boolean canDownload(final ServiceContext context, final String id) throws Exception {\n416           if (isOwner(context, id)) {\n417               return true;\n418           }\n419           int downloadId = ReservedOperation.download.getId();\n420           Set<Operation> ops = getOperations(context, id, context.getIpAddress());\n421           for (Operation op : ops) {\n422               if (op.getId() == downloadId) {\n423                   return true;\n424               }\n425           }\n426           return false;\n427       }\n578       public boolean isIntranet(String ip) {\n579           //--- consider IPv4 & IPv6 loopback\n580           //--- we use 'startsWith' because some addresses can be 0:0:0:0:0:0:0:1%0\n581   \n582           if (ip.startsWith(\"0:0:0:0:0:0:0:1\") || ip.equals(\"127.0.0.1\")) return true;\n583   \n584           // IPv6 link-local\n585           String ipv6LinkLocalPrefix = \"fe80:\";\n586           if (ip.toLowerCase().startsWith(ipv6LinkLocalPrefix)) {\n587               return true;\n588           }\n589           // other IPv6\n590           else if (ip.indexOf(':') >= 0) {\n591               return false;\n592           }\n593   \n594           // IPv4\n595           Optional<Setting> network = settingRepository.findById(Settings.SYSTEM_INTRANET_NETWORK);\n596           Optional<Setting> netmask = settingRepository.findById(Settings.SYSTEM_INTRANET_NETMASK);\n597   \n598           try {\n599               if (network.isPresent() && netmask.isPresent() &&\n600                   StringUtils.isNotEmpty(network.get().getValue()) && StringUtils.isNotEmpty(netmask.get().getValue())) {\n601                   long lIntranetNet = getAddress(network.get().getValue());\n602                   long lIntranetMask = getAddress(netmask.get().getValue());\n603                   long lAddress = getAddress(ip.split(\",\")[0]);\n604                   return (lAddress & lIntranetMask) == (lIntranetNet & lIntranetMask);\n605               }\n606           } catch (Exception nfe) {\n607               Log.error(Geonet.ACCESS_MANAGER,\"isIntranet error: \" + nfe.getMessage(), nfe);\n608           }\n609           return false;\n610       }\n",
            "cost": 0.163205,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/AccessManager.java:603:53",
            "status": "corpus",
            "valid_path": "NO",
            "id": 28
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8bWV0YWRhdGEgc2NoZW1hPSJ1bmF1dGhvcml6ZWQqc2NoZW1hIj4KICAgICAgICA8dXVpZD4xMjM0LTU2NzgtOTBhYi1jZGVmPC91dWlkPgogICAgICAgIDxlbGVtZW50PlRlc3Q8L2VsZW1lbnQ+CiAgICAgICAgPGFkZGl0aW9uYWxFbGVtZW50PlRyaWdnZXI8L2FkZGl0aW9uYWxFbGVtZW50PgogICAgPC9tZXRhZGF0YT4KICAgIDxhZGRpdGlvbmFsUm9vdEVsZW1lbnQ+CiAgICAgICAgPHN1YkVsZW1lbnQ+RW5zdXJlUGF0aDwvc3ViRWxlbWVudD4KICAgIDwvYWRkaXRpb25hbFJvb3RFbGVtZW50Pgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n",
            "cost": 0.638335,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:571:101",
            "status": "corpus",
            "valid_path": "YES",
            "id": 29
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.188105,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:500:90",
            "status": "corpus",
            "valid_path": "NO",
            "id": 30
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxyb290PgogICAgICAgIDxtZXRhZGF0YT4KICAgICAgICAgICAgPHJlc291cmNlSWQ+KjwvcmVzb3VyY2VJZD4KICAgICAgICA8L21ldGFkYXRhPgogICAgPC9yb290Pg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 1.224565,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:504:90",
            "status": "corpus",
            "valid_path": "YES",
            "id": 31
        },
        {
            "blob": [
                "CiAgICA8cm9vdD4KICAgICAgICA8Z2VuZXJhbD4KICAgICAgICAgICAgPHV1aWQ+dGVzdC11dWlkPC91dWlkPgogICAgICAgICAgICA8bWV0YWRhdGFpZD57Lip9PC9tZXRhZGF0YWlkPgogICAgICAgICAgICA8ZmlsZW5hbWU+ZXhhbXBsZS54bWw8L2ZpbGVuYW1lPgogICAgICAgIDwvZ2VuZXJhbD4KICAgIDwvcm9vdD4KICAgIA=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 1.18722,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:508:90",
            "status": "corpus",
            "valid_path": "YES",
            "id": 32
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.18340499999999998,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:512:90",
            "status": "corpus",
            "valid_path": "NO",
            "id": 33
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.18495499999999998,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:516:90",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 34
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.179255,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:520:90",
            "status": "corpus",
            "valid_path": "NO",
            "id": 35
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+CiAgICA8bWV0YWRhdGE+CiAgICAgICAgPHV1aWQ+MTIzNC01Njc4LTkxMDEtMTEyMTwvdXVpZD4KICAgICAgICA8cmVzb3VyY2U+CiAgICAgICAgICAgIDxuYW1lPmJhZGZpbGUueG1sPC9uYW1lPgogICAgICAgICAgICA8Y29udGVudD4uKjwvY29udGVudD4gPCEtLSBJbmplY3RpbmcgcmVnZXggc3BlY2lhbCBjaGFyYWN0ZXIgaGVyZSAtLT4KICAgICAgICA8L3Jlc291cmNlPgogICAgICAgIDxkZXRhaWxzPgogICAgICAgICAgICA8aW5mbz4oLiopPC9pbmZvPgogICAgICAgICAgICA8c2NoZW1hPlsuKl08L3NjaGVtYT4KICAgICAgICAgICAgPHZlcnNpb24+KjwvdmVyc2lvbj4gPCEtLSBJbmplY3RpbmcgcmVnZXggc3BlY2lhbCBjaGFyYWN0ZXIgaGVyZSAtLT4KICAgICAgICA8L2RldGFpbHM+CiAgICA8L21ldGFkYXRhPg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 1.66621,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:525:90",
            "status": "corpus",
            "valid_path": "YES",
            "id": 36
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.187755,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:543:94",
            "status": "corpus",
            "valid_path": "NO",
            "id": 37
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:\n111       private MetadataResource createResourceDescription(final ServiceContext context, final SettingManager settingManager, final String metadataUuid,\n112                                                          final MetadataResourceVisibility visibility, final String resourceId, long size, Date lastModification, String version, int metadataId,\n113                                                          boolean approved) {\n114           String filename = getFilename(metadataUuid, resourceId);\n115   \n116           String versionValue = null;\n117           if (CMISConfiguration.isVersioningEnabled()) {\n118               versionValue = version;\n119           }\n120   \n121           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties =\n122               getExternalResourceManagementProperties(context, metadataId, metadataUuid, visibility, resourceId, filename, version);\n123   \n124           return new FilesystemStoreResource(metadataUuid, metadataId, filename,\n125               settingManager.getNodeURL() + \"api/records/\", visibility, size, lastModification, versionValue, externalResourceManagementProperties, approved);\n126       }\n162       @Override\n163       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n164                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility, Boolean approved)\n165               throws Exception {\n166           final SettingManager settingManager = context.getBean(SettingManager.class);\n167           final int metadataId = canEdit(context, metadataUuid, approved);\n168           String key = getKey(context, metadataUuid, metadataId, visibility, filename);\n169   \n170           // Don't use caching for this process.\n171           OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n172           oc.setCacheEnabled(false);\n173   \n174           // Split the filename and parent folder from the key.\n175           int lastFolderDelimiterKeyIndex = key.lastIndexOf(CMISConfiguration.getFolderDelimiter());\n176           String filenameKey = key.substring(lastFolderDelimiterKeyIndex + 1);\n177           String parentKey = key.substring(0, lastFolderDelimiterKeyIndex);\n178   \n179           Map<String, Object> properties = new HashMap<String, Object>();\n180           properties.put(PropertyIds.OBJECT_TYPE_ID, \"cmis:document\");\n181           properties.put(PropertyIds.NAME, filenameKey);\n182           if (changeDate != null) {\n183               properties.put(PropertyIds.LAST_MODIFICATION_DATE, changeDate);\n184           }\n185           int isLength=is.available();\n186           ContentStream contentStream = CMISConfiguration.getClient().getObjectFactory().createContentStream(key, isLength, Files.probeContentType(new File(key).toPath()), is);\n187   \n188           Document doc;\n189           try {\n190               // If the document is found then we are updating the existing document.\n191               doc = (Document) CMISConfiguration.getClient().getObjectByPath(key, oc);\n192               doc.updateProperties(properties, true);\n193               doc.setContentStream(contentStream, true, true);\n194               //           }\n195               // Avoid CMIS API call is info is not enabled.\n196               if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n197                   Log.info(Geonet.RESOURCES,\n198                           String.format(\"Updated metadata resource '%s' for metadata '%s'. Current version '%s'.\", key, metadataUuid, doc.getVersionLabel()));\n199               }\n200           } catch (CmisPermissionDeniedException ex) {\n201               Log.warning(Geonet.RESOURCES, String.format(\n202                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n203               throw new NotAllowedException(String.format(\n204                       \"No permissions to update metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n205   \n206           } catch (CmisConstraintException e) {\n207               Log.warning(Geonet.RESOURCES, String.format(\n208                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n209               throw new NotAllowedException(String.format(\n210                       \"No allowed to modify existing metadata resource '%s' for metadata '%s' due to constraint violation or lock.\", key, metadataUuid));\n211           } catch (CmisObjectNotFoundException e) {\n212               // If the document is not found then we are adding a new document.\n213   \n214               // Get parent folder.\n215               Folder parentFolder;\n216               // synchronize folder creation.\n217               // This will prevent cases where multiple files are uploaded on the interface\n218               // In this case there will be a race condition to create the same folder.\n219               // And if this is not synchronized then there will be a lot or CmisContentAlreadyExistsException errors.\n220               synchronized (this) {\n221                   try {\n222                       parentFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(parentKey, oc);\n223                   } catch (CmisObjectNotFoundException ex) {\n224                       // Create parent folder if it does not exists.\n225                       ObjectId objectId = CMISConfiguration.getClient().createPath(parentKey, \"cmis:folder\");\n226                       parentFolder = (Folder) CMISConfiguration.getClient().getObject(objectId, oc);\n227                   }\n228               }\n229               try {\n230                   doc = parentFolder.createDocument(properties, contentStream, VersioningState.MAJOR);\n231                   // Avoid CMIS API call is info is not enabled.\n232                   if (Logger.getLogger(Geonet.RESOURCES).isInfoEnabled()) {\n233                       Log.info(Geonet.RESOURCES,\n234                               String.format(\"Added resource metadata resource '%s' for metadata '%s'.\", doc.getPaths().get(0), metadataUuid));\n235                   }\n236               } catch (CmisPermissionDeniedException ex) {\n237                   Log.warning(Geonet.RESOURCES, String.format(\n238                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n239                   throw new NotAllowedException(String.format(\n240                           \"No permissions to add metadata resource '%s' for metadata '%s'.\", key, metadataUuid));\n241               }\n242           }\n243   \n244           return createResourceDescription(context, settingManager, metadataUuid, visibility, filename, isLength,\n245                   doc.getLastModificationDate().getTime(), doc.getVersionLabel(), metadataId, approved);\n246       }\n488       private MetadataResource.ExternalResourceManagementProperties getExternalResourceManagementProperties(ServiceContext context,\n489                                                       int metadataId,\n490                                                       final String metadataUuid,\n491                                                       final MetadataResourceVisibility visibility,\n492                                                       final String resourceId,\n493                                                       String filename,\n494                                                       String version\n495       ) {\n496           String externalResourceManagementUrl = CMISConfiguration.getExternalResourceManagementUrl();\n497           if (!StringUtils.isEmpty(externalResourceManagementUrl)) {\n498               // {id}  id\n499               if (externalResourceManagementUrl.contains(\"{id}\")) {\n500                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{id\\\\})\", resourceId);\n501               }\n502               // {uuid}  metadatauuid\n503               if (externalResourceManagementUrl.contains(\"{uuid}\")) {\n504                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{uuid\\\\})\", metadataUuid);\n505               }\n506               // {metadataid}  metadataid\n507               if (externalResourceManagementUrl.contains(\"{metadataid}\")) {\n508                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{metadataid\\\\})\", String.valueOf(metadataId));\n509               }\n510               //    {visibility}  visibility\n511               if (externalResourceManagementUrl.contains(\"{visibility}\")) {\n512                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{visibility\\\\})\", visibility.toString().toLowerCase());\n513               }\n514               //    {filename}  filename\n515               if (externalResourceManagementUrl.contains(\"{filename}\")) {\n516                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{filename\\\\})\", filename);\n517               }\n518               // {version}  version\n519               if (externalResourceManagementUrl.contains(\"{version}\")) {\n520                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{version\\\\})\", version);\n521               }\n522               // {cmisobjectid}  cmis object id\n523               if (externalResourceManagementUrl.contains(\"{cmisobjectid}\")) {\n524                   final CmisObject cmisObject = CMISConfiguration.getClient().getObjectByPath(getKey(context, metadataUuid, metadataId, visibility, resourceId));\n525                   externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{cmisobjectid\\\\})\", ((Document) cmisObject).getVersionSeriesId());\n526               }\n527   \n528               if (externalResourceManagementUrl.contains(\"{lang}\") || externalResourceManagementUrl.contains(\"{ISO3lang}\")) {\n529                   final IsoLanguagesMapper mapper = ApplicationContextHolder.get().getBean(IsoLanguagesMapper.class);\n530                   String contextLang = context.getLanguage() == null ? Geonet.DEFAULT_LANGUAGE : context.getLanguage();\n531                   String lang;\n532                   String iso3Lang;\n533   \n534                   if (contextLang.length() == 2) {\n535                       lang = contextLang;\n536                       iso3Lang = mapper.iso639_1_to_iso639_2(contextLang);\n537                   } else {\n538                       lang = mapper.iso639_2_to_iso639_1(contextLang);\n539                       iso3Lang = contextLang;\n540                   }\n541                   // {lang}  ISO639-1 2 char language\n542                   if (externalResourceManagementUrl.contains(\"{lang}\")) {\n543                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{lang\\\\})\", lang);\n544                   }\n545                   // {iso3lang}  ISO 639-2/T language\n546                   if (externalResourceManagementUrl.contains(\"{iso3lang}\")) {\n547                       externalResourceManagementUrl = externalResourceManagementUrl.replaceAll(\"(\\\\{iso3lang\\\\})\", iso3Lang);\n548                   }\n549               }\n550           }\n551   \n552           MetadataResource.ExternalResourceManagementProperties externalResourceManagementProperties\n553                   = new MetadataResource.ExternalResourceManagementProperties(externalResourceManagementUrl,\n554                   CMISConfiguration.getExternalResourceManagementWindowParameters(), CMISConfiguration.isExternalResourceManagementModal());\n555   \n556           return externalResourceManagementProperties;\n557       }\n",
            "cost": 0.188255,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Regular Expression Injection",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/CMISStore.java:547:94",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 38
        },
        {
            "blob": [
                "PHJvb3Q+PGVudGl0eT48cHJvcGVydHkgbmFtZT0idnVsbmVyYWJsZVByb3BlcnR5Ij4iImpheiIrInplciIiPC9wcm9wZXJ0eT48L2VudGl0eT48L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n126       protected static void addPropertyToElement(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude,\n127               Element record, Method method, final String descName) throws IllegalAccessException, InvocationTargetException {\n128           final Object rawData = method.invoke(obj);\n129           if (rawData != null) {\n130               final Element element = propertyToElement(alreadyEncoded, descName, rawData, exclude);\n131               record.addContent(element);\n132           }\n133       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 1.053005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:128:32",
            "status": "corpus",
            "valid_path": "YES",
            "id": 39
        },
        {
            "blob": [
                "PG1ldGFkYXRhPjxlbnRpdHk+PHByb3BlcnR5IG5hbWU9InZ1bG5lcmFibGVQcm9wZXJ0eSI+IiJqYXoiKyJ6ZXIiIjwvcHJvcGVydHk+PC9lbnRpdHk+PC9tZXRhZGF0YT4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n126       protected static void addPropertyToElement(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude,\n127               Element record, Method method, final String descName) throws IllegalAccessException, InvocationTargetException {\n128           final Object rawData = method.invoke(obj);\n129           if (rawData != null) {\n130               final Element element = propertyToElement(alreadyEncoded, descName, rawData, exclude);\n131               record.addContent(element);\n132           }\n133       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 1.05421,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:128:46",
            "status": "corpus",
            "valid_path": "YES",
            "id": 40
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n 99       protected static void addLabels(Object obj, Element record, Method method) throws IllegalAccessException, InvocationTargetException {\n100           Element labelEl = new Element(LABEL_EL_NAME);\n101   \n102           @SuppressWarnings(\"unchecked\")\n103           Map<String, String> labels = (Map<String, String>) method.invoke(obj);\n104   \n105           if (labels != null) {\n106               for (Map.Entry<String, String> entry : labels.entrySet()) {\n107                   labelEl.addContent(new Element(entry.getKey().toLowerCase()).setText(entry.getValue()));\n108               }\n109           }\n110   \n111           record.addContent(labelEl);\n112       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 0.15779500000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:103:60",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 41
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n 99       protected static void addLabels(Object obj, Element record, Method method) throws IllegalAccessException, InvocationTargetException {\n100           Element labelEl = new Element(LABEL_EL_NAME);\n101   \n102           @SuppressWarnings(\"unchecked\")\n103           Map<String, String> labels = (Map<String, String>) method.invoke(obj);\n104   \n105           if (labels != null) {\n106               for (Map.Entry<String, String> entry : labels.entrySet()) {\n107                   labelEl.addContent(new Element(entry.getKey().toLowerCase()).setText(entry.getValue()));\n108               }\n109           }\n110   \n111           record.addContent(labelEl);\n112       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 0.153095,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:103:74",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 42
        },
        {
            "blob": [
                "PHJvb3Q+PHBhcmFtcz48aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPjwvcGFyYW1zPjwvcm9vdD4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n",
            "cost": 0.500295,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:283:32",
            "status": "corpus",
            "valid_path": "YES",
            "id": 43
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPGhhcnZlc3Rlcj4KICAgIDxwYXJhbXM+CiAgICAgICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KICAgIDwvcGFyYW1zPgogICAgPG5hbWU+VGVzdCBIYXJ2ZXN0ZXI8L25hbWU+CiAgICA8dXVpZD50ZXN0LXV1aWQ8L3V1aWQ+CiAgICA8dHJhbnNsYXRpb25zPgogICAgICAgIDx0cmFuc2xhdGlvbiBsYW5nPSJlbiI+VGVzdCBUcmFuc2xhdGlvbjwvdHJhbnNsYXRpb24+CiAgICA8L3RyYW5zbGF0aW9ucz4KPC9oYXJ2ZXN0ZXI+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n",
            "cost": 0.5069,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:283:44",
            "status": "corpus",
            "valid_path": "YES",
            "id": 44
        },
        {
            "blob": [
                "PHJvb3Q+PGhhcnZlc3Rlcj48cGFyYW1zPjxpY29uPi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2ljb24+PC9wYXJhbXM+PC9oYXJ2ZXN0ZXI+PC9yb290Pg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n",
            "cost": 0.486715,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:309:84",
            "status": "corpus",
            "valid_path": "YES",
            "id": 45
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8cGFyYW1zPgogICAgICAgIDxub2RlPgogICAgICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgICAgIDwvbm9kZT4KICAgIDwvcGFyYW1zPgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java:\n 95       protected Path locateResource(@Nullable Path resourcesDir,\n 96                                     ServletContext context, Path appPath,\n 97                                     @Nonnull String filename) throws IOException {\n 98           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n 99               filename = filename.substring(1);\n100           }\n101   \n102           Path file;\n103           if (resourcesDir != null) {\n104               file = resourcesDir.resolve(filename);\n105           } else {\n106               file = IO.toPath(filename);\n107           }\n108   \n109           if (!Files.exists(file)) {\n110               Path webappCopy = null;\n111               if (context != null) {\n112                   final String realPath = context.getRealPath(filename);\n113                   if (realPath != null) {\n114                       webappCopy = IO.toPath(realPath);\n115                   }\n116               }\n117   \n118               if (webappCopy == null) {\n119                   webappCopy = appPath.resolve(filename);\n120               }\n121               if (Files.exists(webappCopy)) {\n122                   IO.copyDirectoryOrFile(webappCopy, file, false);\n123               }\n124   \n125               final String fileName = file.getFileName().toString();\n126               final int indexOfDot = fileName.lastIndexOf(\".\");\n127               final String suffixless = FilenameUtils.removeExtension(fileName);\n128               final String suffix = FilenameUtils.getExtension(fileName);\n129   \n130               if (!Files.exists(file) && IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n131                   // find a different format and convert it to our desired format\n132                   DirectoryStream.Filter<Path> filter = entry -> {\n133                       String name = entry.getFileName().toString();\n134                       boolean startsWith = name.startsWith(suffixless);\n135                       final String ext = FilenameUtils.getExtension(name).toLowerCase();\n136                       boolean canReadImage = name.length() > indexOfDot && IMAGE_READ_SUFFIXES.contains(ext);\n137                       return startsWith && canReadImage;\n138                   };\n139                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(file.getParent(), filter)) {\n140                       Iterator<Path> iter = paths.iterator();\n141                       if (iter.hasNext()) {\n142                           Path path = iter.next();\n143                           try (\n144                               InputStream in = IO.newInputStream(path);\n145                               OutputStream out = Files.newOutputStream(file)\n146                           ) {\n147                               try {\n148                                   BufferedImage image = ImageIO.read(in);\n149                                   ImageIO.write(image, suffix, out);\n150                               } catch (IOException e) {\n151                                   if (context != null) {\n152                                       context.log(\"Unable to convert image from \" + path + \" to \" + file, e);\n153                                   }\n154                               }\n155                           }\n156                       }\n157                   }\n158               }\n159           }\n160   \n161           return file;\n162       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n128       public static void copyDirectoryOrFile(@Nonnull final Path from,\n129                                              @Nonnull final Path to,\n130                                              boolean copyInto) throws IOException {\n131           copyDirectoryOrFile(from, to, copyInto, null);\n132       }\n141       public static void copyDirectoryOrFile(@Nonnull final Path from,\n142                                              @Nonnull final Path to,\n143                                              boolean copyInto,\n144                                              @Nullable final DirectoryStream.Filter<Path> filter) throws IOException {\n145           Objects.requireNonNull(from);\n146           Objects.requireNonNull(to);\n147   \n148           final Path actualTo;\n149           if (copyInto && Files.isDirectory(to)) {\n150               actualTo = to.resolve(from.getFileName().toString());\n151           } else {\n152               actualTo = to;\n153           }\n154   \n155           if (from.equals(to)) {\n156               return;\n157           }\n158   \n159           if (Files.isDirectory(from)) {\n160               Assert.isTrue(!Files.isRegularFile(actualTo), \"cannot copy a directory to a file. From: \" + from + \" to \" + actualTo);\n161               if (filter == null) {\n162                   Files.walkFileTree(from, new CopyAllFiles(from, actualTo));\n163               } else {\n164                   Files.walkFileTree(from, new CopyAcceptedFiles(from, actualTo, filter));\n165               }\n166           } else if (Files.exists(from)) {\n167               if (filter == null || filter.accept(from)) {\n168                   final Path parent = actualTo.getParent();\n169                   if (parent != null && !Files.exists(parent)) {\n170                       Files.createDirectories(parent);\n171                   }\n172                   Files.copy(from, actualTo);\n173               }\n174           }\n175       }\n",
            "cost": 0.491495,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:172:28",
            "status": "corpus",
            "valid_path": "YES",
            "id": 46
        },
        {
            "blob": [
                "PGNvbmZpZz48cGFyYW1zPjxpY29uPi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2ljb24+PC9wYXJhbXM+PC9jb25maWc+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java:\n 95       protected Path locateResource(@Nullable Path resourcesDir,\n 96                                     ServletContext context, Path appPath,\n 97                                     @Nonnull String filename) throws IOException {\n 98           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n 99               filename = filename.substring(1);\n100           }\n101   \n102           Path file;\n103           if (resourcesDir != null) {\n104               file = resourcesDir.resolve(filename);\n105           } else {\n106               file = IO.toPath(filename);\n107           }\n108   \n109           if (!Files.exists(file)) {\n110               Path webappCopy = null;\n111               if (context != null) {\n112                   final String realPath = context.getRealPath(filename);\n113                   if (realPath != null) {\n114                       webappCopy = IO.toPath(realPath);\n115                   }\n116               }\n117   \n118               if (webappCopy == null) {\n119                   webappCopy = appPath.resolve(filename);\n120               }\n121               if (Files.exists(webappCopy)) {\n122                   IO.copyDirectoryOrFile(webappCopy, file, false);\n123               }\n124   \n125               final String fileName = file.getFileName().toString();\n126               final int indexOfDot = fileName.lastIndexOf(\".\");\n127               final String suffixless = FilenameUtils.removeExtension(fileName);\n128               final String suffix = FilenameUtils.getExtension(fileName);\n129   \n130               if (!Files.exists(file) && IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n131                   // find a different format and convert it to our desired format\n132                   DirectoryStream.Filter<Path> filter = entry -> {\n133                       String name = entry.getFileName().toString();\n134                       boolean startsWith = name.startsWith(suffixless);\n135                       final String ext = FilenameUtils.getExtension(name).toLowerCase();\n136                       boolean canReadImage = name.length() > indexOfDot && IMAGE_READ_SUFFIXES.contains(ext);\n137                       return startsWith && canReadImage;\n138                   };\n139                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(file.getParent(), filter)) {\n140                       Iterator<Path> iter = paths.iterator();\n141                       if (iter.hasNext()) {\n142                           Path path = iter.next();\n143                           try (\n144                               InputStream in = IO.newInputStream(path);\n145                               OutputStream out = Files.newOutputStream(file)\n146                           ) {\n147                               try {\n148                                   BufferedImage image = ImageIO.read(in);\n149                                   ImageIO.write(image, suffix, out);\n150                               } catch (IOException e) {\n151                                   if (context != null) {\n152                                       context.log(\"Unable to convert image from \" + path + \" to \" + file, e);\n153                                   }\n154                               }\n155                           }\n156                       }\n157                   }\n158               }\n159           }\n160   \n161           return file;\n162       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n128       public static void copyDirectoryOrFile(@Nonnull final Path from,\n129                                              @Nonnull final Path to,\n130                                              boolean copyInto) throws IOException {\n131           copyDirectoryOrFile(from, to, copyInto, null);\n132       }\n141       public static void copyDirectoryOrFile(@Nonnull final Path from,\n142                                              @Nonnull final Path to,\n143                                              boolean copyInto,\n144                                              @Nullable final DirectoryStream.Filter<Path> filter) throws IOException {\n145           Objects.requireNonNull(from);\n146           Objects.requireNonNull(to);\n147   \n148           final Path actualTo;\n149           if (copyInto && Files.isDirectory(to)) {\n150               actualTo = to.resolve(from.getFileName().toString());\n151           } else {\n152               actualTo = to;\n153           }\n154   \n155           if (from.equals(to)) {\n156               return;\n157           }\n158   \n159           if (Files.isDirectory(from)) {\n160               Assert.isTrue(!Files.isRegularFile(actualTo), \"cannot copy a directory to a file. From: \" + from + \" to \" + actualTo);\n161               if (filter == null) {\n162                   Files.walkFileTree(from, new CopyAllFiles(from, actualTo));\n163               } else {\n164                   Files.walkFileTree(from, new CopyAcceptedFiles(from, actualTo, filter));\n165               }\n166           } else if (Files.exists(from)) {\n167               if (filter == null || filter.accept(from)) {\n168                   final Path parent = actualTo.getParent();\n169                   if (parent != null && !Files.exists(parent)) {\n170                       Files.createDirectories(parent);\n171                   }\n172                   Files.copy(from, actualTo);\n173               }\n174           }\n175       }\n",
            "cost": 0.5194900000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:172:34",
            "status": "corpus",
            "valid_path": "YES",
            "id": 47
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n140       void updateMetadata(Element xml, final String id, GroupMapper localGroups, final CategoryMapper localCateg,\n141           String changeDate, BaseAligner<LocalFilesystemParams> aligner,\n142           boolean force) throws Exception {\n143   \n144           log.debug(\"  - Updating metadata with id: \" + id);\n145   \n146           String language = context.getLanguage();\n147   \n148           final AbstractMetadata metadata = metadataManager.updateMetadata(context, id, xml, false, false, false, language, changeDate,\n149               true);\n150   \n151           if (force) {\n152               //change ownership of metadata to new harvester (Used in OVERRIDE option)\n153               log.debug(String.format(\"  - Changing source of metadata id %s to '%s' harvester\", id, params.getName()));\n154   \n155               metadata.getHarvestInfo().setUuid(params.getUuid());\n156               metadata.getSourceInfo().setSourceId(params.getUuid());\n157               metadataManager.save(metadata);\n158           }\n159   \n160           OperationAllowedRepository repository = context.getBean(OperationAllowedRepository.class);\n161           repository.deleteAllByMetadataId(Integer.parseInt(id));\n162           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n163   \n164           metadata.getCategories().clear();\n165           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, true);\n166   \n167           metadataManager.flush();\n168   \n169           dataMan.indexMetadata(id, true);\n170       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n273       private void updateMetadata(Path file, Path filePath, Element xml, String schema, String id,\n274           AbstractMetadata metadata, boolean force)\n275           throws Exception {\n276           // Check last modified date of the file with the record change date\n277           // to check if an update is required\n278           if (params.checkFileLastModifiedForUpdate) {\n279               Date fileDate = new Date(Files.getLastModifiedTime(file).toMillis());\n280   \n281               ISODate modified = new ISODate();\n282               if (metadata.getDataInfo() != null) {\n283                   modified = metadata.getDataInfo().getChangeDate();\n284               }\n285   \n286               Date recordDate = modified.toDate();\n287   \n288               String changeDate = new ISODate(fileDate.getTime(), false).getDateAndTime();\n289   \n290               LOGGER.debug(\" File date is: {} / record date is: {}\", filePath, modified);\n291   \n292               if (DateUtils.truncate(recordDate, Calendar.SECOND)\n293                   .before(DateUtils.truncate(fileDate, Calendar.SECOND))) {\n294                   LOGGER.debug(\"  Db record is older than file. Updating record with id: {}\", id);\n295                   updateMedata(xml, id, changeDate, force);\n296               } else {\n297                   LOGGER.debug(\"  Db record is not older than last modified date of file. No need for update.\");\n298                   result.unchangedMetadata++;\n299               }\n300           } else {\n301               LOGGER.debug(\"  updating existing metadata, id is: \" + id);\n302   \n303               String changeDate;\n304   \n305               try {\n306                   changeDate = dataMan.extractDateModified(schema, xml);\n307               } catch (Exception ex) {\n308                   LOGGER.error(\"LocalFilesystemHarvester - updateMetadata - can't get metadata modified date for \" +\n309                       \"metadata id= {}, using current date for modified date\", id);\n310                   changeDate = new ISODate().toString();\n311               }\n312   \n313               updateMedata(xml, id, changeDate, force);\n314           }\n315       }\n405       private void updateMedata(Element xml, String id, String changeDate, boolean force) throws Exception {\n406           harvester.updateMetadata(xml, id, localGroups, localCateg, changeDate, aligner, force);\n407           listOfRecordsToIndex.add(Integer.valueOf(id));\n408           result.updatedMetadata++;\n409       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 715       @Override\n 716       public synchronized AbstractMetadata updateMetadata(final ServiceContext context, final String metadataId, final Element md,\n 717                                                           final boolean validate, final boolean ufo, final boolean index, final String lang, final String changeDate,\n 718                                                           final boolean updateDateStamp) throws Exception {\n 719           Log.trace(Geonet.DATA_MANAGER, \"Update record with id \" + metadataId);\n 720   \n 721           Element metadataXml = md;\n 722   \n 723           // when invoked from harvesters, session is null?\n 724           UserSession session = context.getUserSession();\n 725           if (session != null) {\n 726               session.removeProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n 727           }\n 728           String schema = metadataSchemaUtils.getMetadataSchema(metadataId);\n 729           if (ufo) {\n 730               String parentUuid = null;\n 731               Integer intId = Integer.valueOf(metadataId);\n 732   \n 733               final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 734   \n 735               String uuid = findUuid(metadataXml, schema, metadata);\n 736   \n 737               metadataXml = updateFixedInfo(schema, Optional.of(intId), uuid, metadataXml, parentUuid,\n 738                   (updateDateStamp ? UpdateDatestamp.YES : UpdateDatestamp.NO), context);\n 739           }\n 740   \n 741           // --- force namespace prefix for iso19139 metadata\n 742           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 743   \n 744           // Notifies the metadata change to metatada notifier service\n 745           final AbstractMetadata metadata = metadataUtils.findOne(metadataId);\n 746   \n 747           String uuid = findUuid(metadataXml, schema, metadata);\n 748   \n 749           metadataUtils.checkMetadataWithSameUuidExist(uuid, metadata.getId());\n 750   \n 751           // --- write metadata to dbms\n 752           getXmlSerializer().update(metadataId, metadataXml, changeDate, updateDateStamp, uuid, context);\n 753   \n 754           try {\n 755               // --- do the validation last - it throws exceptions\n 756               if (session != null && validate) {\n 757                   metadataValidator.doValidate(session, schema, metadataId, metadataXml, lang, false);\n 758               }\n 759           } finally {\n 760               if (index) {\n 761                   // --- update search criteria\n 762                   metadataIndexer.indexMetadata(metadataId, true);\n 763               }\n 764           }\n 765   \n 766           if (metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE) {\n 767               if (!index) {\n 768                   metadataIndexer.indexMetadata(metadataId, true);\n 769               }\n 770   //\t\t\tTODOES\n 771   //            MetaSearcher searcher = searcherForReferencingMetadata(context, metadata);\n 772   //            Map<Integer, AbstractMetadata> result = ((LuceneSearcher) searcher).getAllMdInfo(context, 500);\n 773   //            for (Integer id : result.keySet()) {\n 774   //                IndexingList list = context.getBean(IndexingList.class);\n 775   //                list.add(id);\n 776   //            }\n 777           }\n 778   \n 779           Log.trace(Geonet.DATA_MANAGER, \"Finishing update of record with id \" + metadataId);\n 780           // Return an up to date metadata record\n 781           return metadataUtils.findOne(metadataId);\n 782       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataValidator.java:\n245       private Element validateInfo(String schema, Element md, XmlErrorHandler eh) throws Exception {\n246           if (settingManager.getValueAsBool(SYSTEM_METADATA_VALIDATION_REMOVESCHEMALOCATION, false)) {\n247               md.removeAttribute(\"schemaLocation\", Namespaces.XSI);\n248           }\n249           String schemaLoc = md.getAttributeValue(\"schemaLocation\", Namespaces.XSI);\n250           LOGGER.debug(\"Extracted schemaLocation of {}\", schemaLoc);\n251           boolean noChoiceButToUseSchemaLocation = schema == null;\n252           boolean isSchemaLocationDefinedInMd = schemaLoc != null && schemaLoc != \"\";\n253   \n254           if (noChoiceButToUseSchemaLocation || isSchemaLocationDefinedInMd) {\n255               return Xml.validateInfo(md, eh, schema);\n256           } else {\n257               return Xml.validateInfo(metadataSchemaUtils.getSchemaDir(schema).resolve(Geonet.File.SCHEMA), md, eh, schema);\n258           }\n259       }\n284       private Element getXSDXmlReport(String schema, Element md, boolean forEditing) {\n285           // NOTE: this method assumes that enumerateTree has NOT been run on the metadata\n286           XmlErrorHandler errorHandler;\n287           if (forEditing) {\n288               errorHandler = new BaseErrorHandlerAttachingErrorToElem();\n289               ((BaseErrorHandlerAttachingErrorToElem) errorHandler).setElementDecorator(this);\n290           } else {\n291               errorHandler = new XmlErrorHandler();\n292           }\n293           errorHandler.setNs(Edit.NAMESPACE);\n294           try {\n295               Element xsdErrors = validateInfo(schema, md, errorHandler);\n296               if (forEditing) {\n297                   ((BaseErrorHandlerAttachingErrorToElem) errorHandler).attachReports();\n298               }\n299               return xsdErrors;\n300           } catch (Exception e) {\n301               return JeevesException.toElement(e);\n302           }\n303       }\n434       @Override\n435       public Pair<Element, String> doValidate(UserSession session, String schema, String metadataId, Element md, String lang,\n436                                               boolean forEditing) throws Exception {\n437           int intMetadataId = Integer.parseInt(metadataId);\n438           String version = null;\n439           LOGGER.debug(\"Creating validation report for record #{} [schema: {}].\", metadataId, schema);\n440   \n441           Element sessionReport = (Element) session.getProperty(Geonet.Session.VALIDATION_REPORT + metadataId);\n442           if (sessionReport != null && !forEditing) {\n443               LOGGER.debug(\"  Validation report available in session.\");\n444               sessionReport.detach();\n445               return Pair.read(sessionReport, version);\n446           }\n447   \n448           List<MetadataValidation> validations = new ArrayList<>();\n449           Element errorReport = new Element(\"report\", Edit.NAMESPACE);\n450           errorReport.setAttribute(\"id\", metadataId, Edit.NAMESPACE);\n451   \n452           // -- get an XSD validation report and add results to the metadata\n453           // -- as geonet:xsderror attributes on the affected elements\n454           Element xsdErrors = getXSDXmlReport(schema, md, forEditing);\n455           int xsdErrorCount = 0;\n456           if (xsdErrors != null) {\n457               xsdErrorCount = xsdErrors.getContent().size();\n458           }\n459           if (xsdErrorCount > 0) {\n460               errorReport.addContent(xsdErrors);\n461               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n462                   .setStatus(MetadataValidationStatus.INVALID).setRequired(true).setNumTests(xsdErrorCount)\n463                   .setNumFailures(xsdErrorCount));\n464               if (LOGGER.isDebugEnabled()) {\n465                   LOGGER.debug(\"  - XSD error: {}\", Xml.getString(xsdErrors));\n466               }\n467           } else {\n468               validations.add(new MetadataValidation().setId(new MetadataValidationId(intMetadataId, \"xsd\"))\n469                   .setStatus(MetadataValidationStatus.VALID).setRequired(true).setNumTests(1).setNumFailures(0));\n470               LOGGER.trace(\"Valid.\");\n471           }\n472   \n473           // ...then schematrons\n474           Element error = null;\n475           if (forEditing) {\n476               LOGGER.debug(\"  - Schematron in editing mode.\");\n477               // -- now expand the elements and add the geonet: elements\n478               metadataManager.getEditLib().expandElements(schema, md);\n479               version = metadataManager.getEditLib().getVersionForEditing(schema, metadataId, md);\n480   \n481               error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n482           } else {\n483               // enumerate the metadata xml so that we can report any problems found by the schematron_xml script to the geonetwork editor\n484               metadataManager.getEditLib().enumerateTree(md);\n485               try {\n486                   error = applyCustomSchematronRules(schema, intMetadataId, md, lang, validations);\n487               } catch (Exception e) {\n488                   LOGGER.error(\"Could not run schematron validation on metadata {}.\", metadataId);\n489                   LOGGER.error(\"Could not run schematron validation on metadata, exception.\", e);\n490               } finally {\n491                   // remove editing info added by enumerateTree\n492                   metadataManager.getEditLib().removeEditingInfo(md);\n493               }\n494           }\n495   \n496           if (error != null) {\n497               errorReport.addContent(error);\n498           }\n499   \n500           saveValidationStatus(intMetadataId, validations);\n501   \n502           session.setProperty(Geonet.Session.VALIDATION_REPORT + metadataId, errorReport);\n503   \n504           return Pair.read(errorReport, version);\n505       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/Xml.java:\n 962       public static Element validateInfo(Path schemaPath, Element xml, XmlErrorHandler eh, String schemaName) throws Exception {\n 963           Schema schema = getSchemaFromPath(schemaPath);\n 964           return validateRealGuts(schema, xml, eh, schemaName);\n 965       }\n 969       private static Schema getSchemaFromPath(Path schemaPath) throws SAXException {\n 970           PathStreamSource schemaFile = new PathStreamSource(schemaPath);\n 971           schemaFile.setSystemId(schemaPath.toUri().toASCIIString());\n 972   \n 973           final SchemaFactory factory = factory();\n 974           NioPathHolder.setBase(schemaPath);\n 975           Resolver resolver = ResolverWrapper.getInstance();\n 976           factory.setResourceResolver(resolver.getXmlResolver());\n 977           return factory.newSchema(schemaFile);\n 978       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/ResolverWrapper.java:\n62       public static synchronized Resolver getInstance() {\n63           if (!resolverMap.containsKey(DEFAULT)) resolverMap.put(DEFAULT, new Resolver());\n64           return resolverMap.get(DEFAULT);\n65       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/Resolver.java:\n 62       public Resolver() {\n 63           this.oasisCatalogPath = null;\n 64           beforeWrite();\n 65           try {\n 66               setUpXmlResolver();\n 67           } finally {\n 68               afterWrite();\n 69           }\n 70       }\n 84       private void setUpXmlResolver() {\n 85           CatalogManager catMan = new CatalogManager();\n 86           catMan.setAllowOasisXMLCatalogPI(false);\n 87           catMan.setCatalogClassName(\"org.apache.xml.resolver.Catalog\");\n 88           String catFiles = null;\n 89           if(this.oasisCatalogPath == null) {\n 90               catFiles = System.getProperty(Constants.XML_CATALOG_FILES);\n 91               if (catFiles == null) catFiles = \"\";\n 92           } else {\n 93               catFiles = this.oasisCatalogPath.toString();\n 94           }\n 95           if (Log.isDebugEnabled(Log.JEEVES))\n 96               Log.debug(Log.JEEVES, \"Using oasis catalog files \" + catFiles);\n 97   \n 98           setBlankXSLFile(System.getProperty(Constants.XML_CATALOG_BLANKXSLFILE));\n 99   \n100           catMan.setCatalogFiles(catFiles);\n101           catMan.setIgnoreMissingProperties(true);\n102           catMan.setPreferPublic(true);\n103           catMan.setRelativeCatalogs(false);\n104           catMan.setUseStaticCatalog(false);\n105           String catVerbosity = System.getProperty(Constants.XML_CATALOG_VERBOSITY);\n106           if (catVerbosity == null) catVerbosity = \"1\";\n107           int iCatVerb = 1;\n108           try {\n109               iCatVerb = Integer.parseInt(catVerbosity);\n110           } catch (NumberFormatException nfe) {\n111               Log.error(Log.JEEVES, \"Failed to parse \" + Constants.XML_CATALOG_VERBOSITY + \" \" + catVerbosity, nfe);\n112           }\n113           if (Log.isDebugEnabled(Log.JEEVES))\n114               Log.debug(Log.JEEVES, \"Using catalog resolver verbosity \" + iCatVerb);\n115           catMan.setVerbosity(iCatVerb);\n116   \n117           catResolver = new NioPathAwareCatalogResolver(catMan);\n118   \n119           @SuppressWarnings(\"unchecked\")\n120           Vector<String> catalogs = catResolver.getCatalog().getCatalogManager().getCatalogFiles();\n121           String[] cats = new String[catalogs.size()];\n122           System.arraycopy(catalogs.toArray(), 0, cats, 0, catalogs.size());\n123   \n124           if (proxyInfo == null) proxyInfo = new ProxyInfo();\n125           ProxyParams proxyParams = proxyInfo.getProxyParams();\n126           xmlResolver = new XmlResolver(cats, proxyParams);\n127       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/nio/NioPathAwareCatalogResolver.java:\n 60       public NioPathAwareCatalogResolver(CatalogManager catMan) {\n 61           super(catMan);\n 62           final Vector catalogFiles = catMan.getCatalogFiles();\n 63           // any catalogFiles that are paths and not files must be handled by this child.\n 64           for (Object catalogFile : catalogFiles) {\n 65               final String path = catalogFile.toString();\n 66               if (!new File(path).exists() && Files.exists(IO.toPath(path))) {\n 67                   try {\n 68                       final String xml = new String(Files.readAllBytes(IO.toPath(path)), Constants.CHARSET);\n 69                       final Element element = Xml.loadString(xml, false);\n 70                   } catch (Exception e) {\n 71                       throw new RuntimeException(e);\n 72                   }\n 73               }\n 74           }\n 75       }\n",
            "cost": 0.14425500000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/nio/NioPathAwareCatalogResolver.java:68:70",
            "status": "corpus",
            "valid_path": "NO",
            "id": 48
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+Cg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n330       public static InputStream newInputStream(Path file) throws IOException {\n331           if (ApplicationContextHolder.get() != null && ApplicationContextHolder.get().getBeansOfType(SystemInfo.class).size() > 0 &&\n332               ApplicationContextHolder.get().getBean(SystemInfo.class).isDevMode()) {\n333               return new DebuggingInputStream(file.toString(), Files.newInputStream(file));\n334           } else {\n335               return Files.newInputStream(file);\n336           }\n337       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/debug/DebuggingInputStream.java:\n41       public DebuggingInputStream(String descriptor, InputStream in) throws IOException {\n42           super(in);\n43           this.descriptor = descriptor;\n44           OpenResourceTracker.open(descriptor, exception);\n45       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/debug/OpenResourceTracker.java:\n46       public static synchronized void open(String descriptor, OpenResourceTracker openStackTrace) throws IOException {\n47           openResources.put(descriptor, openStackTrace);\n48           reportOpenResources(1000);\n49           reportOpenResources(2000);\n50           reportOpenResources(3000);\n51           reportOpenResources(4000);\n52       }\n54       public static void reportOpenResources(int cutOff) throws IOException {\n55           if (openResources.size() > cutOff && !isReported(cutOff)) {\n56               printExceptions(100);\n57           }\n58       }\n71       public static synchronized void printExceptions(int numExceptionsToPrint) throws IOException {\n72           Path log = Files.createTempFile(\"openFileTraces\", \".txt\");\n73           try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(log, Constants.CHARSET))) {\n74               printExceptions(out, numExceptionsToPrint);\n75           }\n76   \n77           final String message = \"Resource Leak detected: First \" + numExceptionsToPrint + \" of \" + openResources.size() + \" open file stacktraces to: \" + log;\n78           Log.error(Log.JEEVES, message);\n79       }\n",
            "cost": 0.5250250000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/debug/OpenResourceTracker.java:73:72",
            "status": "corpus",
            "valid_path": "YES",
            "id": 49
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+CiAgICA8IURPQ1RZUEUgcm9vdCBbCiAgICA8IUVOVElUWSBmaWxlIFNZU1RFTSAiZmlsZTovLy9ldGMvcGFzc3dkIj4KICAgIF0+CiAgICA8cm9vdD4KICAgICAgICA8ZWxlbWVudD4KICAgICAgICAgICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KICAgICAgICA8L2VsZW1lbnQ+CiAgICA8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n330       public static InputStream newInputStream(Path file) throws IOException {\n331           if (ApplicationContextHolder.get() != null && ApplicationContextHolder.get().getBeansOfType(SystemInfo.class).size() > 0 &&\n332               ApplicationContextHolder.get().getBean(SystemInfo.class).isDevMode()) {\n333               return new DebuggingInputStream(file.toString(), Files.newInputStream(file));\n334           } else {\n335               return Files.newInputStream(file);\n336           }\n337       }\n",
            "cost": 0.49897499999999995,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:333:83",
            "status": "corpus",
            "valid_path": "YES",
            "id": 50
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aGFydmVzdGVyPgogICAgICAgIDxwYXJhbXM+CiAgICAgICAgICAgIDxpY29uUGF0aD4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uUGF0aD4KICAgICAgICA8L3BhcmFtcz4KICAgIDwvaGFydmVzdGVyPgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n238       @Override\n239       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n240                                     final Path appPath, @Nonnull String filename) throws IOException {\n241           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n242               filename = filename.substring(1);\n243           }\n244   \n245           final String key;\n246           if (resourcesDir != null) {\n247               key = getKey(resourcesDir, filename);\n248           } else {\n249               key = CMISConfiguration.getFolderDelimiter() +  filename;\n250           }\n251   \n252           boolean keyExists=false;\n253           // Use getObjectByPath as it does caching while existsPath does not.\n254           try {\n255               CMISConfiguration.getClient().getObjectByPath(key);\n256               keyExists = true;\n257           } catch (CmisObjectNotFoundException e) {\n258               keyExists=false;\n259           }\n260   \n261           if (!keyExists) {\n262               Path webappCopy = null;\n263               if (context != null) {\n264                   final String realPath = context.getRealPath(filename);\n265                   if (realPath != null) {\n266                       webappCopy = IO.toPath(realPath);\n267                   }\n268               }\n269   \n270               if (webappCopy == null) {\n271                   webappCopy = appPath.resolve(filename);\n272               }\n273               if (!Files.isReadable(webappCopy)) {\n274                   final ConfigurableApplicationContext applicationContext =\n275                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n276                   if (resourcesDir.equals(locateResourcesDir(context, applicationContext))) {\n277                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n278                   }\n279               }\n280               if (Files.isReadable(webappCopy)) {\n281                   try (ResourceHolder holder = new CMISResourceHolder(key, true)) {\n282                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to \" + holder.getPath() + \" for resource \" + key);\n283                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n284                   }\n285               } else {\n286   \n287                   final String suffix = FilenameUtils.getExtension(key);\n288   \n289                   // find a different format and convert it to our desired format\n290                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n291                       final String suffixless = FilenameUtils.removeExtension(key);\n292                       final String suffixlessKeyFilename = FilenameUtils.getName(suffixless);\n293                       final String suffixlessKeyFolder = getKey(Paths.get(FilenameUtils.getFullPath(suffixless)));\n294   \n295                       OperationContext oc = CMISConfiguration.getClient().createOperationContext();\n296   \n297                       try {\n298                           Folder resourceFolder = (Folder) CMISConfiguration.getClient().getObjectByPath(suffixlessKeyFolder, oc);\n299                           Map<String, Document> documentMap = getCmisObjectMap(resourceFolder, null, suffixlessKeyFilename);\n300   \n301                           for (Map.Entry<String,Document> entry : documentMap.entrySet()) {\n302                               Document object = entry.getValue();\n303                               String cmisFilePath = entry.getKey();\n304                               final String ext = FilenameUtils.getExtension(object.getName()).toLowerCase();\n305                               if (IMAGE_READ_SUFFIXES.contains(ext)) {\n306                                   try (ResourceHolder in = new CMISResourceHolder(object.getName(), true);\n307                                        ResourceHolder out = new CMISResourceHolder(key, true)) {\n308                                       try (InputStream inS = IO.newInputStream(in.getPath());\n309                                            OutputStream outS = Files.newOutputStream(out.getPath())) {\n310                                           Log.info(Log.RESOURCES, \"Converting \" + cmisFilePath + \" to \" + key);\n311                                           BufferedImage image = ImageIO.read(inS);\n312                                           ImageIO.write(image, suffix, outS);\n313                                           break;\n314                                       } catch (IOException e) {\n315                                           if (context != null) {\n316                                               context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n317                                                       out.getPath(), e);\n318                                           } else {\n319                                               Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n320                                                       in.getPath() + \" to \" + out.getPath(), e);\n321                                           }\n322                                       }\n323                                   }\n324                               }\n325                           }\n326                       } catch (CmisObjectNotFoundException e) {\n327                           Log.warning(Geonet.RESOURCES,\n328                                   String.format(\"Unable to locate resource folder '%s'.\", suffixlessKeyFolder));\n329                           // Ignore not found error.\n330                       }\n331                   }\n332   \n333               }\n334           }\n335   \n336           return getKeyPath(key);\n337       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n330       public static InputStream newInputStream(Path file) throws IOException {\n331           if (ApplicationContextHolder.get() != null && ApplicationContextHolder.get().getBeansOfType(SystemInfo.class).size() > 0 &&\n332               ApplicationContextHolder.get().getBean(SystemInfo.class).isDevMode()) {\n333               return new DebuggingInputStream(file.toString(), Files.newInputStream(file));\n334           } else {\n335               return Files.newInputStream(file);\n336           }\n337       }\n",
            "cost": 0.48553500000000005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:335:41",
            "status": "corpus",
            "valid_path": "YES",
            "id": 51
        },
        {
            "blob": [
                "UEsDBBQAAAAIAFKdK1qZLHPbVwAAAIEAAAAIAAAAaW5mby54bWxdjUEKgDAMBF9kQ/FUCPlLrFErqUpbPfT1gmgPwpyWWQajFB65MOEsmyRWwuwXiUwh79bZ3iG8A0JTjnPQ4AmnoELGwI+Va5XUlcSXpMyK8IgI3w9a9gZQSwMEFAAAAAgAUp0rWvglsK4VAAAAFQAAABAAAABwdWJsaWMvZHVtbXkudHh0C8nILFYAokSFlNLc3EqFtMycVD0AUEsBAhQDFAAAAAgAUp0rWpksc9tXAAAAgQAAAAgAAAAAAAAAAAAAAIABAAAAAGluZm8ueG1sUEsBAhQDFAAAAAgAUp0rWvglsK4VAAAAFQAAABAAAAAAAAAAAAAAAIABfQAAAHB1YmxpYy9kdW1teS50eHRQSwUGAAAAAAIAAgB0AAAAwAAAAAAA"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java:\n167       @Override\n168       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n169                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility,\n170                                           Boolean approved) throws Exception {\n171           int metadataId = canEdit(context, metadataUuid, approved);\n172           Path filePath = getPath(context, metadataId, visibility, filename, approved);\n173           Files.copy(is, filePath, StandardCopyOption.REPLACE_EXISTING);\n174           if (changeDate != null) {\n175               IO.touch(filePath, FileTime.from(changeDate.getTime(), TimeUnit.MILLISECONDS));\n176           }\n177   \n178           return getResourceDescription(context, metadataUuid, visibility, filePath, approved);\n179       }\n",
            "cost": 1.05322,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java:173:20",
            "status": "corpus",
            "valid_path": "YES",
            "id": 52
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n317       private void processMef(Path file) {\n318           Path filePath = file.toAbsolutePath().normalize();\n319   \n320           LOGGER.debug(\"reading file: {}\", filePath);\n321           try {\n322               String xsl = params.getImportXslt();\n323               MEFLib.Version version = MEFLib.getMEFVersion(file);\n324               String fileType = version == MEFLib.Version.V1 ? \"mef\" : \"mef2\";\n325               String style = (xsl == null || xsl.equals(\"none\")) ? \"_none_\" : xsl;\n326               MetadataType isTemplate = MetadataType.lookup(params.recordType);\n327   \n328               MEFLib.UuidAction uuidAction;\n329               switch (params.getOverrideUuid()) {\n330               case SKIP:\n331                   uuidAction = MEFLib.UuidAction.NOTHING;\n332                   break;\n333               case RANDOM:\n334                   uuidAction = MEFLib.UuidAction.GENERATEUUID;\n335                   break;\n336               case OVERRIDE:\n337               default:\n338                   uuidAction = MEFLib.UuidAction.OVERWRITE;\n339               }\n340   \n341   \n342               List<String> ids = MEFLib.doImport(\n343                       fileType,\n344                       uuidAction,\n345                       style,\n346                       params.getUuid(),\n347                       isTemplate,\n348                       Iterables.toArray(params.getCategories(), String.class),\n349                       params.getOwnerIdGroup(),\n350                       params.getValidate() != NOVALIDATION,\n351                       false, context, file);\n352               for (String id : ids) {\n353                   LOGGER.debug(\"Metadata imported from MEF: {}\", id);\n354                   context.getBean(MetadataRepository.class).update(Integer.valueOf(id), new Updater<Metadata>() {\n355                       @Override\n356                       public void apply(@Nonnull final Metadata metadata) {\n357                          metadata.getHarvestInfo().setHarvested(true);\n358                          metadata.getHarvestInfo().setUuid(params.getUuid());\n359                          metadata.getSourceInfo().setOwner(aligner.getOwner());\n360                       }\n361                   });\n362                   aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n363                   listOfRecordsToIndex.add(Integer.valueOf(id));\n364                   listOfRecords.add(Integer.valueOf(id));\n365                   result.addedMetadata++;\n366               }\n367           } catch (Exception e) {\n368               LOGGER.error(\"Error retrieving MEF from file {}, ignoring\", filePath);\n369               LOGGER.error(\"Error: \",  e);\n370               result.unretrievable++;\n371           }\n372       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFLib.java:\n100       public static List<String> doImport(String fileType,\n101                                           final MEFLib.UuidAction uuidAction,\n102                                           final String style,\n103                                           final String source,\n104                                           final MetadataType isTemplate,\n105                                           final String[] category,\n106                                           final String groupId,\n107                                           final boolean validate,\n108                                           final boolean assign,\n109                                           final ServiceContext context,\n110                                           final Path mefFile) throws Exception {\n111           return Importer.doImport(fileType, uuidAction, style, source, isTemplate, category, groupId, validate, assign, context, mefFile);\n112       }\n151       public static void visit(Path mefFile, IVisitor visitor, IMEFVisitor v)\n152           throws Exception {\n153           visitor.visit(mefFile, v);\n154       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/Importer.java:\n105       public static List<String> doImport(String fileType, final MEFLib.UuidAction uuidAction, final String style, final String source,\n106           final MetadataType isTemplate, final String[] category, final String groupId, final boolean validate, final boolean assign,\n107           final ServiceContext context, final Path mefFile) throws Exception {\n108           ApplicationContext applicationContext = ApplicationContextHolder.get();\n109           final DataManager dm = applicationContext.getBean(DataManager.class);\n110           final SettingManager sm = applicationContext.getBean(SettingManager.class);\n111   \n112           // Load preferred schema and set to iso19139 by default\n113           String preferredSchema = applicationContext.getBean(ServiceConfig.class).getValue(\"preferredSchema\", \"iso19139\");\n114   \n115           final List<String> metadataIdMap = new ArrayList<String>();\n116           final List<Element> md = new ArrayList<Element>();\n117           final List<Element> fc = new ArrayList<Element>();\n118   \n119           // Try to define MEF version from mef file not from parameter\n120           if (fileType.equals(\"mef\")) {\n121               MEFLib.Version version = MEFLib.getMEFVersion(mefFile);\n122               if (version != null && version.equals(MEFLib.Version.V2)) {\n123                   fileType = \"mef2\";\n124               }\n125           }\n126   \n127           IVisitor visitor;\n128   \n129           if (fileType.equals(\"single\"))\n130               visitor = new XmlVisitor();\n131           else if (fileType.equals(\"mef\"))\n132               visitor = new MEFVisitor();\n133           else if (fileType.equals(\"mef2\"))\n134               visitor = new MEF2Visitor();\n135           else\n136               throw new BadArgumentException(\"Bad file type parameter.\");\n137   \n138           // --- import metadata from MEF, Xml, ZIP files\n139           final String finalPreferredSchema = preferredSchema;\n140           MEFLib.visit(mefFile, visitor, new IMEFVisitor() {\n141   \n142               public void handleMetadata(Element metadata, int index) throws Exception {\n143                   if (Log.isDebugEnabled(Geonet.MEF))\n144                       Log.debug(Geonet.MEF, \"Collecting metadata:\\n\" + Xml.getString(metadata));\n145                   md.add(index, metadata);\n146               }\n147   \n148               public void handleMetadataFiles(DirectoryStream<Path> metadataXmlFiles, Element info, int index) throws Exception {\n149                   String infoSchema = \"_none_\";\n150                   if (info != null && info.getContentSize() != 0) {\n151                       Element general = info.getChild(\"general\");\n152                       if (general != null && general.getContentSize() != 0) {\n153                           if (general.getChildText(\"schema\") != null) {\n154                               infoSchema = general.getChildText(\"schema\");\n155                           }\n156                       }\n157                   }\n158   \n159                   Path lastUnknownMetadataFolderName = null;\n160                   if (Log.isDebugEnabled(Geonet.MEF))\n161                       Log.debug(Geonet.MEF, \"Multiple metadata files\");\n162   \n163                   if (Log.isDebugEnabled(Geonet.MEF))\n164                       Log.debug(Geonet.MEF, \"info.xml says schema should be \" + infoSchema);\n165   \n166                   Element metadataValidForImport;\n167   \n168                   Map<String, Pair<String, Element>> mdFiles = new HashMap<String, Pair<String, Element>>();\n169                   for (Path file : metadataXmlFiles) {\n170                       if (file != null && java.nio.file.Files.isRegularFile(file)) {\n171                           Element metadata = Xml.loadFile(file);\n172                           try {\n173                               String metadataSchema = dm.autodetectSchema(metadata, null);\n174                               // If local node doesn't know metadata\n175                               // schema try to load next xml file.\n176                               if (metadataSchema == null) {\n177                                   continue;\n178                               }\n179   \n180                               String currFile = \"Found metadata file \" + file.getParent().getParent().relativize(file);\n181   \n182                               mdFiles.put(metadataSchema, Pair.read(currFile, metadata));\n183   \n184                           } catch (NoSchemaMatchesException e) {\n185                               // Important folder name to identify metadata should be ../../\n186                               lastUnknownMetadataFolderName = file.getParent().getParent().relativize(file);\n187                               Log.debug(Geonet.MEF, \"No schema match for \" + lastUnknownMetadataFolderName + \".\");\n188                           }\n189                       }\n190                   }\n191   \n192                   if (mdFiles.size() == 0) {\n193                       throw new BadFormatEx(\"No valid metadata file found\" + ((lastUnknownMetadataFolderName == null) ?\n194                           \"\" :\n195                           (\" in \" + lastUnknownMetadataFolderName)) + \".\");\n196                   }\n197   \n198                   // 1st: Select metadata with schema in info file\n199                   Pair<String, Element> mdInform = mdFiles.get(infoSchema);\n200                   if (mdInform != null) {\n201                       if (Log.isDebugEnabled(Geonet.MEF)) {\n202                           Log.debug(Geonet.MEF, mdInform.one() + \" with info.xml schema (\" + infoSchema + \").\");\n203                       }\n204                       metadataValidForImport = mdInform.two();\n205                       handleMetadata(metadataValidForImport, index);\n206                       return;\n207                   }\n208   \n209                   // 2nd: Select metadata with preferredSchema\n210                   mdInform = mdFiles.get(finalPreferredSchema);\n211                   if (mdInform != null) {\n212                       if (Log.isDebugEnabled(Geonet.MEF)) {\n213                           Log.debug(Geonet.MEF, mdInform.one() + \" with preferred schema (\" + finalPreferredSchema + \").\");\n214                       }\n215                       metadataValidForImport = mdInform.two();\n216                       handleMetadata(metadataValidForImport, index);\n217                       return;\n218                   }\n219   \n220                   // Lastly: Select the first metadata in the map\n221                   String metadataSchema = (String) mdFiles.keySet().toArray()[0];\n222                   mdInform = mdFiles.get(metadataSchema);\n223                   if (Log.isDebugEnabled(Geonet.MEF)) {\n224                       Log.debug(Geonet.MEF, mdInform.one() + \" with known schema (\" + metadataSchema + \").\");\n225                   }\n226                   metadataValidForImport = mdInform.two();\n227   \n228                   // Import valid metadata\n229                   handleMetadata(metadataValidForImport, index);\n230               }\n231   \n232               // --------------------------------------------------------------------\n233   \n234               public void handleFeatureCat(Element featureCat, int index) throws Exception {\n235                   if (featureCat != null) {\n236                       if (Log.isDebugEnabled(Geonet.MEF))\n237                           Log.debug(Geonet.MEF, \"Collecting feature catalog:\\n\" + Xml.getString(featureCat));\n238                   }\n239                   fc.add(index, featureCat);\n240               }\n241   \n242               // --------------------------------------------------------------------\n243   \n244               /**\n245                * Record is not a template by default. No category attached to\n246                * record by default. No stylesheet used by default. If no site\n247                * identifier provided, use current node id by default. No\n248                * validation by default.\n249                * <p/>\n250                * If record is a template and not a MEF file always generate a new\n251                * UUID.\n252                */\n253               public void handleInfo(Element info, int index) throws Exception {\n254                   String uuid = null;\n255                   String createDate = null;\n256                   String changeDate = null;\n257                   String sourceName = null;\n258                   Map<String, String> sourceTranslations = Maps.newHashMap();\n259                   // Schema in info.xml is not used here anymore.\n260                   // It is used in handleMetadataFiles as the first option to pick a\n261                   // metadata file from those in a metadata dir in a MEF2\n262                   // String schema = null;\n263                   String rating = null;\n264                   String popularity = null;\n265                   Element categs = null;\n266                   final Element privileges;\n267   \n268                   // Apply a stylesheet transformation if requested\n269   \n270                   if (!style.equals(\"_none_\")) {\n271                       FilePathChecker.verify(style);\n272   \n273                       final GeonetworkDataDirectory dataDirectory = applicationContext.getBean(GeonetworkDataDirectory.class);\n274                       Path stylePath = dataDirectory.getWebappDir().resolve(Geonet.Path.IMPORT_STYLESHEETS);\n275                       Path xsltPath = stylePath.resolve(style + \".xsl\");\n276                       if (Files.exists(xsltPath)) {\n277                           md.add(index, Xml.transform(md.get(index), xsltPath));\n278                       } else {\n279                           throw new Exception(String.format(\"XSL transformation '%s' not found.\", style));\n280                       }\n281                   }\n282   \n283                   final Element metadata = md.get(index);\n284                   String schema = dm.autodetectSchema(metadata, null);\n285   \n286                   if (schema == null)\n287                       throw new Exception(\"Unknown schema\");\n288   \n289                   // Handle non MEF files insertion\n290                   if (info.getChildren().size() == 0) {\n291                       if (category != null) {\n292                           categs = new Element(\"categories\");\n293                           for (String c : category) {\n294                               // TODO: convert id to name ?\n295                               categs.addContent((new Element(\"category\")).setAttribute(\"name\", c));\n296                           }\n297                       }\n298                       privileges = new Element(\"group\");\n299                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"view\"));\n300                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"editing\"));\n301                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"download\"));\n302                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"notify\"));\n303                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"dynamic\"));\n304                       privileges.addContent(new Element(\"operation\").setAttribute(\"name\", \"featured\"));\n305   \n306                       if (isTemplate == MetadataType.METADATA) {\n307                           // Get the Metadata uuid if it's not a template.\n308                           uuid = dm.extractUUID(schema, md.get(index));\n309                       } else if (isTemplate == MetadataType.SUB_TEMPLATE) {\n310                           // Get subtemplate uuid if defined in @uuid at root\n311                           uuid = md.get(index).getAttributeValue(\"uuid\");\n312                       } else if (isTemplate == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n313                           // Get subtemplate uuid if defined in @uuid at root\n314                           uuid = md.get(index).getAttributeValue(\"uuid\");\n315                       }\n316   \n317                   } else {\n318                       if (Log.isDebugEnabled(Geonet.MEF))\n319                           Log.debug(Geonet.MEF, \"Collecting info file:\\n\" + Xml.getString(info));\n320   \n321                       categs = info.getChild(\"categories\");\n322                       privileges = info.getChild(\"privileges\");\n323   \n324                       Element general = info.getChild(\"general\");\n325   \n326                       uuid = general.getChildText(\"uuid\");\n327                       createDate = general.getChildText(\"createDate\");\n328                       changeDate = general.getChildText(\"changeDate\");\n329                       // If \"assign\" checkbox is set to true, we assign the metadata to the current catalog siteID/siteName\n330                       if (assign) {\n331                           if (Log.isDebugEnabled(Geonet.MEF)) {\n332                               Log.debug(Geonet.MEF, \"Assign to local catalog\");\n333                           }\n334                       } else {\n335                           // --- If siteId is not set, set to current node\n336                           sourceName = general.getChildText(\"siteName\");\n337                           sourceTranslations = translationXmlToLangMap(general.getChildren(\"siteTranslations\"));\n338                           if (Log.isDebugEnabled(Geonet.MEF))\n339                               Log.debug(Geonet.MEF, \"Assign to catalog: \" + source);\n340                       }\n341                       rating = general.getChildText(\"rating\");\n342                       popularity = general.getChildText(\"popularity\");\n343                   }\n344   \n345                   if (schema.startsWith(\"iso19139\")) {\n346                       // In GeoNetwork 3.x, links to resources changed:\n347                       // * thumbnails contains full URL instead of file name only\n348                       // * API mode change old URL structure.\n349                       try {\n350                           MetadataResourceDatabaseMigration.updateMetadataResourcesLink(metadata, null, sm);\n351                       } catch (UnsupportedOperationException ex) {\n352                           // Ignore, this is triggered when importing templates with empty gmd:fileIdentifier, should not fail.\n353                       }\n354                   }\n355   \n356                   if (validate) {\n357                       Integer groupIdVal = null;\n358                       if (org.apache.commons.lang.StringUtils.isNotEmpty(groupId)) {\n359                           groupIdVal = Integer.parseInt(groupId);\n360                       }\n361   \n362                       // Validate xsd and schematron\n363                       DataManager.validateExternalMetadata(schema, metadata, context, groupIdVal);\n364                   }\n365   \n366                   try {\n367                       importRecord(uuid, uuidAction, md, schema, index, source, sourceName, sourceTranslations, context, metadataIdMap,\n368                           createDate, changeDate, groupId, isTemplate);\n369                   } catch (Exception e) {\n370                       throw new Exception(\"Failed to import metadata with uuid '\" + uuid + \"'. \" + e.getLocalizedMessage(), e);\n371                   }\n372   \n373                   if (fc.size() != 0 && fc.get(index) != null) {\n374                       // UUID is set as @uuid in root element\n375                       uuid = UUID.randomUUID().toString();\n376   \n377                       fc.add(index, dm.setUUID(\"iso19110\", uuid, fc.get(index)));\n378   \n379                       //\n380                       // insert metadata\n381                       //\n382                       int userid = context.getUserSession().getUserIdAsInt();\n383                       String group = null, docType = null, title = null, category = null;\n384                       boolean ufo = false, indexImmediate = true;\n385                       String fcId = dm\n386                           .insertMetadata(context, \"iso19110\", fc.get(index), uuid, userid, group, source, isTemplate.codeString, docType,\n387                               category, createDate, changeDate, ufo, indexImmediate);\n388   \n389                       if (Log.isDebugEnabled(Geonet.MEF))\n390                           Log.debug(Geonet.MEF, \"Adding Feature catalog with uuid: \" + uuid);\n391   \n392                       // Create database relation between metadata and feature\n393                       // catalog\n394                       String mdId = metadataIdMap.get(index);\n395   \n396                       final MetadataRelationRepository relationRepository = context.getBean(MetadataRelationRepository.class);\n397                       final MetadataRelation relation = new MetadataRelation();\n398                       relation.setId(new MetadataRelationId(Integer.valueOf(mdId), Integer.valueOf(fcId)));\n399   \n400                       relationRepository.save(relation);\n401   \n402                       metadataIdMap.add(fcId);\n403                       // TODO : privileges not handled for feature catalog ...\n404                   }\n405   \n406                   final int iMetadataId = Integer.valueOf(metadataIdMap.get(index));\n407   \n408                   final String finalPopularity = popularity;\n409                   final String finalRating = rating;\n410                   final Element finalCategs = categs;\n411                   final String finalGroupId = groupId;\n412                   context.getBean(IMetadataManager.class).update(iMetadataId, new Updater<Metadata>() {\n413                       @Override public void apply(@Nonnull final Metadata metadata) {\n414                           final MetadataDataInfo dataInfo = metadata.getDataInfo();\n415                           if (finalPopularity != null) {\n416                               dataInfo.setPopularity(Integer.valueOf(finalPopularity));\n417                           }\n418                           if (finalRating != null) {\n419                               dataInfo.setRating(Integer.valueOf(finalRating));\n420                           }\n421                           dataInfo.setType(isTemplate);\n422   \n423                           metadata.getHarvestInfo().setHarvested(false);\n424   \n425                           addCategoriesToMetadata(metadata, finalCategs, context);\n426   \n427                           if (finalGroupId == null || finalGroupId.equals(\"\")) {\n428                               Group ownerGroup = addPrivileges(context, dm, iMetadataId, privileges);\n429                               if (ownerGroup != null) {\n430                                   metadata.getSourceInfo().setGroupOwner(ownerGroup.getId());\n431                               }\n432                           } else {\n433                               final OperationAllowedRepository allowedRepository = context.getBean(OperationAllowedRepository.class);\n434                               final Set<OperationAllowed> allowedSet = addOperations(context, dm, privileges, iMetadataId,\n435                                   Integer.valueOf(finalGroupId));\n436                               allowedRepository.saveAll(allowedSet);\n437                           }\n438   \n439                       }\n440                   });\n441                   dm.indexMetadata(metadataIdMap.get(index), true);\n442               }\n443   \n444               // --------------------------------------------------------------------\n445   \n446               public void handlePublicFile(String file, String changeDate, InputStream is, int index) throws Exception {\n447                   if (Log.isDebugEnabled(Geonet.MEF)) {\n448                       Log.debug(Geonet.MEF, \"Adding public file with name=\" + file);\n449                   }\n450                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PUBLIC, file, changeDate, is);\n451               }\n452   \n453               // --------------------------------------------------------------------\n454   \n455               public void handlePrivateFile(String file, String changeDate, InputStream is, int index) throws Exception {\n456                   if (Log.isDebugEnabled(Geonet.MEF))\n457                       Log.debug(Geonet.MEF, \"Adding private file with name=\" + file);\n458                   saveFile(context, metadataIdMap.get(index), MetadataResourceVisibility.PRIVATE, file, changeDate, is);\n459               }\n460   \n461           });\n462   \n463           return metadataIdMap;\n464       }\n564       private static void saveFile(ServiceContext context, String id, MetadataResourceVisibility access, String file, String changeDate,\n565           InputStream is) throws Exception {\n566           final Store store = context.getBean(\"resourceStore\", Store.class);\n567           final IMetadataUtils metadataUtils = context.getBean(IMetadataUtils.class);\n568           final String metadataUuid = metadataUtils.getMetadataUuid(id);\n569           assert metadataUuid != null;\n570           store.putResource(context, metadataUuid, file, is, new ISODate(changeDate).toDate(), access, true);\n571       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/mef/MEFVisitor.java:\n 49       public void visit(Path mefFile, IMEFVisitor v) throws Exception {\n 50           Element info = handleXml(mefFile, v);\n 51           handleBin(mefFile, v, info, 0);\n 52       }\n 91       public void handleBin(Path mefFile, IMEFVisitor v, Element info, int index)\n 92           throws Exception {\n 93   \n 94           // yes they must be registered but make sure we don't crash if the\n 95           // public/private elements don't exist\n 96           List<Element> pubFiles;\n 97           if (info.getChild(\"public\") != null) {\n 98               @SuppressWarnings(\"unchecked\")\n 99               List<Element> tmp = info.getChild(\"public\").getChildren();\n100               pubFiles = tmp;\n101           } else {\n102               pubFiles = new ArrayList<>();\n103           }\n104           List<Element> prvFiles;\n105           if (info.getChild(\"private\") != null) {\n106               @SuppressWarnings(\"unchecked\")\n107               List<Element> tmp = info.getChild(\"private\").getChildren();\n108               prvFiles = tmp;\n109           } else {\n110               prvFiles = new ArrayList<>();\n111           }\n112   \n113   \n114           try (FileSystem zipFs = ZipUtil.openZipFs(mefFile)) {\n115               Path pubPath = zipFs.getPath(DIR_PUBLIC);\n116               if (Files.isDirectory(pubPath)) {\n117                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(pubPath)) {\n118                       for (Path path : paths) {\n119                           String simpleName = path.getFileName().toString();\n120                           try (InputStream isb = IO.newInputStream(path)) {\n121                               v.handlePublicFile(simpleName, MEFLib.getChangeDate(pubFiles, simpleName), isb, 0);\n122                           }\n123                       }\n124                   }\n125               }\n126               Path priPath = zipFs.getPath(DIR_PRIVATE);\n127               if (Files.isDirectory(priPath)) {\n128                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(priPath)) {\n129                       for (Path path : paths) {\n130                           String simpleName = path.getFileName().toString();\n131                           try (InputStream isb = IO.newInputStream(path)) {\n132                               v.handlePrivateFile(simpleName, MEFLib.getChangeDate(prvFiles, simpleName), isb, 0);\n133                           }\n134                       }\n135                   }\n136               }\n137           }\n138       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java:\n167       @Override\n168       public MetadataResource putResource(final ServiceContext context, final String metadataUuid, final String filename,\n169                                           final InputStream is, @Nullable final Date changeDate, final MetadataResourceVisibility visibility,\n170                                           Boolean approved) throws Exception {\n171           int metadataId = canEdit(context, metadataUuid, approved);\n172           Path filePath = getPath(context, metadataId, visibility, filename, approved);\n173           Files.copy(is, filePath, StandardCopyOption.REPLACE_EXISTING);\n174           if (changeDate != null) {\n175               IO.touch(filePath, FileTime.from(changeDate.getTime(), TimeUnit.MILLISECONDS));\n176           }\n177   \n178           return getResourceDescription(context, metadataUuid, visibility, filePath, approved);\n179       }\n",
            "cost": 0.16226500000000002,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/api/records/attachments/FilesystemStore.java:173:24",
            "status": "corpus",
            "valid_path": "IDK",
            "id": 53
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPGNvbmZpZz4KICAgIDxzaXRlPgogICAgICAgIDxuYW1lPlRlc3QgU2l0ZTwvbmFtZT4KICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPiA8IS0tIEFkanVzdCBwYXRoIGFzIG5lZWRlZCAtLT4KICAgIDwvc2l0ZT4KPC9jb25maWc+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n",
            "cost": 0.39107000000000003,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:290:46",
            "status": "corpus",
            "valid_path": "YES",
            "id": 54
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgPG5hbWU+VGVzdCBIYXJ2ZXN0ZXI8L25hbWU+CiAgICA8dHJhbnNsYXRpb25zPgogICAgICAgIDx0cmFuc2xhdGlvbiBsYW5nPSJlbiI+VGVzdCBIYXJ2ZXN0ZXI8L3RyYW5zbGF0aW9uPgogICAgPC90cmFuc2xhdGlvbnM+Cjwvcm9vdD4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n",
            "cost": 0.38834,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:290:61",
            "status": "corpus",
            "valid_path": "YES",
            "id": 55
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n278           @Override\n279           public Path getPath() {\n280               if (path != null) {\n281                   return path;\n282               }\n283               final String[] splittedKey = key.split(\"/\");\n284               try {\n285                   path = java.nio.file.Files.createTempFile(\"\", splittedKey[splittedKey.length - 1]);\n286                   try {\n287                       final S3Object object = s3.getClient().getObject(s3.getBucket(), key);\n288                       try (S3ObjectInputStream in = object.getObjectContent()) {\n289                           java.nio.file.Files.copy(in, path,\n290                                                    StandardCopyOption.REPLACE_EXISTING);\n291                       }\n292                   } catch (AmazonServiceException e) {\n293                       if (e.getStatusCode() == HttpStatus.SC_NOT_FOUND && writeOnClose) {\n294                           Files.delete(path);\n295                       } else if (e.getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n296                           throw e;\n297                       }\n298                   }\n299               } catch (IOException e) {\n300                   throw new RuntimeException(e);\n301               }\n302   \n303               return path;\n304           }\n",
            "cost": 0.051340000000000004,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:289:50",
            "status": "corpus",
            "valid_path": "NO",
            "id": 56
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n278           @Override\n279           public Path getPath() {\n280               if (path != null) {\n281                   return path;\n282               }\n283               final String[] splittedKey = key.split(\"/\");\n284               try {\n285                   path = java.nio.file.Files.createTempFile(\"\", splittedKey[splittedKey.length - 1]);\n286                   try {\n287                       final S3Object object = s3.getClient().getObject(s3.getBucket(), key);\n288                       try (S3ObjectInputStream in = object.getObjectContent()) {\n289                           java.nio.file.Files.copy(in, path,\n290                                                    StandardCopyOption.REPLACE_EXISTING);\n291                       }\n292                   } catch (AmazonServiceException e) {\n293                       if (e.getStatusCode() == HttpStatus.SC_NOT_FOUND && writeOnClose) {\n294                           Files.delete(path);\n295                       } else if (e.getStatusCode() != HttpStatus.SC_NOT_FOUND) {\n296                           throw e;\n297                       }\n298                   }\n299               } catch (IOException e) {\n300                   throw new RuntimeException(e);\n301               }\n302   \n303               return path;\n304           }\n",
            "cost": 0.05084,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:289:54",
            "status": "corpus",
            "valid_path": "NO",
            "id": 57
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n546       @VisibleForTesting\n547       Pair<FormatterImpl, FormatterParams> loadMetadataAndCreateFormatterAndParams(ServiceContext context, Key key, final NativeWebRequest request) throws Exception {\n548           final Pair<Element, AbstractMetadata> elementMetadataPair = getMetadata(context, key.mdId, key.hideWithheld);\n549           Element metadata = elementMetadataPair.one();\n550           AbstractMetadata metadataInfo = elementMetadataPair.two();\n551   \n552           return createFormatterAndParams(key.lang, key.formatType, key.formatterId, key.width, request, context, metadata, metadataInfo);\n553       }\n561       private Pair<FormatterImpl, FormatterParams> createFormatterAndParams(String lang, FormatType type, String xslid,\n562                                                                             FormatterWidth width,\n563                                                                             NativeWebRequest request,\n564                                                                             ServiceContext context,\n565                                                                             Element metadata,\n566                                                                             AbstractMetadata metadataInfo) throws Exception {\n567           final String schema = metadataInfo.getDataInfo().getSchemaId();\n568           Path schemaDir = null;\n569           if (schema != null) {\n570               schemaDir = context.getBean(SchemaManager.class).getSchemaDir(schema);\n571           }\n572           GeonetworkDataDirectory geonetworkDataDirectory = context.getBean(GeonetworkDataDirectory.class);\n573           Path formatDir = getAndVerifyFormatDir(geonetworkDataDirectory, \"xsl\", xslid, schemaDir);\n574   \n575           ConfigFile config = new ConfigFile(formatDir, true, schemaDir);\n576   \n577           if (!isCompatibleMetadata(schema, config)) {\n578               throw new IllegalArgumentException(\"The bundle cannot format metadata with the \" + schema + \" schema\");\n579           }\n580   \n581           FormatterParams fparams = new FormatterParams();\n582           fparams.config = config;\n583           fparams.format = this;\n584           fparams.webRequest = request;\n585           fparams.context = context;\n586           fparams.formatDir = formatDir.toRealPath();\n587           fparams.metadata = metadata;\n588           fparams.schema = schema;\n589           fparams.schemaDir = schemaDir;\n590           fparams.formatType = type;\n591           fparams.url = context.getBean(SettingManager.class).getSiteURL(lang);\n592           fparams.metadataInfo = metadataInfo;\n593           fparams.width = width;\n594           fparams.formatterInSchemaPlugin = isFormatterInSchemaPlugin(formatDir, schemaDir);\n595   \n596           Path viewXslFile = formatDir.resolve(FormatterConstants.VIEW_XSL_FILENAME);\n597           Path viewGroovyFile = formatDir.resolve(FormatterConstants.VIEW_GROOVY_FILENAME);\n598           FormatterImpl formatter;\n599           if (Files.exists(viewXslFile)) {\n600               fparams.viewFile = viewXslFile.toRealPath();\n601               formatter = context.getBean(XsltFormatter.class);\n602           } else if (Files.exists(viewGroovyFile)) {\n603               fparams.viewFile = viewGroovyFile.toRealPath();\n604               formatter = context.getBean(GroovyFormatter.class);\n605           } else {\n606               throw new IllegalArgumentException(\"The 'xsl' parameter must be a valid id of a formatter\");\n607           }\n608   \n609           return Pair.read(formatter, fparams);\n610       }\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java:\n 60       public ConfigFile(Path bundleDir, boolean searchParentDir, Path schemaDir) throws IOException {\n 61           this.config = new Properties();\n 62           List<Path> properties = new ArrayList<>();\n 63           if (searchParentDir) {\n 64               if (schemaDir == null) {\n 65                   properties.add(bundleDir.getParent().resolve(CONFIG_PROPERTIES_FILENAME));\n 66                   properties.add(bundleDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 67   \n 68               } else {\n 69                   Path current = bundleDir;\n 70                   while (current.getParent() != null && !schemaDir.equals(current) && Files.exists(current.getParent())) {\n 71                       properties.add(current.resolve(CONFIG_PROPERTIES_FILENAME));\n 72                       current = current.getParent();\n 73                   }\n 74                   properties.add(schemaDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 75               }\n 76           } else {\n 77               properties.add(bundleDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 78           }\n 79   \n 80           // Reverse to allow override (issue #1973):\n 81           // more general -> file in the schema root\n 82           // more specific -> file in the formatter dir\n 83           Collections.reverse(properties);\n 84           for (Path file : properties) {\n 85               if (Files.exists(file)) {\n 86                   try (Reader reader = IO.newBufferedReader(file, Constants.CHARSET)) {\n 87                       config.load(reader);\n 88                   }\n 89               }\n 90           }\n 91       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n339       public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException {\n340           if (ApplicationContextHolder.get() != null && ApplicationContextHolder.get().getBeansOfType(SystemInfo.class).size() > 0 &&\n341               ApplicationContextHolder.get().getBean(SystemInfo.class).isDevMode()) {\n342               return new DebuggingReader(path.toString(), Files.newBufferedReader(path, cs));\n343           } else {\n344               return Files.newBufferedReader(path, cs);\n345           }\n346       }\n",
            "cost": 0.144715,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:342:81",
            "status": "corpus",
            "valid_path": "NO",
            "id": 58
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n546       @VisibleForTesting\n547       Pair<FormatterImpl, FormatterParams> loadMetadataAndCreateFormatterAndParams(ServiceContext context, Key key, final NativeWebRequest request) throws Exception {\n548           final Pair<Element, AbstractMetadata> elementMetadataPair = getMetadata(context, key.mdId, key.hideWithheld);\n549           Element metadata = elementMetadataPair.one();\n550           AbstractMetadata metadataInfo = elementMetadataPair.two();\n551   \n552           return createFormatterAndParams(key.lang, key.formatType, key.formatterId, key.width, request, context, metadata, metadataInfo);\n553       }\n561       private Pair<FormatterImpl, FormatterParams> createFormatterAndParams(String lang, FormatType type, String xslid,\n562                                                                             FormatterWidth width,\n563                                                                             NativeWebRequest request,\n564                                                                             ServiceContext context,\n565                                                                             Element metadata,\n566                                                                             AbstractMetadata metadataInfo) throws Exception {\n567           final String schema = metadataInfo.getDataInfo().getSchemaId();\n568           Path schemaDir = null;\n569           if (schema != null) {\n570               schemaDir = context.getBean(SchemaManager.class).getSchemaDir(schema);\n571           }\n572           GeonetworkDataDirectory geonetworkDataDirectory = context.getBean(GeonetworkDataDirectory.class);\n573           Path formatDir = getAndVerifyFormatDir(geonetworkDataDirectory, \"xsl\", xslid, schemaDir);\n574   \n575           ConfigFile config = new ConfigFile(formatDir, true, schemaDir);\n576   \n577           if (!isCompatibleMetadata(schema, config)) {\n578               throw new IllegalArgumentException(\"The bundle cannot format metadata with the \" + schema + \" schema\");\n579           }\n580   \n581           FormatterParams fparams = new FormatterParams();\n582           fparams.config = config;\n583           fparams.format = this;\n584           fparams.webRequest = request;\n585           fparams.context = context;\n586           fparams.formatDir = formatDir.toRealPath();\n587           fparams.metadata = metadata;\n588           fparams.schema = schema;\n589           fparams.schemaDir = schemaDir;\n590           fparams.formatType = type;\n591           fparams.url = context.getBean(SettingManager.class).getSiteURL(lang);\n592           fparams.metadataInfo = metadataInfo;\n593           fparams.width = width;\n594           fparams.formatterInSchemaPlugin = isFormatterInSchemaPlugin(formatDir, schemaDir);\n595   \n596           Path viewXslFile = formatDir.resolve(FormatterConstants.VIEW_XSL_FILENAME);\n597           Path viewGroovyFile = formatDir.resolve(FormatterConstants.VIEW_GROOVY_FILENAME);\n598           FormatterImpl formatter;\n599           if (Files.exists(viewXslFile)) {\n600               fparams.viewFile = viewXslFile.toRealPath();\n601               formatter = context.getBean(XsltFormatter.class);\n602           } else if (Files.exists(viewGroovyFile)) {\n603               fparams.viewFile = viewGroovyFile.toRealPath();\n604               formatter = context.getBean(GroovyFormatter.class);\n605           } else {\n606               throw new IllegalArgumentException(\"The 'xsl' parameter must be a valid id of a formatter\");\n607           }\n608   \n609           return Pair.read(formatter, fparams);\n610       }\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/ConfigFile.java:\n 60       public ConfigFile(Path bundleDir, boolean searchParentDir, Path schemaDir) throws IOException {\n 61           this.config = new Properties();\n 62           List<Path> properties = new ArrayList<>();\n 63           if (searchParentDir) {\n 64               if (schemaDir == null) {\n 65                   properties.add(bundleDir.getParent().resolve(CONFIG_PROPERTIES_FILENAME));\n 66                   properties.add(bundleDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 67   \n 68               } else {\n 69                   Path current = bundleDir;\n 70                   while (current.getParent() != null && !schemaDir.equals(current) && Files.exists(current.getParent())) {\n 71                       properties.add(current.resolve(CONFIG_PROPERTIES_FILENAME));\n 72                       current = current.getParent();\n 73                   }\n 74                   properties.add(schemaDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 75               }\n 76           } else {\n 77               properties.add(bundleDir.resolve(CONFIG_PROPERTIES_FILENAME));\n 78           }\n 79   \n 80           // Reverse to allow override (issue #1973):\n 81           // more general -> file in the schema root\n 82           // more specific -> file in the formatter dir\n 83           Collections.reverse(properties);\n 84           for (Path file : properties) {\n 85               if (Files.exists(file)) {\n 86                   try (Reader reader = IO.newBufferedReader(file, Constants.CHARSET)) {\n 87                       config.load(reader);\n 88                   }\n 89               }\n 90           }\n 91       }\n\nsrc/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:\n339       public static BufferedReader newBufferedReader(Path path, Charset cs) throws IOException {\n340           if (ApplicationContextHolder.get() != null && ApplicationContextHolder.get().getBeansOfType(SystemInfo.class).size() > 0 &&\n341               ApplicationContextHolder.get().getBean(SystemInfo.class).isDevMode()) {\n342               return new DebuggingReader(path.toString(), Files.newBufferedReader(path, cs));\n343           } else {\n344               return Files.newBufferedReader(path, cs);\n345           }\n346       }\n",
            "cost": 0.146815,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/common/src/main/java/org/fao/geonet/utils/IO.java:344:44",
            "status": "corpus",
            "valid_path": "NO",
            "id": 59
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8dGhlc2F1cnVzPgogICAgICAgIDxrZXk+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwva2V5PgogICAgICAgIDxkbmFtZT5leHBsb2l0PC9kbmFtZT4KICAgICAgICA8ZmlsZW5hbWU+ZXhwbG9pdC54bWw8L2ZpbGVuYW1lPgogICAgICAgIDx0aXRsZT5FeHBsb2l0IFRpdGxlPC90aXRsZT4KICAgICAgICA8bXVsdGlsaW5ndWFsVGl0bGVzPgogICAgICAgICAgICA8bXVsdGlsaW5ndWFsVGl0bGU+CiAgICAgICAgICAgICAgICA8bGFuZz5lbjwvbGFuZz4KICAgICAgICAgICAgICAgIDx0aXRsZT5BY2Nlc3MgdGhpcyBmaWxlOiBqYXp6ZXItdHJhdmVyc2FsPC90aXRsZT4KICAgICAgICAgICAgPC9tdWx0aWxpbmd1YWxUaXRsZT4KICAgICAgICA8L211bHRpbGluZ3VhbFRpdGxlcz4KICAgIDwvdGhlc2F1cnVzPgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 562       @Override\n 563       public AbstractMetadata insertMetadata(ServiceContext context, AbstractMetadata newMetadata, Element metadataXml,\n 564                                              boolean index, boolean updateFixedInfo, UpdateDatestamp updateDatestamp,\n 565                                              boolean fullRightsForGroup, boolean forceRefreshReaders) throws Exception {\n 566           final String schema = newMetadata.getDataInfo().getSchemaId();\n 567   \n 568           // Check if the schema is allowed by settings\n 569           String mdImportSetting = settingManager.getValue(Settings.METADATA_IMPORT_RESTRICT);\n 570           if (mdImportSetting != null && !mdImportSetting.equals(\"\")) {\n 571               if (!newMetadata.getHarvestInfo().isHarvested() && !Arrays.asList(mdImportSetting.split(\",\")).contains(schema)) {\n 572                   throw new IllegalArgumentException(\"The system setting '\" + Settings.METADATA_IMPORT_RESTRICT\n 573                       + \"' doesn't allow to import \" + schema\n 574                       + \" metadata records (they can still be harvested). \"\n 575                       + \"Apply an import stylesheet to convert file to one of the allowed schemas: \" + mdImportSetting);\n 576               }\n 577           }\n 578   \n 579           // --- force namespace prefix for iso19139 metadata\n 580           setNamespacePrefixUsingSchemas(schema, metadataXml);\n 581   \n 582           if (updateFixedInfo && newMetadata.getDataInfo().getType() == MetadataType.METADATA) {\n 583               String parentUuid = null;\n 584               metadataXml = updateFixedInfo(schema, Optional.absent(), newMetadata.getUuid(), metadataXml, parentUuid,\n 585                   updateDatestamp, context);\n 586           }\n 587   \n 588           // --- store metadata\n 589           final AbstractMetadata savedMetadata = getXmlSerializer().insert(newMetadata, metadataXml, context);\n 590   \n 591           final String stringId = String.valueOf(savedMetadata.getId());\n 592           String groupId = null;\n 593           final Integer groupIdI = newMetadata.getSourceInfo().getGroupOwner();\n 594           if (groupIdI != null) {\n 595               groupId = String.valueOf(groupIdI);\n 596           }\n 597           metadataOperations.copyDefaultPrivForGroup(context, stringId, groupId, fullRightsForGroup);\n 598   \n 599           if (index) {\n 600               metadataIndexer.indexMetadata(stringId, forceRefreshReaders);\n 601           }\n 602   \n 603           return savedMetadata;\n 604       }\n 914       @Override\n 915       public Element updateFixedInfo(String schema, Optional<Integer> metadataId, String uuid, Element md, String parentUuid,\n 916                                      UpdateDatestamp updateDatestamp, ServiceContext context) throws Exception {\n 917           boolean autoFixing = settingManager.getValueAsBool(Settings.SYSTEM_AUTOFIXING_ENABLE, true);\n 918           if (autoFixing) {\n 919               LOGGER_DATA_MANAGER.debug(\"Autofixing is enabled, trying update-fixed-info (updateDatestamp: {})\", updateDatestamp.name());\n 920   \n 921               AbstractMetadata metadata = null;\n 922               if (metadataId.isPresent()) {\n 923                   metadata = metadataUtils.findOne(metadataId.get());\n 924               }\n 925   \n 926               String currentUuid = metadata != null ? metadata.getUuid() : null;\n 927               String id = metadata != null ? metadata.getId() + \"\" : null;\n 928               uuid = uuid == null ? currentUuid : uuid;\n 929   \n 930               // --- setup environment\n 931               Element env = new Element(\"env\");\n 932               env.addContent(new Element(\"id\").setText(id));\n 933               env.addContent(new Element(\"uuid\").setText(uuid));\n 934   \n 935               env.addContent(thesaurusManager.buildResultfromThTable(context));\n 936   \n 937               Element schemaLoc = new Element(\"schemaLocation\");\n 938               schemaLoc.setAttribute(schemaManager.getSchemaLocation(schema, context));\n 939               env.addContent(schemaLoc);\n 940   \n 941               if (updateDatestamp == UpdateDatestamp.YES) {\n 942                   String changeDate = new ISODate().toString();\n 943                   String createDate = \"\";\n 944                   if (metadata != null) {\n 945                       changeDate = metadata.getDataInfo().getChangeDate().getDateAndTime();\n 946                       createDate = metadata.getDataInfo().getCreateDate().getDateAndTime();\n 947                   }\n 948                   env.addContent(new Element(\"changeDate\").setText(changeDate));\n 949                   env.addContent(new Element(\"createDate\").setText(createDate));\n 950               }\n 951               if (parentUuid != null) {\n 952                   env.addContent(new Element(\"parentUuid\").setText(parentUuid));\n 953               }\n 954               if (metadataId.isPresent()) {\n 955                   final Path resourceDir = Lib.resource.getDir(Params.Access.PRIVATE, metadataId.get());\n 956                   env.addContent(new Element(\"datadir\").setText(resourceDir.toString()));\n 957               }\n 958   \n 959               // add user information to env if user is authenticated (should be)\n 960               Element elUser = new Element(\"user\");\n 961               UserSession usrSess = context.getUserSession();\n 962               if (usrSess.isAuthenticated()) {\n 963                   String myUserId = usrSess.getUserId();\n 964                   User user = getApplicationContext().getBean(UserRepository.class).findOne(myUserId);\n 965                   if (user != null) {\n 966                       Element elUserDetails = new Element(\"details\");\n 967                       elUserDetails.addContent(new Element(\"surname\").setText(user.getSurname()));\n 968                       elUserDetails.addContent(new Element(\"firstname\").setText(user.getName()));\n 969                       elUserDetails.addContent(new Element(\"organisation\").setText(user.getOrganisation()));\n 970                       elUserDetails.addContent(new Element(\"username\").setText(user.getUsername()));\n 971                       elUser.addContent(elUserDetails);\n 972                       env.addContent(elUser);\n 973                   }\n 974               }\n 975   \n 976               // add original metadata to result\n 977               Element result = new Element(\"root\");\n 978               // Remove the 'geonet' namespace to avoid adding it to the\n 979               // processed elements in updated-fixed-info\n 980               md.removeNamespaceDeclaration(Geonet.Namespaces.GEONET);\n 981               result.addContent(md);\n 982               // add 'environment' to result\n 983               env.addContent(new Element(\"siteURL\").setText(settingManager.getSiteURL(context)));\n 984               env.addContent(new Element(\"nodeURL\").setText(settingManager.getNodeURL()));\n 985               env.addContent(new Element(\"node\").setText(context.getNodeId()));\n 986   \n 987               // Settings were defined as an XML starting with root named config\n 988               // Only second level elements are defined (under system).\n 989               List<?> config = settingManager.getAllAsXML(true).cloneContent();\n 990               for (Object c : config) {\n 991                   Element settings = (Element) c;\n 992                   env.addContent(settings);\n 993               }\n 994   \n 995               result.addContent(env);\n 996               // apply update-fixed-info.xsl\n 997               Path styleSheet = metadataSchemaUtils.getSchemaDir(schema).resolve(\n 998                   metadata != null\n 999                       && (\n1000                           metadata.getDataInfo().getType() == MetadataType.SUB_TEMPLATE\n1001                           || metadata.getDataInfo().getType() == MetadataType.TEMPLATE_OF_SUB_TEMPLATE)?\n1002                       Geonet.File.UPDATE_FIXED_INFO_SUBTEMPLATE :\n1003                       Geonet.File.UPDATE_FIXED_INFO);\n1004               result = Xml.transform(result, styleSheet);\n1005               return result;\n1006           } else {\n1007               LOGGER_DATA_MANAGER.debug(\"Autofixing is disabled, not applying update-fixed-info\");\n1008               return md;\n1009           }\n1010       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/ThesaurusManager.java:\n424       public Element buildResultfromThTable(ServiceContext context) throws SQLException, JDOMException, IOException {\n425   \n426           Element elRoot = new Element(\"thesauri\");\n427   \n428           Collection<Thesaurus> e = getThesauriMap().values();\n429           for (Thesaurus currentTh : e) {\n430               Element elLoop = new Element(\"thesaurus\");\n431   \n432               Element elKey = new Element(\"key\");\n433               String key = currentTh.getKey();\n434               elKey.addContent(key);\n435   \n436               Element elDname = new Element(\"dname\");\n437               String dname = currentTh.getDname();\n438               elDname.addContent(dname);\n439   \n440               Element elFname = new Element(\"filename\");\n441               String fname = currentTh.getFname();\n442               elFname.addContent(fname);\n443   \n444               Element elTitle = new Element(\"title\");\n445               String title = currentTh.getTitles(context.getApplicationContext()).get(context.getLanguage());\n446               if (title == null) {\n447                   title = currentTh.getTitle();\n448               }\n449               elTitle.addContent(title);\n450   \n451               //add multilingual titles in to response\n452               //      \"multilingualTitles\":     [\n453               //            { \"lang\": \"fr\",\"title\": \"Data Usage Scope FR\"},\n454               //            {\"lang\": \"en\",\"title\": \"Data Usage Scope EN\"}\n455               //      ],\n456               Element elMultilingualTitles = new Element(\"multilingualTitles\");\n457               for (Map.Entry<String, String> entry : currentTh.getMultilingualTitles().entrySet()) {\n458                   Element elMultilingualTitle = new Element(\"multilingualTitle\");\n459                   Element elMultilingualTitl_lang = new Element(\"lang\");\n460                   elMultilingualTitl_lang.setText(entry.getKey());\n461                   Element elMultilingualTitle_title = new Element(\"title\");\n462                   elMultilingualTitle_title.setText(entry.getValue());\n463                   elMultilingualTitle.addContent(elMultilingualTitl_lang);\n464                   elMultilingualTitle.addContent(elMultilingualTitle_title);\n465   \n466                   elMultilingualTitles.addContent(elMultilingualTitle);\n467               }\n468   \n469               //add dublin core items to the response\n470               // \"dublinCoreMultilingual\": [\n471               //    { \"lang\": \"fr\",\"tag\":\"title\",\"value\": \"Data Usage Scope FR\"},\n472               //    {\"lang\": \"en\",\"tag\":\"title\",\"value\": \"Data Usage Scope EN\"}\n473               //]\n474               Element elDublinCoreMultilingual = new Element(\"dublinCoreMultilinguals\");\n475               for (Map.Entry<String, Map<String,String>> entryLang : currentTh.getDublinCoreMultilingual().entrySet()) {\n476                   String lang = entryLang.getKey();\n477                   for (Map.Entry<String, String> entryItem : entryLang.getValue().entrySet()) {\n478                       Element elItem = new Element(\"dublinCoreMultilingual\");\n479                       Element elLang = new Element(\"lang\");\n480                       elLang.setText(lang);\n481                       Element elTag = new Element(\"tag\");\n482                       elTag.setText(entryItem.getKey());\n483                       Element elValue = new Element(\"value\");\n484                       elValue.setText(entryItem.getValue());\n485   \n486                       elItem.addContent(elLang);\n487                       elItem.addContent(elTag);\n488                       elItem.addContent(elValue);\n489   \n490   \n491                       elDublinCoreMultilingual.addContent(elItem);\n492                   }\n493               }\n494   \n495               Element elType = new Element(\"type\");\n496               String type = currentTh.getType();\n497               elType.addContent(type);\n498   \n499               Element elDate = new Element(\"date\");\n500               String date = currentTh.getDate();\n501               elDate.addContent(date);\n502   \n503               Element elUrl = new Element(\"url\");\n504               String url = currentTh.getDownloadUrl();\n505               elUrl.addContent(url);\n506   \n507               Element elDefaultURI = new Element(\"defaultNamespace\");\n508               String defaultURI = currentTh.getDefaultNamespace();\n509               elDefaultURI.addContent(defaultURI);\n510   \n511   \n512               Element elActivated = new Element(\"activated\");\n513   \n514               // By default thesaurus are enabled (if nothing defined in db)\n515               char activated = Constants.YN_TRUE;\n516               final Optional<ThesaurusActivation> activation = thesaurusActivationRepository.findById(currentTh.getKey());\n517               if (activation.isPresent() && !activation.get().isActivated()) {\n518                   activated = Constants.YN_FALSE;\n519               }\n520               elActivated.setText(\"\" + activated);\n521   \n522               elLoop.addContent(elKey);\n523               elLoop.addContent(elDname);\n524               elLoop.addContent(elFname);\n525               elLoop.addContent(elTitle);\n526               elLoop.addContent(elMultilingualTitles);\n527               elLoop.addContent(elDublinCoreMultilingual);\n528               elLoop.addContent(elDate);\n529               elLoop.addContent(elUrl);\n530               elLoop.addContent(elDefaultURI);\n531               elLoop.addContent(elType);\n532               elLoop.addContent(elActivated);\n533   \n534               elRoot.addContent(elLoop);\n535           }\n536   \n537           return elRoot;\n538       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/Thesaurus.java:\n1196       public Map<String, String> getTitles(ApplicationContext context) throws JDOMException, IOException {\n1197           return LangUtils.translate(context, getKey());\n1198       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/util/LangUtils.java:\n 60       public static Map<String, String> translate(ApplicationContext context, String type, String key) throws JDOMException, IOException {\n 61           TranslationKey translationKey = new TranslationKey(type, key);\n 62           Map<String, String> translations = translationsCache.get(translationKey);\n 63   \n 64           if (translations == null || context.getBean(SystemInfo.class).isDevMode()) {\n 65               Path webappDir = context.getBean(GeonetworkDataDirectory.class).getWebappDir();\n 66               Path loc = webappDir.resolve(\"loc\");\n 67               XmlCacheManager cacheManager = context.getBean(XmlCacheManager.class);\n 68   \n 69               String xmlTypeWithExtension = \"xml/\" + type + \".xml\";\n 70               String jsonTypeWithExtension = \"json/\" + type + \".json\";\n 71   \n 72               Map<String, String> translations1 = new HashMap<>();\n 73               try (DirectoryStream<Path> paths = Files.newDirectoryStream(loc, IO.DIRECTORIES_FILTER)) {\n 74                   for (Path path : paths) {\n 75                       final String lang = path.getFileName().toString();\n 76                       String translation = null;\n 77                       if (Files.exists(path.resolve(jsonTypeWithExtension))) {\n 78                           Path jsonFile = path.resolve(jsonTypeWithExtension);\n 79                           try {\n 80                               JSONObject json = new JSONObject(new String(Files.readAllBytes(jsonFile), Constants.CHARSET));\n 81                               translation = json.optString(key);\n 82                           } catch (JSONException e) {\n 83                               throw new RuntimeException(\"Failed to parse the following file as a json file: \" + jsonFile, e);\n 84                           }\n 85                       } else if (Files.exists(path.resolve(xmlTypeWithExtension))) {\n 86                           Element xml = cacheManager.get(context, true, loc, xmlTypeWithExtension, lang, lang, false);\n 87                           if (key.contains(\"/\") || key.contains(\"[\") || key.contains(\":\")) {\n 88                               translation = Xml.selectString(xml, key);\n 89                           } else {\n 90                               translation = xml.getChildText(key);\n 91                           }\n 92                       }\n 93                       if (translation != null && !translation.trim().isEmpty()) {\n 94                           translations1.put(lang, translation);\n 95                       }\n 96                   }\n 97               }\n 98               translations = translations1;\n 99               translationsCache.put(translationKey, translations);\n100           }\n101   \n102           return translations;\n103       }\n108       public static Map<String, String> translate(ApplicationContext context, String key) throws JDOMException, IOException {\n109           return translate(context, \"strings\", key);\n110       }\n",
            "cost": 0.9499350000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/util/LangUtils.java:80:92",
            "status": "corpus",
            "valid_path": "YES",
            "id": 60
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n146       @Override\n147       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n148                                     final Path appPath, @Nonnull String filename) throws IOException {\n149           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n150               filename = filename.substring(1);\n151           }\n152   \n153           final String key;\n154           if (resourcesDir != null) {\n155               key = getKey(resourcesDir, filename);\n156           } else {\n157               key = s3.getKeyPrefix() + filename;\n158           }\n159   \n160   \n161           if (!s3.getClient().doesObjectExist(s3.getBucket(), key)) {\n162               Path webappCopy = null;\n163               if (context != null) {\n164                   final String realPath = context.getRealPath(filename);\n165                   if (realPath != null) {\n166                       webappCopy = IO.toPath(realPath);\n167                   }\n168               }\n169   \n170               if (webappCopy == null) {\n171                   webappCopy = appPath.resolve(filename);  // TODO: this won't work...\n172               }\n173               if (!java.nio.file.Files.isReadable(webappCopy)) {\n174                   if (resourcesDir.equals(Paths.get(\"/resources\"))) {\n175                       final ConfigurableApplicationContext applicationContext =\n176                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n177                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n178                   }\n179               }\n180               if (java.nio.file.Files.isReadable(webappCopy)) {\n181                   try (ResourceHolder holder = new S3ResourceHolder(key, true)) {\n182                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to S3 \" + key);\n183                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n184                   }\n185               } else {\n186   \n187                   final String suffix = FilenameUtils.getExtension(key);\n188   \n189                   // find a different format and convert it to our desired format\n190                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n191                       final String suffixless = FilenameUtils.removeExtension(key);\n192                       final ListObjectsV2Result objects =\n193                           s3.getClient().listObjectsV2(s3.getBucket(), suffixless + \".\");\n194                       for (S3ObjectSummary object: objects.getObjectSummaries()) {\n195                           final String ext = FilenameUtils.getExtension(object.getKey()).toLowerCase();\n196                           if (IMAGE_READ_SUFFIXES.contains(ext)) {\n197                               try (ResourceHolder in = new S3ResourceHolder(object.getKey(), true);\n198                                    ResourceHolder out = new S3ResourceHolder(key, true)) {\n199                                   try (InputStream inS = IO.newInputStream(in.getPath());\n200                                        OutputStream outS = java.nio.file.Files.newOutputStream(out.getPath())) {\n201                                       Log.info(Log.RESOURCES, \"Converting \" + object.getKey() + \" to \" + key);\n202                                       BufferedImage image = ImageIO.read(inS);\n203                                       ImageIO.write(image, suffix, outS);\n204                                       break;\n205                                   } catch (IOException e) {\n206                                       if (context != null) {\n207                                           context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n208                                                           out.getPath(), e);\n209                                       } else {\n210                                           Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n211                                               in.getPath() + \" to \" + out.getPath(), e);\n212                                       }\n213                                   }\n214                               }\n215                           }\n216                       }\n217                   }\n218               }\n219           }\n220   \n221           return getKeyPath(key);\n222       }\n",
            "cost": 0.4598200000000001,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:183:32",
            "status": "corpus",
            "valid_path": "YES",
            "id": 61
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+"
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n146       @Override\n147       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n148                                     final Path appPath, @Nonnull String filename) throws IOException {\n149           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n150               filename = filename.substring(1);\n151           }\n152   \n153           final String key;\n154           if (resourcesDir != null) {\n155               key = getKey(resourcesDir, filename);\n156           } else {\n157               key = s3.getKeyPrefix() + filename;\n158           }\n159   \n160   \n161           if (!s3.getClient().doesObjectExist(s3.getBucket(), key)) {\n162               Path webappCopy = null;\n163               if (context != null) {\n164                   final String realPath = context.getRealPath(filename);\n165                   if (realPath != null) {\n166                       webappCopy = IO.toPath(realPath);\n167                   }\n168               }\n169   \n170               if (webappCopy == null) {\n171                   webappCopy = appPath.resolve(filename);  // TODO: this won't work...\n172               }\n173               if (!java.nio.file.Files.isReadable(webappCopy)) {\n174                   if (resourcesDir.equals(Paths.get(\"/resources\"))) {\n175                       final ConfigurableApplicationContext applicationContext =\n176                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n177                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n178                   }\n179               }\n180               if (java.nio.file.Files.isReadable(webappCopy)) {\n181                   try (ResourceHolder holder = new S3ResourceHolder(key, true)) {\n182                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to S3 \" + key);\n183                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n184                   }\n185               } else {\n186   \n187                   final String suffix = FilenameUtils.getExtension(key);\n188   \n189                   // find a different format and convert it to our desired format\n190                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n191                       final String suffixless = FilenameUtils.removeExtension(key);\n192                       final ListObjectsV2Result objects =\n193                           s3.getClient().listObjectsV2(s3.getBucket(), suffixless + \".\");\n194                       for (S3ObjectSummary object: objects.getObjectSummaries()) {\n195                           final String ext = FilenameUtils.getExtension(object.getKey()).toLowerCase();\n196                           if (IMAGE_READ_SUFFIXES.contains(ext)) {\n197                               try (ResourceHolder in = new S3ResourceHolder(object.getKey(), true);\n198                                    ResourceHolder out = new S3ResourceHolder(key, true)) {\n199                                   try (InputStream inS = IO.newInputStream(in.getPath());\n200                                        OutputStream outS = java.nio.file.Files.newOutputStream(out.getPath())) {\n201                                       Log.info(Log.RESOURCES, \"Converting \" + object.getKey() + \" to \" + key);\n202                                       BufferedImage image = ImageIO.read(inS);\n203                                       ImageIO.write(image, suffix, outS);\n204                                       break;\n205                                   } catch (IOException e) {\n206                                       if (context != null) {\n207                                           context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n208                                                           out.getPath(), e);\n209                                       } else {\n210                                           Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n211                                               in.getPath() + \" to \" + out.getPath(), e);\n212                                       }\n213                                   }\n214                               }\n215                           }\n216                       }\n217                   }\n218               }\n219           }\n220   \n221           return getKeyPath(key);\n222       }\n",
            "cost": 0.42795,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:183:44",
            "status": "corpus",
            "valid_path": "YES",
            "id": 62
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxoYXJ2ZXN0PgogICAgICAgIDxub2RlPgogICAgICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgICAgIDwvbm9kZT4KICAgIDwvaGFydmVzdD4="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:\n146       @Override\n147       protected Path locateResource(@Nullable final Path resourcesDir, final ServletContext context,\n148                                     final Path appPath, @Nonnull String filename) throws IOException {\n149           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n150               filename = filename.substring(1);\n151           }\n152   \n153           final String key;\n154           if (resourcesDir != null) {\n155               key = getKey(resourcesDir, filename);\n156           } else {\n157               key = s3.getKeyPrefix() + filename;\n158           }\n159   \n160   \n161           if (!s3.getClient().doesObjectExist(s3.getBucket(), key)) {\n162               Path webappCopy = null;\n163               if (context != null) {\n164                   final String realPath = context.getRealPath(filename);\n165                   if (realPath != null) {\n166                       webappCopy = IO.toPath(realPath);\n167                   }\n168               }\n169   \n170               if (webappCopy == null) {\n171                   webappCopy = appPath.resolve(filename);  // TODO: this won't work...\n172               }\n173               if (!java.nio.file.Files.isReadable(webappCopy)) {\n174                   if (resourcesDir.equals(Paths.get(\"/resources\"))) {\n175                       final ConfigurableApplicationContext applicationContext =\n176                           JeevesDelegatingFilterProxy.getApplicationContextFromServletContext(context);\n177                       webappCopy = super.locateResourcesDir(context, applicationContext).resolve(filename);\n178                   }\n179               }\n180               if (java.nio.file.Files.isReadable(webappCopy)) {\n181                   try (ResourceHolder holder = new S3ResourceHolder(key, true)) {\n182                       Log.info(Log.RESOURCES, \"Copying \" + webappCopy + \" to S3 \" + key);\n183                       Files.copy(webappCopy, holder.getPath(), StandardCopyOption.REPLACE_EXISTING);\n184                   }\n185               } else {\n186   \n187                   final String suffix = FilenameUtils.getExtension(key);\n188   \n189                   // find a different format and convert it to our desired format\n190                   if (IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n191                       final String suffixless = FilenameUtils.removeExtension(key);\n192                       final ListObjectsV2Result objects =\n193                           s3.getClient().listObjectsV2(s3.getBucket(), suffixless + \".\");\n194                       for (S3ObjectSummary object: objects.getObjectSummaries()) {\n195                           final String ext = FilenameUtils.getExtension(object.getKey()).toLowerCase();\n196                           if (IMAGE_READ_SUFFIXES.contains(ext)) {\n197                               try (ResourceHolder in = new S3ResourceHolder(object.getKey(), true);\n198                                    ResourceHolder out = new S3ResourceHolder(key, true)) {\n199                                   try (InputStream inS = IO.newInputStream(in.getPath());\n200                                        OutputStream outS = java.nio.file.Files.newOutputStream(out.getPath())) {\n201                                       Log.info(Log.RESOURCES, \"Converting \" + object.getKey() + \" to \" + key);\n202                                       BufferedImage image = ImageIO.read(inS);\n203                                       ImageIO.write(image, suffix, outS);\n204                                       break;\n205                                   } catch (IOException e) {\n206                                       if (context != null) {\n207                                           context.log(\"Unable to convert image from \" + in.getPath() + \" to \" +\n208                                                           out.getPath(), e);\n209                                       } else {\n210                                           Log.warning(Log.RESOURCES, \"Unable to convert image from \" +\n211                                               in.getPath() + \" to \" + out.getPath(), e);\n212                                       }\n213                                   }\n214                               }\n215                           }\n216                       }\n217                   }\n218               }\n219           }\n220   \n221           return getKeyPath(key);\n222       }\n",
            "cost": 0.469835,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/S3Resources.java:200:94",
            "status": "corpus",
            "valid_path": "YES",
            "id": 63
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxyb290PgogICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KPC9yb290Pg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java:\n 95       protected Path locateResource(@Nullable Path resourcesDir,\n 96                                     ServletContext context, Path appPath,\n 97                                     @Nonnull String filename) throws IOException {\n 98           if (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') {\n 99               filename = filename.substring(1);\n100           }\n101   \n102           Path file;\n103           if (resourcesDir != null) {\n104               file = resourcesDir.resolve(filename);\n105           } else {\n106               file = IO.toPath(filename);\n107           }\n108   \n109           if (!Files.exists(file)) {\n110               Path webappCopy = null;\n111               if (context != null) {\n112                   final String realPath = context.getRealPath(filename);\n113                   if (realPath != null) {\n114                       webappCopy = IO.toPath(realPath);\n115                   }\n116               }\n117   \n118               if (webappCopy == null) {\n119                   webappCopy = appPath.resolve(filename);\n120               }\n121               if (Files.exists(webappCopy)) {\n122                   IO.copyDirectoryOrFile(webappCopy, file, false);\n123               }\n124   \n125               final String fileName = file.getFileName().toString();\n126               final int indexOfDot = fileName.lastIndexOf(\".\");\n127               final String suffixless = FilenameUtils.removeExtension(fileName);\n128               final String suffix = FilenameUtils.getExtension(fileName);\n129   \n130               if (!Files.exists(file) && IMAGE_WRITE_SUFFIXES.contains(suffix.toLowerCase())) {\n131                   // find a different format and convert it to our desired format\n132                   DirectoryStream.Filter<Path> filter = entry -> {\n133                       String name = entry.getFileName().toString();\n134                       boolean startsWith = name.startsWith(suffixless);\n135                       final String ext = FilenameUtils.getExtension(name).toLowerCase();\n136                       boolean canReadImage = name.length() > indexOfDot && IMAGE_READ_SUFFIXES.contains(ext);\n137                       return startsWith && canReadImage;\n138                   };\n139                   try (DirectoryStream<Path> paths = Files.newDirectoryStream(file.getParent(), filter)) {\n140                       Iterator<Path> iter = paths.iterator();\n141                       if (iter.hasNext()) {\n142                           Path path = iter.next();\n143                           try (\n144                               InputStream in = IO.newInputStream(path);\n145                               OutputStream out = Files.newOutputStream(file)\n146                           ) {\n147                               try {\n148                                   BufferedImage image = ImageIO.read(in);\n149                                   ImageIO.write(image, suffix, out);\n150                               } catch (IOException e) {\n151                                   if (context != null) {\n152                                       context.log(\"Unable to convert image from \" + path + \" to \" + file, e);\n153                                   }\n154                               }\n155                           }\n156                       }\n157                   }\n158               }\n159           }\n160   \n161           return file;\n162       }\n",
            "cost": 0.41846000000000005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/FileResources.java:145:70",
            "status": "corpus",
            "valid_path": "YES",
            "id": 64
        },
        {
            "blob": [
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8ZWxlbWVudD4KICAgICAgICA8a2V5Pi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2tleT4KICAgIDwvZWxlbWVudD4KPC9yb290Pgo="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n402           @Override\n403           public Path getPath() {\n404               if (path != null) {\n405                   return path;\n406               }\n407               final String[] splittedKey = key.split(CMISConfiguration.getFolderDelimiter());\n408               try {\n409                   // Preserve filename by putting the files into a temporary folder and using the same filename.\n410                   tempFolderPath = Files.createTempDirectory(\"gn-res-\" + splittedKey[splittedKey.length - 2] + \"-\");\n411                   tempFolderPath.toFile().deleteOnExit();\n412                   path = tempFolderPath.resolve(splittedKey[splittedKey.length - 1]);\n413   \n414                   try {\n415                       final CmisObject object = CMISConfiguration.getClient().getObjectByPath(key);\n416                       try (InputStream in = ((Document) object).getContentStream().getStream()) {\n417                           Files.copy(in, path,\n418                               StandardCopyOption.REPLACE_EXISTING);\n419                       }\n420                   } catch (CmisObjectNotFoundException e) {\n421                       // As there is no cmis file, we will also remove the path if it exists so that the current file does not get saved on close.\n422                       if (writeOnClose && Files.exists(path)) {\n423                           Files.delete(path);\n424                       }\n425                   }\n426               } catch (IOException e) {\n427                   Log.error(Geonet.RESOURCES, String.format(\n428                       \"Error getting path for resource '%s'.\", key), e);\n429                   throw new RuntimeException(e);\n430               }\n431   \n432               return path;\n433           }\n",
            "cost": 0.45572500000000005,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:417:36",
            "status": "corpus",
            "valid_path": "YES",
            "id": 65
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/AbstractHarvester.java:\n 233       public void add(Element node) throws BadInputEx, SQLException {\n 234           status = Status.INACTIVE;\n 235           error = null;\n 236           id = doAdd(node);\n 237       }\n 856       private final String doAdd(Element node) throws BadInputEx, SQLException {\n 857           params = createParams();\n 858   \n 859           //--- retrieve/initialize information\n 860           params.create(node);\n 861   \n 862           //--- force the creation of a new uuid\n 863           params.setUuid(UUID.randomUUID().toString());\n 864   \n 865           String id = harvesterSettingsManager.add(\"harvesting\", \"node\", getType());\n 866           storeNode(params, \"id:\" + id);\n 867   \n 868           Source source = new Source(params.getUuid(), params.getName(), params.getTranslations(), SourceType.harvester);\n 869           context.getBean(SourceRepository.class).save(source);\n 870           final String icon = params.getIcon();\n 871           if (icon != null) {\n 872               context.getBean(Resources.class)\n 873                   .copyLogo(context, \"images\" + File.separator + \"harvesting\" + File.separator + icon, params.getUuid());\n 874           }\n 875   \n 876           return id;\n 877       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/Resources.java:\n274       public void copyLogo(ServiceContext context, String icon,\n275                            String destName) {\n276           ServletContext servletContext = null;\n277           if (context.getServlet() != null) {\n278               servletContext = context.getServlet().getServletContext();\n279           }\n280           Path appDir = context.getAppPath();\n281   \n282           final Path logosDir = locateLogosDir(context);\n283           try {\n284               Path srcPath = locateResource(locateResourcesDir(context), servletContext, appDir, icon);\n285               String extension = Files.getFileExtension(srcPath.getFileName().toString());\n286               try(ResourceHolder src = getImage(context, srcPath.getFileName().toString(), srcPath.getParent());\n287                   ResourceHolder des = getWritableImage(context, destName + \".\" + extension,\n288                                                         logosDir)) {\n289                   if (src != null) {\n290                       java.nio.file.Files.copy(src.getPath(), des.getPath(), REPLACE_EXISTING, NOFOLLOW_LINKS);\n291                   } else {\n292                       des.abort();\n293                   }\n294               }\n295           } catch (IOException e) {\n296               // --- we ignore exceptions here, just log them\n297   \n298               context.warning(\"Cannot copy icon -> \" + e.getMessage());\n299               context.warning(\" (C) Source : \" + icon);\n300               context.warning(\" (C) Destin : \" + logosDir);\n301           }\n302       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:\n402           @Override\n403           public Path getPath() {\n404               if (path != null) {\n405                   return path;\n406               }\n407               final String[] splittedKey = key.split(CMISConfiguration.getFolderDelimiter());\n408               try {\n409                   // Preserve filename by putting the files into a temporary folder and using the same filename.\n410                   tempFolderPath = Files.createTempDirectory(\"gn-res-\" + splittedKey[splittedKey.length - 2] + \"-\");\n411                   tempFolderPath.toFile().deleteOnExit();\n412                   path = tempFolderPath.resolve(splittedKey[splittedKey.length - 1]);\n413   \n414                   try {\n415                       final CmisObject object = CMISConfiguration.getClient().getObjectByPath(key);\n416                       try (InputStream in = ((Document) object).getContentStream().getStream()) {\n417                           Files.copy(in, path,\n418                               StandardCopyOption.REPLACE_EXISTING);\n419                       }\n420                   } catch (CmisObjectNotFoundException e) {\n421                       // As there is no cmis file, we will also remove the path if it exists so that the current file does not get saved on close.\n422                       if (writeOnClose && Files.exists(path)) {\n423                           Files.delete(path);\n424                       }\n425                   }\n426               } catch (IOException e) {\n427                   Log.error(Geonet.RESOURCES, String.format(\n428                       \"Error getting path for resource '%s'.\", key), e);\n429                   throw new RuntimeException(e);\n430               }\n431   \n432               return path;\n433           }\n",
            "cost": 0.054105,
            "harness_id": "GeonetworkOne",
            "sanitizer": "File read/write hook path",
            "sink": "src/geonetwork/core/src/main/java/org/fao/geonet/resources/CMISResources.java:417:40",
            "status": "corpus",
            "valid_path": "NO",
            "id": 66
        },
        {
            "blob": [
                "PHJvb3Q+PGVudGl0eT48cHJvcGVydHkgZGVzY05hbWU9InZ1bG5lcmFibGVQcm9wZXJ0eSI+IiJqYXoiKyJ6ZXIiIjwvcHJvcGVydHk+PC9lbnRpdHk+PC9yb290Pg=="
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n45       public static void fuzzerInitialize() {\n46           contextHolder = Mockito.mockStatic(ApplicationContextHolder.class);\n47           appContext = Mockito.mock(ConfigurableApplicationContext.class);\n48           serviceContext = Mockito.mock(ServiceContext.class);\n49           manager = Mockito.mock(SettingManager.class);\n50           harvesterRepo = Mockito.mock(HarvesterSettingRepository.class);\n51           langRepo = Mockito.mock(LanguageRepository.class);\n52           sourceRepo = Mockito.mock(SourceRepository.class);\n53           resources = Mockito.mock(Resources.class);\n54   \n55           harvesterManager = new HarvesterSettingsManager();\n56           harvester = new LocalFilesystemHarvester();\n57           \n58           Mockito.when(ApplicationContextHolder.get()).thenReturn(appContext);\n59           when(appContext.getBean(SettingManager.class)).thenReturn(manager);\n60           when(appContext.getBean(HarvesterSettingRepository.class)).thenReturn(harvesterRepo);\n61           when(appContext.getBean(LanguageRepository.class)).thenReturn(langRepo);\n62           when(appContext.getBeanNamesForType(LocalFilesystemHarvester.class)).thenReturn(new String[]{\"\"});\n63           when(serviceContext.getBean(\"\", AbstractHarvester.class)).thenReturn(harvester);\n64           when(serviceContext.getBean(HarvesterSettingsManager.class)).thenReturn(harvesterManager);\n65           when(serviceContext.getBean(SourceRepository.class)).thenReturn(sourceRepo);\n66           when(serviceContext.getBean(Resources.class)).thenReturn(resources);\n67           when(serviceContext.getApplicationContext()).thenReturn(appContext);\n68           when(manager.getValue(Settings.SYSTEM_SERVER_TIMEZONE, true)).thenReturn(\"UTC\");\n69       }\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n126       protected static void addPropertyToElement(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude,\n127               Element record, Method method, final String descName) throws IllegalAccessException, InvocationTargetException {\n128           final Object rawData = method.invoke(obj);\n129           if (rawData != null) {\n130               final Element element = propertyToElement(alreadyEncoded, descName, rawData, exclude);\n131               record.addContent(element);\n132           }\n133       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 1.04671,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:128:32",
            "status": "corpus",
            "valid_path": "YES",
            "id": 67
        },
        {
            "blob": [
                ""
            ],
            "code": "src/geonetwork-harnesses/geonetwork-harness-one/src/main/java/com/aixcc/geonetwork/harnesses/one/GeonetworkOne.java:\n71       public static void fuzzerTestOneInput(byte[] b) throws Throwable {\n72           try {\n73               new GeonetworkOne().fuzz(b);\n74           } catch (FuzzerSecurityIssueLow |\n75                    FuzzerSecurityIssueMedium |\n76                    FuzzerSecurityIssueHigh |\n77                    FuzzerSecurityIssueCritical e) {\n78               throw e;\n79           } catch (Throwable t) {\n80           }\n81       }\n83       public void fuzz(byte[] b) throws Throwable {\n84           SAXBuilder saxBuilder = new SAXBuilder();\n85           Document document = saxBuilder.build(new StringReader(new String(b)));\n86           Element element = document.getRootElement();\n87           LocalFilesystemHarvester harvester = (LocalFilesystemHarvester)AbstractHarvester.create(\"\", serviceContext);\n88           harvester.add(element);\n89           harvester.doHarvest(null);\n90       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFilesystemHarvester.java:\n 91       private HarvestResult align(Path root) throws Exception {\n 92           log.debug(\"Start of alignment for : \" + params.getName());\n 93           final LocalFsHarvesterFileVisitor visitor = new LocalFsHarvesterFileVisitor(cancelMonitor, context, params, this);\n 94           if (params.recurse) {\n 95               Files.walkFileTree(root, visitor);\n 96           } else {\n 97               try (DirectoryStream<Path> paths = Files.newDirectoryStream(root)) {\n 98                   for (Path path : paths) {\n 99                       if (path != null && Files.isRegularFile(path)) {\n100                           visitor.visitFile(path, Files.readAttributes(path, BasicFileAttributes.class));\n101                       }\n102                   }\n103               }\n104           }\n105           result = visitor.getResult();\n106           log.debug(String.format(\"Scan directory is done. %d files analyzed.\", result.totalMetadata));\n107           Set<Integer> idsForHarvestingResult = visitor.getListOfRecords();\n108           Set<Integer> idsResultHs = Sets.newHashSet(idsForHarvestingResult);\n109   \n110           if (!params.nodelete) {\n111               log.debug(\"Starting to delete locally existing metadata \" +\n112                   \"from the same source if they \" +\n113                   \" were not in this harvesting result...\");\n114               List<Integer> existingMetadata = context.getBean(MetadataRepository.class).findIdsBy((Specification<Metadata>) MetadataSpecs.hasHarvesterUuid(params.getUuid()));\n115               for (Integer existingId : existingMetadata) {\n116   \n117                   if (cancelMonitor.get()) {\n118                       return this.result;\n119                   }\n120                   if (!idsResultHs.contains(existingId)) {\n121                       log.debug(\"  Removing: \" + existingId);\n122                       metadataManager.deleteMetadata(context, existingId.toString());\n123                       result.locallyRemoved++;\n124                   }\n125               }\n126           }\n127   \n128           log.debug(\"Starting indexing in batch thread pool...\");\n129   \n130           List<Integer> listOfRecordsToIndex = Lists.newArrayList(visitor.getListOfRecordsToIndex());\n131           log.debug(String.format(\n132               \"Starting indexing in batch thread pool of %d updated records ...\",\n133               listOfRecordsToIndex.size()));\n134           dataMan.batchIndexInThreadPool(context, listOfRecordsToIndex);\n135   \n136           log.debug(\"End of alignment for : \" + params.getName());\n137           return result;\n138       }\n172       String addMetadata(Element xml, String uuid, String schema, GroupMapper localGroups, final CategoryMapper localCateg,\n173                          String createDate, BaseAligner aligner, boolean index) throws Exception {\n174   \n175           log.debug(\"  - Adding metadata with remote uuid: \" + uuid);\n176           Element md = xml;\n177   \n178           AbstractMetadata metadata = new Metadata();\n179           metadata.setUuid(uuid);\n180   \n181           MetadataType metadataType = MetadataType.lookup(params.recordType);\n182   \n183           String xmlUuid = null;\n184           if (metadataType == MetadataType.METADATA) {\n185               xmlUuid = metadataUtils.extractUUID(schema, md);\n186           } else if (metadataType == MetadataType.SUB_TEMPLATE) {\n187               xmlUuid = md.getAttributeValue(\"uuid\");\n188           } else if (metadataType == MetadataType.TEMPLATE_OF_SUB_TEMPLATE) {\n189               xmlUuid = md.getAttributeValue(\"uuid\");\n190           }\n191   \n192           if (!uuid.equals(xmlUuid)) {\n193               md = metadataUtils.setUUID(schema, uuid, md);\n194           }\n195           metadata.getDataInfo().\n196               setSchemaId(schema).\n197               setRoot(xml.getQualifiedName()).\n198               setType(metadataType).\n199               setCreateDate(new ISODate(createDate)).\n200               setChangeDate(new ISODate(createDate));\n201           metadata.getSourceInfo().\n202               setSourceId(params.getUuid()).\n203               setOwner(aligner.getOwner()).\n204               setGroupOwner(Integer.valueOf(params.getOwnerIdGroup()));\n205           metadata.getHarvestInfo().\n206               setHarvested(true).\n207               setUuid(params.getUuid());\n208   \n209           aligner.addCategories(metadata, params.getCategories(), localCateg, context, null, false);\n210   \n211           metadata = metadataManager.insertMetadata(context, metadata, md, false, false, UpdateDatestamp.NO, false, false);\n212   \n213           String id = String.valueOf(metadata.getId());\n214   \n215           aligner.addPrivileges(id, params.getPrivileges(), localGroups, context);\n216   \n217           metadataManager.flush();\n218   \n219           if (index) {\n220               dataMan.indexMetadata(id, true);\n221           }\n222           return id;\n223       }\n225       @Override\n226       public void doHarvest(Logger l) throws Exception {\n227           log.debug(\"LocalFilesystem doHarvest: top directory is \" + params.directoryname + \", recurse is \" + params.recurse);\n228           runBeforeScript();\n229           Path directory = IO.toPath(params.directoryname);\n230           this.result = align(directory);\n231       }\n\nsrc/geonetwork/harvesters/src/main/java/org/fao/geonet/kernel/harvest/harvester/localfilesystem/LocalFsHarvesterFileVisitor.java:\n119       @Override\n120       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n121           if (cancelMonitor.get()) {\n122               return FileVisitResult.TERMINATE;\n123           }\n124   \n125           if (file == null || file.getFileName() == null) {\n126               return FileVisitResult.CONTINUE;\n127           }\n128   \n129           boolean isMef = MEFLib.isValidArchiveExtensionForMEF(file.getFileName().toString());\n130           boolean isXml = file.getFileName().toString().endsWith(\".xml\");\n131   \n132           if (!isMef && !isXml) {\n133               return FileVisitResult.CONTINUE;\n134           }\n135   \n136           try {\n137               result.totalMetadata++;\n138   \n139               if (LOGGER.isDebugEnabled() && result.totalMetadata % 1000 == 0) {\n140                   long elapsedTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - startTime);\n141                   LOGGER.debug(\"{} records inserted in {} s ({} records/s).\", new Object[] {\n142                           result.totalMetadata,\n143                           elapsedTime,\n144                           result.totalMetadata / elapsedTime});\n145               }\n146   \n147               if(isMef) {\n148                   processMef(file);\n149               } else {\n150                   processXml(file);\n151               }\n152           } catch (Throwable e) {\n153               LOGGER.error(\"An error occurred while harvesting a local file:{}.\", e.getMessage());\n154           }\n155           return FileVisitResult.CONTINUE;\n156       }\n158       private void processXml(Path file) throws Exception {\n159           Path filePath = file.toAbsolutePath().normalize();\n160   \n161           Element xml;\n162           try {\n163               LOGGER.debug(\"reading file: {}\", filePath);\n164               xml = Xml.loadFile(file);\n165           } catch (JDOMException e) {\n166               LOGGER.debug(\"Error loading XML from file {}, ignoring\", filePath);\n167               LOGGER.debug(\"full stack\", e);\n168               result.badFormat++;\n169               return;\n170           } catch (Throwable e) {\n171               LOGGER.debug(\"Error retrieving XML from file {}, ignoring\", filePath);\n172               LOGGER.debug(\"full stack\", e);\n173               result.unretrievable++;\n174               return;\n175           }\n176   \n177           // transform using importxslt if not none\n178           if (transformIt) {\n179               try {\n180                   xml = Xml.transform(xml, thisXslt);\n181               } catch (Exception e) {\n182                   LOGGER.debug(\"Cannot transform XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n183                   result.badFormat++;\n184                   return;\n185               }\n186           }\n187   \n188           String schema = null;\n189           try {\n190               schema = dataMan.autodetectSchema(xml, null);\n191           } catch (Exception e) {\n192               result.unknownSchema++;\n193               return;\n194           }\n195   \n196           try {\n197               Integer groupIdVal = null;\n198               if (StringUtils.isNotEmpty(params.getOwnerIdGroup())) {\n199                   groupIdVal = Integer.parseInt(params.getOwnerIdGroup());\n200               }\n201   \n202               params.getValidate().validate(dataMan, context, xml, groupIdVal);\n203           } catch (Exception e) {\n204               LOGGER.debug(\"Cannot validate XML from file {}, ignoring. Error was: {}\", filePath, e.getMessage());\n205               result.doesNotValidate++;\n206               return;\n207           }\n208   \n209           String uuid = getUuidFromFile(xml, filePath, schema);\n210           if (uuid == null || uuid.equals(\"\")) {\n211               result.badFormat++;\n212               return;\n213           }\n214   \n215           String id = dataMan.getMetadataId(uuid);\n216           if (id == null) {\n217               String createDate = getCreateDate(file, xml, schema, uuid);\n218   \n219               id = addMetadata(xml, schema, uuid, createDate);\n220           } else {\n221               final AbstractMetadata metadata = repo.findOne(id);\n222               if (!params.getUuid().equals(metadata.getHarvestInfo().getUuid())) {\n223                   // Metadata exists and belongs to another source (local node or other harvester)\n224                   switch (params.getOverrideUuid()) {\n225                   case OVERRIDE:\n226                       updateMetadata(file, filePath, xml, schema, id, metadata, true);\n227                       break;\n228                   case RANDOM:\n229                       LOGGER.debug(\"Generating random uuid for remote record with uuid \" + metadata.getUuid());\n230                       String createDate = getCreateDate(file, xml, schema, uuid);\n231                       String newUuid = UUID.randomUUID().toString();\n232                       id = addMetadata(xml, schema, newUuid, createDate);\n233   \n234                       break;\n235                   case SKIP:\n236                       LOGGER.debug(\"Skipping record with uuid \" + metadata.getUuid());\n237                       result.uuidSkipped++;\n238                       result.unchangedMetadata++;\n239   \n240                       break;\n241                   default:\n242                       // Do nothing\n243                       break;\n244                   }\n245               } else {\n246                   //record exists and belongs to this harvester\n247                   updateMetadata(file, filePath, xml, schema, id, metadata, false);\n248               }\n249   \n250           }\n251           listOfRecords.add(Integer.valueOf(id));\n252       }\n397       private String addMetadata(Element xml, String schema, String uuid, String createDate) throws Exception {\n398           LOGGER.debug(\"adding new metadata\");\n399           String id = harvester.addMetadata(xml, uuid, schema, localGroups, localCateg, createDate, aligner, false);\n400           listOfRecordsToIndex.add(Integer.valueOf(id));\n401           result.addedMetadata++;\n402           return id;\n403       }\n\nsrc/geonetwork/core/src/main/java/org/fao/geonet/kernel/datamanager/base/BaseMetadataManager.java:\n 267       @Override\n 268       @Deprecated\n 269       public void flush() {\n 270           TransactionManager.runInTransaction(\"DataManager flush()\", getApplicationContext(),\n 271               TransactionManager.TransactionRequirement.CREATE_ONLY_WHEN_NEEDED, TransactionManager.CommitBehavior.ALWAYS_COMMIT, false,\n 272               new TransactionTask<Object>() {\n 273                   @Override\n 274                   public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n 275                       _entityManager.flush();\n 276                       return null;\n 277                   }\n 278               });\n 279   \n 280       }\n\nsrc/geonetwork/core/src/main/java/jeeves/transaction/TransactionManager.java:\n 47       public static <V> V runInTransaction(String name,\n 48                                            ApplicationContext context,\n 49                                            TransactionRequirement transactionRequirement,\n 50                                            CommitBehavior commitBehavior,\n 51                                            boolean readOnly,\n 52                                            final TransactionTask<V> action) {\n 53           final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n 54           final Throwable[] exception = new Throwable[1];\n 55           TransactionStatus transaction = null;\n 56           boolean isNewTransaction = false;\n 57           boolean rolledBack = false;\n 58           V result = null;\n 59           try {\n 60               DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n 61               definition.setName(name);\n 62               definition.setReadOnly(readOnly);\n 63               transaction = transactionManager.getTransaction(definition);\n 64               isNewTransaction = transaction.isNewTransaction();\n 65   \n 66               if (isNewTransaction) {\n 67                   Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n 68                   for (NewTransactionListener listener : listeners) {\n 69                       listener.newTransaction(transaction);\n 70                   }\n 71               }\n 72   \n 73               result = action.doInTransaction(transaction);\n 74   \n 75           } catch (Throwable e) {\n 76               Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n 77               if (exception[0] == null) {\n 78                   exception[0] = e;\n 79               }\n 80               rolledBack = true;\n 81               doRollback(context, transactionManager, transaction);\n 82           } finally {\n 83               try {\n 84                   if (readOnly) {\n 85                       doRollback(context, transactionManager, transaction);\n 86                   } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n 87                       doCommit(context, transactionManager, transaction);\n 88                   }\n 89               } catch (TransactionSystemException e) {\n 90                   if (!(e.getOriginalException() instanceof RollbackException)) {\n 91                       Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 92                       doRollback(context, transactionManager, transaction);\n 93                   } else {\n 94                       Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n 95                   }\n 96               } catch (Throwable t) {\n 97                   Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n 98                   doRollback(context, transactionManager, transaction);\n 99               }\n100           }\n101   \n102           if (exception[0] != null) {\n103               if (exception[0] instanceof RuntimeException) {\n104                   throw (RuntimeException) exception[0];\n105               } else if (exception[0] instanceof Error) {\n106                   throw (Error) exception[0];\n107               } else {\n108                   throw new RuntimeException(exception[0]);\n109               }\n110           }\n111           return result;\n112       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/processing/MInspireEtfValidateProcess.java:\n155                               @Override\n156                               public Object doInTransaction(TransactionStatus transaction) throws Throwable {\n157                                   // Evaluate test conditions for INSPIRE test suites to apply to the metadata\n158                                   Map<String, String> testsuiteConditions =\n159                                       inspireValidatorUtils.calculateTestsuitesToApply(record.getDataInfo().getSchemaId(), metadataSchemaUtils);\n160   \n161                                   boolean reindexMetadata = false;\n162   \n163                                   String mdToValidate = retrieveMetadataToValidate(context, record);\n164   \n165                                   try {\n166                                       boolean inspireMetadata = false;\n167   \n168                                       if (StringUtils.isNotEmpty(mdToValidate)) {\n169                                           for (Map.Entry<String, String> entry : testsuiteConditions.entrySet()) {\n170                                               boolean applyCondition = false;\n171                                               try {\n172                                                   // Checks the condition in the original record\n173                                                   applyCondition = Xml.selectBoolean(record.getXmlData(false),\n174                                                       entry.getValue(),\n175                                                       schemaManager.getSchema(record.getDataInfo().getSchemaId()).getNamespaces());\n176                                               } catch (Exception ex) {\n177                                                   Log.error(API.LOG_MODULE_NAME, String.format(\"Error checking INSPIRE rule %s to apply to metadata: %s\",\n178                                                       entry.getKey(), record.getUuid()), ex);\n179                                               }\n180   \n181                                               if (applyCondition) {\n182   \n183                                                   String testId = null;\n184                                                   String getRecordByIdUrl = null;\n185                                                   if (StringUtils.isEmpty(mode)) {\n186                                                       testId = inspireValidatorUtils.submitFile(serviceContext, URL,\n187                                                           new ByteArrayInputStream(mdToValidate.getBytes()), entry.getKey(), record.getUuid());\n188                                                   } else {\n189                                                       String portal = null;\n190                                                       if (!NodeInfo.DEFAULT_NODE.equals(mode)) {\n191                                                           Source source = appContext.getBean(SourceRepository.class).findOneByUuid(mode);\n192                                                           if (source == null) {\n193                                                               metadataAnalysedInError++;\n194                                                               Log.warning(API.LOG_MODULE_NAME, String.format(\n195                                                                   \"Portal %s not found. There is no CSW endpoint at this URL \" +\n196                                                                       \"that we can send to the validator.\", mode));\n197                                                           }\n198                                                           portal = mode;\n199                                                       } else {\n200                                                           portal = NodeInfo.DEFAULT_NODE;\n201                                                       }\n202   \n203                                                       if (portal  != null) {\n204                                                           getRecordByIdUrl = String.format(\n205                                                               \"%s%s/eng/csw?SERVICE=CSW&REQUEST=GetRecordById&VERSION=2.0.2&\" +\n206                                                                   \"OUTPUTSCHEMA=%s&ELEMENTSETNAME=full&ID=%s\",\n207                                                               appContext.getBean(SettingManager.class).getBaseURL(),\n208                                                               portal,\n209                                                               ISO19139Namespaces.GMD.getURI(),\n210                                                               record.getUuid());\n211                                                           testId = inspireValidatorUtils.submitUrl(serviceContext, URL, getRecordByIdUrl, entry.getKey(), record.getUuid());\n212                                                       }\n213                                                   }\n214                                                   if (testId != null) {\n215   \n216                                                       inspireValidatorUtils.waitUntilReady(serviceContext, URL, testId);\n217   \n218                                                       String reportUrl = inspireValidatorUtils.getReportUrl(URL, testId);\n219                                                       String reportXmlUrl = InspireValidatorUtils.getReportUrlXML(URL, testId);\n220                                                       String reportXml = inspireValidatorUtils.retrieveReport(serviceContext, reportXmlUrl);\n221   \n222                                                       String validationStatus = inspireValidatorUtils.isPassed(serviceContext, URL, testId);\n223   \n224                                                       MetadataValidationStatus metadataValidationStatus =\n225                                                           inspireValidatorUtils.calculateValidationStatus(validationStatus);\n226   \n227                                                       MetadataValidation metadataValidation = new MetadataValidation()\n228                                                           .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n229                                                           .setStatus(metadataValidationStatus).setRequired(false)\n230                                                           .setReportUrl(reportUrl).setReportContent(reportXml);\n231   \n232                                                       metadataValidationRepository.save(metadataValidation);\n233   \n234                                                       //new RecordValidationTriggeredEvent(record.getId(),\n235                                                       //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n236                                                       //    metadataValidation.getStatus().getCode()).publish(appContext);\n237   \n238                                                       reindexMetadata = true;\n239                                                       inspireMetadata = true;\n240                                                   }\n241                                               }\n242                                           }\n243                                       }\n244   \n245                                       if (!inspireMetadata) {\n246                                           metadataNotInspire++;\n247   \n248                                           MetadataValidation metadataValidation = new MetadataValidation()\n249                                               .setId(new MetadataValidationId(record.getId(), \"inspire\"))\n250                                               .setStatus(MetadataValidationStatus.DOES_NOT_APPLY).setRequired(false);\n251   \n252                                           metadataValidationRepository.save(metadataValidation);\n253   \n254                                           //new RecordValidationTriggeredEvent(record.getId(),\n255                                           //    ApiUtils.getUserSession(request.getSession()).getUserIdAsInt(),\n256                                           //    metadataValidation.getStatus().getCode()).publish(appContext);\n257   \n258                                           reindexMetadata = true;\n259                                       }\n260   \n261                                       if (reindexMetadata) {\n262                                           dataManager.indexMetadata(new ArrayList<>(Arrays.asList(record.getId() + \"\")));\n263                                       }\n264   \n265                                   } catch (Exception ex) {\n266                                       metadataAnalysedInError++;\n267                                       Log.error(API.LOG_MODULE_NAME,\n268                                           String.format(\"Error validating metadata %s in INSPIRE validator: %s\",\n269                                               record.getUuid(), ex.getMessage()), ex);\n270                                   }\n271   \n272                                   metadataAnalysed++;\n273   \n274                                   return null;\n275                               }\n306       private String retrieveMetadataToValidate(ServiceContext context, AbstractMetadata record) {\n307           String mdToValidate = null;\n308   \n309           if (!record.getDataInfo().getSchemaId().equals(ISO19139SchemaPlugin.IDENTIFIER)) {\n310               try {\n311                   Key key = new Key(record.getId(), \"eng\", FormatType.xml, \"iso19139\", true, FormatterWidth._100);\n312   \n313                   final FormatterApi.FormatMetadata formatMetadata =\n314                       new FormatterApi().new FormatMetadata(context, key, null);\n315                   final byte[] data = formatMetadata.call().data;\n316                   mdToValidate = new String(data, StandardCharsets.UTF_8);\n317               } catch (Exception ex) {\n318                   Log.error(API.LOG_MODULE_NAME,\n319                       String.format(\"Error converting metadata %s to ISO19139 for INSPIRE validator: %s\",\n320                           record.getUuid(), ex.getMessage()), ex);\n321               }\n322           } else {\n323               mdToValidate = record.getData();\n324           }\n325   \n326           return mdToValidate;\n327       }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/FormatterApi.java:\n774           @Override\n775           public StoreInfoAndDataLoadResult call() throws Exception {\n776               serviceContext.setAsThreadLocal();\n777   \n778               Pair<FormatterImpl, FormatterParams> result =\n779                   loadMetadataAndCreateFormatterAndParams(serviceContext, key, request);\n780               FormatterImpl formatter = result.one();\n781               FormatterParams fparams = result.two();\n782               final String formattedMetadata = formatter.format(fparams);\n783               byte[] bytes = formattedMetadata.getBytes(Constants.CHARSET);\n784               long changeDate = fparams.metadataInfo.getDataInfo().getChangeDate().toDate().getTime();\n785               final Specification<OperationAllowed> isPublished = OperationAllowedSpecs.isPublic(ReservedOperation.view);\n786               final Specification<OperationAllowed> hasMdId = OperationAllowedSpecs.hasMetadataId(key.mdId);\n787               final Optional<OperationAllowed> one = serviceContext.getBean(OperationAllowedRepository.class).findOne(where(hasMdId).and(isPublished));\n788               final boolean isPublishedMd = one.isPresent();\n789   \n790               Key withheldKey = null;\n791               FormatMetadata loadWithheld = null;\n792               if (!key.hideWithheld && isPublishedMd) {\n793                   withheldKey = new Key(key.mdId, key.lang, key.formatType, key.formatterId, true, key.width);\n794                   loadWithheld = new FormatMetadata(serviceContext, withheldKey, request);\n795               }\n796               return new StoreInfoAndDataLoadResult(bytes, changeDate, isPublishedMd, withheldKey, loadWithheld);\n797           }\n\nsrc/geonetwork/services/src/main/java/org/fao/geonet/api/records/formatters/XsltFormatter.java:\n 90       public String format(FormatterParams fparams) throws Exception {\n 91   \n 92           String lang = fparams.config.getLang(fparams.context.getLanguage());\n 93   \n 94           Element root = new Element(\"root\");\n 95   \n 96           SettingManager settingManager = ApplicationContextHolder.get().getBean(SettingManager.class);\n 97   \n 98           root.addContent(new Element(\"lang\").setText(fparams.context.getLanguage()));\n 99           root.addContent(new Element(\"url\").setText(fparams.url));\n100           // FIXME: This is a hack to mimic what Jeeves service are doing.\n101           // Some XSLT are used by both formatters and Jeeves and Spring MVC services\n102           Element translations = new Element(\"translations\");\n103           Element gui = new Element(\"gui\");\n104           gui.addContent(new Element(\"url\").setText(fparams.url + \"../..\"));\n105           gui.addContent(new Element(\"nodeUrl\").setText(settingManager.getNodeURL()));\n106           gui.addContent(new Element(\"baseUrl\").setText(settingManager.getBaseURL()));\n107           gui.addContent(new Element(\"serverUrl\").setText(settingManager.getServerURL()));\n108           gui.addContent(new Element(\"language\").setText(fparams.context.getLanguage()));\n109           gui.addContent(new Element(\"reqService\").setText(\"md.format.html\"));\n110           Element env = new Element(\"systemConfig\");\n111           env.addContent(settingManager.getAllAsXML(true));\n112           gui.addContent(env);\n113           root.addContent(gui);\n114   \n115   \n116           root.addContent(new Element(\"locUrl\").setText(fparams.getLocUrl()));\n117   \n118           root.addContent(new Element(\"resourceUrl\").setText(fparams.getResourceUrl()));\n119           // TODO: It could be easier to put the metadata\n120           // record in a metadata tag so it will be easier to pick\n121           // it up with xpath whatever the standard is.\n122           root.addContent(fparams.metadata);\n123   \n124           // Add metadata information (ie. harvested, categories, schema, dates, ...)\n125           Element info = fparams.metadataInfo.asXml();\n126           // metadataInfo contains the XML in data which is not needed\n127           info.removeChild(\"data\");\n128           root.addContent(new Element(\"info\")\n129               .addContent(info));\n130   \n131           root.addContent(fparams.format.getPluginLocResources(fparams.context, fparams.formatDir, lang));\n132           if (fparams.config.loadStrings()) {\n133               root.addContent(fparams.format.getStrings(fparams.context.getAppPath(), lang));\n134           }\n135   \n136           Element schemas = new Element(\"schemas\");\n137           root.addContent(schemas);\n138   \n139           List<String> schemasToLoadList = fparams.config.listOfSchemasToLoad();\n140   \n141           String schemasToLoad = fparams.config.schemasToLoad();\n142           if (!\"none\".equalsIgnoreCase(schemasToLoad)) {\n143               List<Element> elementList = getSchemaLocalization(\n144                   schemasToLoad, schemasToLoadList, fparams.context.getLanguage());\n145               for (Element e : elementList) {\n146                   schemas.addContent(e);\n147               }\n148           }\n149           if (!\"false\".equalsIgnoreCase(fparams.param(\"debug\", \"false\"))) {\n150               return Xml.getString(root);\n151           }\n152   \n153           // Create a map of request parameters to be passed to the XSL transformation\n154           // For a formatter to retrieve a request parameter\n155           // an xsl:param should be defined\n156           // eg. <xsl:param name=\"view\"/>\n157           Map<String, Object> requestParameters = new HashMap<String, Object>();\n158   \n159           if (fparams.webRequest != null) {\n160               Iterator<String> iterator = fparams.webRequest.getParameterMap().keySet().iterator();\n161               while (iterator.hasNext()) {\n162                   String key = iterator.next();\n163                   requestParameters.put(key, fparams.webRequest.getParameterMap().get(key));\n164               }\n165           }\n166           Element transformed = Xml.transform(root, fparams.viewFile, requestParameters);\n167           return \"textResponse\".equals(transformed.getName()) ?\n168               transformed.getTextNormalize() :\n169               Xml.getString(transformed);\n170       }\n\nsrc/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:\n 58       private static Element asXml(Object obj, IdentityHashMap<Object, Void> alreadyEncoded, Set<String> exclude) {\n 59           alreadyEncoded.put(obj, null);\n 60           Element record = new Element(RECORD_EL_NAME);\n 61   \n 62           Class<? extends Object> objclass = obj.getClass();\n 63           while (objclass != null) {\n 64               for (Method method : objclass.getDeclaredMethods()) {\n 65                   try {\n 66                       if (shouldBeAdded(exclude, objclass, method)) {\n 67                           // Then process all getters\n 68                           if (isGetter(method)) {\n 69                               final String descName = method.getName().substring(3);\n 70   \n 71                               if (isLabel(descName) && !objclass.equals(Localized.class)) {\n 72                                   addLabels(obj, record, method);\n 73                               } else if (!isADuplicatedMethodWithAnotherReturnType(descName) && !isLabel(descName)) {\n 74                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 75                               }\n 76   \n 77                           } else if (isBooleanGetter(method)) {\n 78                               final String descName = method.getName().substring(2);\n 79   \n 80                               if (!isADuplicatedMethodWithAnotherReturnType(descName)) {\n 81                                   addPropertyToElement(obj, alreadyEncoded, exclude, record, method, descName);\n 82                               }\n 83                           }\n 84                       }\n 85                   } catch (InvalidPropertyException e) {\n 86                       // just ignore it and get to the following property\n 87                   } catch (Exception e) {\n 88                       // e.printStackTrace();\n 89                       throw new RuntimeException(e);\n 90                   }\n 91               }\n 92   \n 93               // Iterate over the parent classes of the object\n 94               objclass = getNextSignificantAncestor(objclass);\n 95           }\n 96           return record;\n 97       }\n 99       protected static void addLabels(Object obj, Element record, Method method) throws IllegalAccessException, InvocationTargetException {\n100           Element labelEl = new Element(LABEL_EL_NAME);\n101   \n102           @SuppressWarnings(\"unchecked\")\n103           Map<String, String> labels = (Map<String, String>) method.invoke(obj);\n104   \n105           if (labels != null) {\n106               for (Map.Entry<String, String> entry : labels.entrySet()) {\n107                   labelEl.addContent(new Element(entry.getKey().toLowerCase()).setText(entry.getValue()));\n108               }\n109           }\n110   \n111           record.addContent(labelEl);\n112       }\n254       @Nonnull\n255       public final Element asXml() {\n256           IdentityHashMap<Object, Void> alreadyEncoded = new IdentityHashMap<Object, Void>();\n257   \n258           Element record = asXml(alreadyEncoded);\n259   \n260           return record;\n261       }\n273       protected Element asXml(IdentityHashMap<Object, Void> alreadyEncoded) {\n274           return asXml(this, alreadyEncoded, propertiesToExcludeFromXml());\n275       }\n",
            "cost": 0.153445,
            "harness_id": "GeonetworkOne",
            "sanitizer": "Script Engine Injection",
            "sink": "src/geonetwork/domain/src/main/java/org/fao/geonet/domain/GeonetEntity.java:103:60",
            "status": "corpus",
            "valid_path": "NO",
            "id": 68
        }
    ],
    "result": [
        {
            "harness_id": "GeonetworkOne",
            "blob": [
                "",
                "CiAgICA8cm9vdD4KICAgICAgICA8Z2VuZXJhbD4KICAgICAgICAgICAgPHV1aWQ+dGVzdC11dWlkPC91dWlkPgogICAgICAgICAgICA8bWV0YWRhdGFpZD57Lip9PC9tZXRhZGF0YWlkPgogICAgICAgICAgICA8ZmlsZW5hbWU+ZXhhbXBsZS54bWw8L2ZpbGVuYW1lPgogICAgICAgIDwvZ2VuZXJhbD4KICAgIDwvcm9vdD4KICAgIA==",
                "CiAgICA8cm9vdD4KICAgICAgICA8c2V0dGluZ3M+CiAgICAgICAgICAgIDxzZXR0aW5nPgogICAgICAgICAgICAgICAgPGtleT5TZXR0aW5ncy5NRVRBREFUQV9XT1JLRkxPV19EUkFGVF9XSEVOX0lOX0dST1VQPC9rZXk+CiAgICAgICAgICAgICAgICA8dmFsdWU+Lio8L3ZhbHVlPiA8IS0tIEEgcmVnZXggcGF0dGVybiBpbnRlbmRlZCB0byBtYXRjaCBhbnkgaW5wdXQgLS0+CiAgICAgICAgICAgIDwvc2V0dGluZz4KICAgICAgICA8L3NldHRpbmdzPgogICAgICAgIDxncm91cD4KICAgICAgICAgICAgPG5hbWU+YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYSo8L25hbWU+CiAgICAgICAgPC9ncm91cD4KICAgIDwvcm9vdD4KICAgIA==",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxoYXJ2ZXN0PgogICAgICAgIDxub2RlPgogICAgICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgICAgIDwvbm9kZT4KICAgIDwvaGFydmVzdD4=",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxyb290IHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KICAgICAgICA8ZWxlbWVudCB4bGluazpocmVmPSJodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/cGFyYW09KiZhbm90aGVycGFyYW09dmFsdWUiIC8+CiAgICAgICAgPGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3BhcmFtMT12YWx1ZTEmcGFyYW0yPSomcGFyYW0zPXZhbHVlMyIgLz4KICAgICAgICA8ZWxlbWVudCB4bGluazpocmVmPSJodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/cGFyYW09KiZhbm90aGVycGFyYW09KiIgLz4KICAgIDwvcm9vdD4=",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KICAgIDxyb290PgogICAgICAgIDxtZXRhZGF0YT4KICAgICAgICAgICAgPHJlc291cmNlSWQ+KjwvcmVzb3VyY2VJZD4KICAgICAgICA8L21ldGFkYXRhPgogICAgPC9yb290Pg==",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPGNvbmZpZz4KICAgIDxzaXRlPgogICAgICAgIDxuYW1lPlRlc3QgU2l0ZTwvbmFtZT4KICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPiA8IS0tIEFkanVzdCBwYXRoIGFzIG5lZWRlZCAtLT4KICAgIDwvc2l0ZT4KPC9jb25maWc+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPGhhcnZlc3Rlcj4KICAgIDxwYXJhbXM+CiAgICAgICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KICAgIDwvcGFyYW1zPgogICAgPG5hbWU+VGVzdCBIYXJ2ZXN0ZXI8L25hbWU+CiAgICA8dXVpZD50ZXN0LXV1aWQ8L3V1aWQ+CiAgICA8dHJhbnNsYXRpb25zPgogICAgICAgIDx0cmFuc2xhdGlvbiBsYW5nPSJlbiI+VGVzdCBUcmFuc2xhdGlvbjwvdHJhbnNsYXRpb24+CiAgICA8L3RyYW5zbGF0aW9ucz4KPC9oYXJ2ZXN0ZXI+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8ZWxlbWVudD4KICAgICAgICA8a2V5Pi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2tleT4KICAgIDwvZWxlbWVudD4KPC9yb290Pgo=",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aGFydmVzdGVyPgogICAgICAgIDxwYXJhbXM+CiAgICAgICAgICAgIDxpY29uUGF0aD4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uUGF0aD4KICAgICAgICA8L3BhcmFtcz4KICAgIDwvaGFydmVzdGVyPgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgo8L3Jvb3Q+Cg==",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgPG5hbWU+VGVzdCBIYXJ2ZXN0ZXI8L25hbWU+CiAgICA8dHJhbnNsYXRpb25zPgogICAgICAgIDx0cmFuc2xhdGlvbiBsYW5nPSJlbiI+VGVzdCBIYXJ2ZXN0ZXI8L3RyYW5zbGF0aW9uPgogICAgPC90cmFuc2xhdGlvbnM+Cjwvcm9vdD4=",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8bWV0YWRhdGEgc2NoZW1hPSJ1bmF1dGhvcml6ZWQqc2NoZW1hIj4KICAgICAgICA8dXVpZD4xMjM0LTU2NzgtOTBhYi1jZGVmPC91dWlkPgogICAgICAgIDxlbGVtZW50PlRlc3Q8L2VsZW1lbnQ+CiAgICAgICAgPGFkZGl0aW9uYWxFbGVtZW50PlRyaWdnZXI8L2FkZGl0aW9uYWxFbGVtZW50PgogICAgPC9tZXRhZGF0YT4KICAgIDxhZGRpdGlvbmFsUm9vdEVsZW1lbnQ+CiAgICAgICAgPHN1YkVsZW1lbnQ+RW5zdXJlUGF0aDwvc3ViRWxlbWVudD4KICAgIDwvYWRkaXRpb25hbFJvb3RFbGVtZW50Pgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8cGFyYW1zPgogICAgICAgIDxub2RlPgogICAgICAgICAgICA8aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPgogICAgICAgIDwvbm9kZT4KICAgIDwvcGFyYW1zPgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3Q+CiAgICA8dGhlc2F1cnVzPgogICAgICAgIDxrZXk+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwva2V5PgogICAgICAgIDxkbmFtZT5leHBsb2l0PC9kbmFtZT4KICAgICAgICA8ZmlsZW5hbWU+ZXhwbG9pdC54bWw8L2ZpbGVuYW1lPgogICAgICAgIDx0aXRsZT5FeHBsb2l0IFRpdGxlPC90aXRsZT4KICAgICAgICA8bXVsdGlsaW5ndWFsVGl0bGVzPgogICAgICAgICAgICA8bXVsdGlsaW5ndWFsVGl0bGU+CiAgICAgICAgICAgICAgICA8bGFuZz5lbjwvbGFuZz4KICAgICAgICAgICAgICAgIDx0aXRsZT5BY2Nlc3MgdGhpcyBmaWxlOiBqYXp6ZXItdHJhdmVyc2FsPC90aXRsZT4KICAgICAgICAgICAgPC9tdWx0aWxpbmd1YWxUaXRsZT4KICAgICAgICA8L211bHRpbGluZ3VhbFRpdGxlcz4KICAgIDwvdGhlc2F1cnVzPgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3QgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPG1ldGFkYXRhIHhsaW5rOmhyZWY9Imh0dHA6Ly9qYXp6ZXIuZXhhbXBsZS5jb20vdnVsbmVyYWJsZSIgeGxpbms6c2hvdz0icmVwbGFjZSI+CiAgICAgICAgPHV1aWQ+ZXhwbG9pdC11dWlkPC91dWlkPgogICAgICAgIDxzY2hlbWE+ZXhhbXBsZS1zY2hlbWE8L3NjaGVtYT4KICAgICAgICA8Y3JlYXRlRGF0ZT4yMDIzLTAxLTAxVDAwOjAwOjAwPC9jcmVhdGVEYXRlPgogICAgPC9tZXRhZGF0YT4KPC9yb290Pg==",
                "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHJvb3QgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3F1ZXJ5PS4qIj4KICAgICAgICA8c3ViZWxlbWVudD5UZXN0IFJlZ2V4IEluamVjdGlvbiBwb3NzaWJpbGl0eSB3aXRoIHRoaXMgc3ltYm9sOiAqPC9zdWJlbGVtZW50PgogICAgPC9lbGVtZW50Pgo8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+CiAgICA8IURPQ1RZUEUgcm9vdCBbCiAgICA8IUVOVElUWSBmaWxlIFNZU1RFTSAiZmlsZTovLy9ldGMvcGFzc3dkIj4KICAgIF0+CiAgICA8cm9vdD4KICAgICAgICA8ZWxlbWVudD4KICAgICAgICAgICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KICAgICAgICA8L2VsZW1lbnQ+CiAgICA8L3Jvb3Q+",
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+CiAgICA8bWV0YWRhdGE+CiAgICAgICAgPHV1aWQ+MTIzNC01Njc4LTkxMDEtMTEyMTwvdXVpZD4KICAgICAgICA8cmVzb3VyY2U+CiAgICAgICAgICAgIDxuYW1lPmJhZGZpbGUueG1sPC9uYW1lPgogICAgICAgICAgICA8Y29udGVudD4uKjwvY29udGVudD4gPCEtLSBJbmplY3RpbmcgcmVnZXggc3BlY2lhbCBjaGFyYWN0ZXIgaGVyZSAtLT4KICAgICAgICA8L3Jlc291cmNlPgogICAgICAgIDxkZXRhaWxzPgogICAgICAgICAgICA8aW5mbz4oLiopPC9pbmZvPgogICAgICAgICAgICA8c2NoZW1hPlsuKl08L3NjaGVtYT4KICAgICAgICAgICAgPHZlcnNpb24+KjwvdmVyc2lvbj4gPCEtLSBJbmplY3RpbmcgcmVnZXggc3BlY2lhbCBjaGFyYWN0ZXIgaGVyZSAtLT4KICAgICAgICA8L2RldGFpbHM+CiAgICA8L21ldGFkYXRhPg==",
                "PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxyb290PgogICAgPGljb24+Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vamF6emVyLXRyYXZlcnNhbDwvaWNvbj4KPC9yb290Pg==",
                "PG1ldGFkYXRhIHhtbG5zPSJodHRwOi8vZXhhbXBsZS5jb20vc2NoZW1hIj48dGVzdEVsZW1lbnQgeG1sbnM9Imh0dHA6Ly9leGFtcGxlLmNvbS9zY2hlbWEiPjxwYXR0ZXJuRWxlbWVudD4uKi4qLiouKi4qPC9wYXR0ZXJuRWxlbWVudD48L3Rlc3RFbGVtZW50PjwvbWV0YWRhdGE+",
                "PG1ldGFkYXRhPjxlbnRpdHk+PHByb3BlcnR5IG5hbWU9InZ1bG5lcmFibGVQcm9wZXJ0eSI+IiJqYXoiKyJ6ZXIiIjwvcHJvcGVydHk+PC9lbnRpdHk+PC9tZXRhZGF0YT4=",
                "PGNvbmZpZz48cGFyYW1zPjxpY29uPi4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2ljb24+PC9wYXJhbXM+PC9jb25maWc+",
                "PHJvb3Q+CiAgICAgICAgPHNpdGU+CiAgICAgICAgICAgIDx1cmw+aHR0cDovL2V4YW1wbGUuY29tPC91cmw+CiAgICAgICAgICAgIDxpY29uPmljb24ucG5nPC9pY29uPgogICAgICAgICAgICA8eHNsZmlsdGVyPmZpbHRlci54c2w8L3hzbGZpbHRlcj4KICAgICAgICA8L3NpdGU+CiAgICAgICAgPHNlYXJjaGVzPgogICAgICAgICAgICA8c2VhcmNoPgogICAgICAgICAgICAgICAgPGZyb20+MjAyMSoxMiozMTwvZnJvbT4KICAgICAgICAgICAgICAgIDx1bnRpbD4yMDIxKjEyKjMxPC91bnRpbD4KICAgICAgICAgICAgICAgIDxzZXQ+c2V0MTwvc2V0PgogICAgICAgICAgICAgICAgPHByZWZpeD5vYWlfZGM8L3ByZWZpeD4KICAgICAgICAgICAgICAgIDxzdHlsZXNoZWV0PnN0eWxlLnhzbDwvc3R5bGVzaGVldD4KICAgICAgICAgICAgPC9zZWFyY2g+CiAgICAgICAgPC9zZWFyY2hlcz4KICAgIDwvcm9vdD4=",
                "PHJvb3Q+PGVsZW1lbnQgeGxpbms6aHJlZj0iaHR0cDovL2V4YW1wbGUuY29tL3Jlc291cmNlP3BhcmFtPSYmJiYiLz48L3Jvb3Q+",
                "PHJvb3Q+PGVudGl0eT48cHJvcGVydHkgZGVzY05hbWU9InZ1bG5lcmFibGVQcm9wZXJ0eSI+IiJqYXoiKyJ6ZXIiIjwvcHJvcGVydHk+PC9lbnRpdHk+PC9yb290Pg==",
                "PHJvb3Q+PGVudGl0eT48cHJvcGVydHkgbmFtZT0idnVsbmVyYWJsZVByb3BlcnR5Ij4iImpheiIrInplciIiPC9wcm9wZXJ0eT48L2VudGl0eT48L3Jvb3Q+",
                "PHJvb3Q+PGhhcnZlc3Rlcj48cGFyYW1zPjxpY29uPi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2phenplci10cmF2ZXJzYWw8L2ljb24+PC9wYXJhbXM+PC9oYXJ2ZXN0ZXI+PC9yb290Pg==",
                "PHJvb3Q+PHBhcmFtcz48aWNvbj4uLi8uLi8uLi8uLi8uLi8uLi9qYXp6ZXItdHJhdmVyc2FsPC9pY29uPjwvcGFyYW1zPjwvcm9vdD4=",
                "UEsDBBQAAAAIAFKdK1qZLHPbVwAAAIEAAAAIAAAAaW5mby54bWxdjUEKgDAMBF9kQ/FUCPlLrFErqUpbPfT1gmgPwpyWWQajFB65MOEsmyRWwuwXiUwh79bZ3iG8A0JTjnPQ4AmnoELGwI+Va5XUlcSXpMyK8IgI3w9a9gZQSwMEFAAAAAgAUp0rWvglsK4VAAAAFQAAABAAAABwdWJsaWMvZHVtbXkudHh0C8nILFYAokSFlNLc3EqFtMycVD0AUEsBAhQDFAAAAAgAUp0rWpksc9tXAAAAgQAAAAgAAAAAAAAAAAAAAIABAAAAAGluZm8ueG1sUEsBAhQDFAAAAAgAUp0rWvglsK4VAAAAFQAAABAAAAAAAAAAAAAAAIABfQAAAHB1YmxpYy9kdW1teS50eHRQSwUGAAAAAAIAAgB0AAAAwAAAAAAA"
            ]
        }
    ]
}