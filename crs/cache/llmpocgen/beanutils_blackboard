{
    "sinks": {
        "load arbitrary library": [
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/JDBCDynaClass.java",
                "line": 161,
                "column": 34
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java",
                "line": 515,
                "column": 50
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java",
                "line": 524,
                "column": 46
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/ResultSetDynaClass.java",
                "line": 242,
                "column": 58
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java",
                "line": 95,
                "column": 60
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java",
                "line": 104,
                "column": 52
            }
        ],
        "Script Engine Injection": [
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanMap.java",
                "line": 415,
                "column": 28
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanMap.java",
                "line": 415,
                "column": 43
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanMap.java",
                "line": 457,
                "column": 17
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanMap.java",
                "line": 457,
                "column": 32
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java",
                "line": 1055,
                "column": 17
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java",
                "line": 1055,
                "column": 42
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 278,
                "column": 16
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 278,
                "column": 30
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 402,
                "column": 16
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 402,
                "column": 30
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 452,
                "column": 16
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 452,
                "column": 30
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 601,
                "column": 16
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java",
                "line": 601,
                "column": 30
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java",
                "line": 2127,
                "column": 20
            },
            {
                "path": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java",
                "line": 2127,
                "column": 34
            }
        ]
    },
    "tasks": [
        {
            "blob": [
                "AAAAAQAAABUAAAA7amF2YS5sYW5nLlN5c3RlbQBnZXRQcm9wZXJ0eQBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 416       public Object getIndexedProperty(final Object bean, String name)\n 417               throws IllegalAccessException, InvocationTargetException,\n 418               NoSuchMethodException {\n 419   \n 420           if (bean == null) {\n 421               throw new IllegalArgumentException(\"No bean specified\");\n 422           }\n 423           if (name == null) {\n 424               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 425                       bean.getClass() + \"'\");\n 426           }\n 427   \n 428           // Identify the index of the requested individual property\n 429           int index = -1;\n 430           try {\n 431               index = resolver.getIndex(name);\n 432           } catch (final IllegalArgumentException e) {\n 433               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 434                       name + \"' on bean class '\" + bean.getClass() + \"' \" +\n 435                       e.getMessage());\n 436           }\n 437           if (index < 0) {\n 438               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 439                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 440           }\n 441   \n 442           // Isolate the name\n 443           name = resolver.getProperty(name);\n 444   \n 445           // Request the specified indexed property value\n 446           return (getIndexedProperty(bean, name, index));\n 447   \n 448       }\n 473       public Object getIndexedProperty(final Object bean,\n 474                                               final String name, final int index)\n 475               throws IllegalAccessException, InvocationTargetException,\n 476               NoSuchMethodException {\n 477   \n 478           if (bean == null) {\n 479               throw new IllegalArgumentException(\"No bean specified\");\n 480           }\n 481           if (name == null || name.length() == 0) {\n 482               if (bean.getClass().isArray()) {\n 483                   return Array.get(bean, index);\n 484               } else if (bean instanceof List) {\n 485                   return ((List<?>)bean).get(index);\n 486               }\n 487           }\n 488           if (name == null) {\n 489               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 490                       bean.getClass() + \"'\");\n 491           }\n 492   \n 493           // Handle DynaBean instances specially\n 494           if (bean instanceof DynaBean) {\n 495               final DynaProperty descriptor =\n 496                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n 497               if (descriptor == null) {\n 498                   throw new NoSuchMethodException(\"Unknown property '\" +\n 499                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 500               }\n 501               return (((DynaBean) bean).get(name, index));\n 502           }\n 503   \n 504           // Retrieve the property descriptor for the specified property\n 505           final PropertyDescriptor descriptor =\n 506                   getPropertyDescriptor(bean, name);\n 507           if (descriptor == null) {\n 508               throw new NoSuchMethodException(\"Unknown property '\" +\n 509                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 510           }\n 511   \n 512           // Call the indexed getter method if there is one\n 513           if (descriptor instanceof IndexedPropertyDescriptor) {\n 514               Method readMethod = ((IndexedPropertyDescriptor) descriptor).\n 515                       getIndexedReadMethod();\n 516               readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);\n 517               if (readMethod != null) {\n 518                   final Object[] subscript = new Object[1];\n 519                   subscript[0] = new Integer(index);\n 520                   try {\n 521                       return (invokeMethod(readMethod,bean, subscript));\n 522                   } catch (final InvocationTargetException e) {\n 523                       if (e.getTargetException() instanceof\n 524                               IndexOutOfBoundsException) {\n 525                           throw (IndexOutOfBoundsException)\n 526                                   e.getTargetException();\n 527                       } else {\n 528                           throw e;\n 529                       }\n 530                   }\n 531               }\n 532           }\n 533   \n 534           // Otherwise, the underlying property must be an array\n 535           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n 536           if (readMethod == null) {\n 537               throw new NoSuchMethodException(\"Property '\" + name + \"' has no \" +\n 538                       \"getter method on bean class '\" + bean.getClass() + \"'\");\n 539           }\n 540   \n 541           // Call the property getter and return the value\n 542           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n 543           if (!value.getClass().isArray()) {\n 544               if (!(value instanceof java.util.List)) {\n 545                   throw new IllegalArgumentException(\"Property '\" + name +\n 546                           \"' is not indexed on bean class '\" + bean.getClass() + \"'\");\n 547               } else {\n 548                   //get the List's value\n 549                   return ((java.util.List<?>) value).get(index);\n 550               }\n 551           } else {\n 552               //get the array's value\n 553               try {\n 554                   return (Array.get(value, index));\n 555               } catch (final ArrayIndexOutOfBoundsException e) {\n 556                   throw new ArrayIndexOutOfBoundsException(\"Index: \" +\n 557                           index + \", Size: \" + Array.getLength(value) +\n 558                           \" for property '\" + name + \"'\");\n 559               }\n 560           }\n 561   \n 562       }\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n 919       public PropertyDescriptor getPropertyDescriptor(Object bean,\n 920                                                              String name)\n 921               throws IllegalAccessException, InvocationTargetException,\n 922               NoSuchMethodException {\n 923   \n 924           if (bean == null) {\n 925               throw new IllegalArgumentException(\"No bean specified\");\n 926           }\n 927           if (name == null) {\n 928               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 929                       bean.getClass() + \"'\");\n 930           }\n 931   \n 932           // Resolve nested references\n 933           while (resolver.hasNested(name)) {\n 934               final String next = resolver.next(name);\n 935               final Object nestedBean = getProperty(bean, next);\n 936               if (nestedBean == null) {\n 937                   throw new NestedNullException\n 938                           (\"Null property value for '\" + next +\n 939                           \"' on bean class '\" + bean.getClass() + \"'\");\n 940               }\n 941               bean = nestedBean;\n 942               name = resolver.remove(name);\n 943           }\n 944   \n 945           // Remove any subscript from the final name value\n 946           name = resolver.getProperty(name);\n 947   \n 948           // Look up and return this property from our cache\n 949           // creating and adding it to the cache if not found.\n 950           if (name == null) {\n 951               return (null);\n 952           }\n 953   \n 954           final BeanIntrospectionData data = getIntrospectionData(bean.getClass());\n 955           PropertyDescriptor result = data.getDescriptor(name);\n 956           if (result != null) {\n 957               return result;\n 958           }\n 959   \n 960           FastHashMap mappedDescriptors =\n 961                   getMappedPropertyDescriptors(bean);\n 962           if (mappedDescriptors == null) {\n 963               mappedDescriptors = new FastHashMap();\n 964               mappedDescriptors.setFast(true);\n 965               mappedDescriptorsCache.put(bean.getClass(), mappedDescriptors);\n 966           }\n 967           result = (PropertyDescriptor) mappedDescriptors.get(name);\n 968           if (result == null) {\n 969               // not found, try to create it\n 970               try {\n 971                   result = new MappedPropertyDescriptor(name, bean.getClass());\n 972               } catch (final IntrospectionException ie) {\n 973                   /* Swallow IntrospectionException\n 974                    * TODO: Why?\n 975                    */\n 976               }\n 977               if (result != null) {\n 978                   mappedDescriptors.put(name, result);\n 979               }\n 980           }\n 981   \n 982           return result;\n 983   \n 984       }\n1201       Method getReadMethod(final Class<?> clazz, final PropertyDescriptor descriptor) {\n1202           return (MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod()));\n1203       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n2218       private BeanIntrospectionData getIntrospectionData(final Class<?> beanClass) {\n2219           if (beanClass == null) {\n2220               throw new IllegalArgumentException(\"No bean class specified\");\n2221           }\n2222   \n2223           // Look up any cached information for this bean class\n2224           BeanIntrospectionData data = descriptorsCache.get(beanClass);\n2225           if (data == null) {\n2226               data = fetchIntrospectionData(beanClass);\n2227               descriptorsCache.put(beanClass, data);\n2228           }\n2229   \n2230           return data;\n2231       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/expression/DefaultResolver.java:\n 79       public int getIndex(final String expression) {\n 80           if (expression == null || expression.length() == 0) {\n 81               return -1;\n 82           }\n 83           for (int i = 0; i < expression.length(); i++) {\n 84               final char c = expression.charAt(i);\n 85               if (c == NESTED || c == MAPPED_START) {\n 86                   return -1;\n 87               } else if (c == INDEXED_START) {\n 88                   final int end = expression.indexOf(INDEXED_END, i);\n 89                   if (end < 0) {\n 90                       throw new IllegalArgumentException(\"Missing End Delimiter\");\n 91                   }\n 92                   final String value = expression.substring(i + 1, end);\n 93                   if (value.length() == 0) {\n 94                       throw new IllegalArgumentException(\"No Index Value\");\n 95                   }\n 96                   int index = 0;\n 97                   try {\n 98                       index = Integer.parseInt(value, 10);\n 99                   } catch (final Exception e) {\n100                       throw new IllegalArgumentException(\"Invalid index value '\"\n101                               + value + \"'\");\n102                   }\n103                   return index;\n104               }\n105           }\n106           return -1;\n107       }\n163       public boolean hasNested(final String expression) {\n164           if (expression == null || expression.length() == 0) {\n165               return false;\n166           } else {\n167               return (remove(expression) != null);\n168           }\n169       }\n178       public boolean isIndexed(final String expression) {\n179           if (expression == null || expression.length() == 0) {\n180               return false;\n181           }\n182           for (int i = 0; i < expression.length(); i++) {\n183               final char c = expression.charAt(i);\n184               if (c == NESTED || c == MAPPED_START) {\n185                   return false;\n186               } else if (c == INDEXED_START) {\n187                   return true;\n188               }\n189           }\n190           return false;\n191       }\n200       public boolean isMapped(final String expression) {\n201           if (expression == null || expression.length() == 0) {\n202               return false;\n203           }\n204           for (int i = 0; i < expression.length(); i++) {\n205               final char c = expression.charAt(i);\n206               if (c == NESTED || c == INDEXED_START) {\n207                   return false;\n208               } else if (c == MAPPED_START) {\n209                   return true;\n210               }\n211           }\n212           return false;\n213       }\n222       public String next(final String expression) {\n223           if (expression == null || expression.length() == 0) {\n224               return null;\n225           }\n226           boolean indexed = false;\n227           boolean mapped  = false;\n228           for (int i = 0; i < expression.length(); i++) {\n229               final char c = expression.charAt(i);\n230               if (indexed) {\n231                   if (c == INDEXED_END) {\n232                       return expression.substring(0, i + 1);\n233                   }\n234               } else if (mapped) {\n235                   if (c == MAPPED_END) {\n236                       return expression.substring(0, i + 1);\n237                   }\n238               } else {\n239                   if (c == NESTED) {\n240                       return expression.substring(0, i);\n241                   } else if (c == MAPPED_START) {\n242                       mapped = true;\n243                   } else if (c == INDEXED_START) {\n244                       indexed = true;\n245                   }\n246               }\n247           }\n248           return expression;\n249       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/WeakFastHashMap.java:\n155       @Override\n156       public V get(final Object key) {\n157           if (fast) {\n158               return (map.get(key));\n159           } else {\n160               synchronized (map) {\n161                   return (map.get(key));\n162               }\n163           }\n164       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanIntrospectionData.java:\n 79       public PropertyDescriptor[] getDescriptors() {\n 80           return descriptors;\n 81       }\n 90       public PropertyDescriptor getDescriptor(final String name) {\n 91           for (final PropertyDescriptor pd : getDescriptors()) {\n 92               if (name.equals(pd.getName())) {\n 93                   return pd;\n 94               }\n 95           }\n 96           return null;\n 97       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java:\n 774       public static Method getAccessibleMethod(Class<?> clazz, Method method) {\n 775   \n 776           // Make sure we have a method to check\n 777           if (method == null) {\n 778               return (null);\n 779           }\n 780   \n 781           // If the requested method is not public we cannot call it\n 782           if (!Modifier.isPublic(method.getModifiers())) {\n 783               return (null);\n 784           }\n 785   \n 786           boolean sameClass = true;\n 787           if (clazz == null) {\n 788               clazz = method.getDeclaringClass();\n 789           } else {\n 790               sameClass = clazz.equals(method.getDeclaringClass());\n 791               if (!method.getDeclaringClass().isAssignableFrom(clazz)) {\n 792                   throw new IllegalArgumentException(clazz.getName() +\n 793                           \" is not assignable from \" + method.getDeclaringClass().getName());\n 794               }\n 795           }\n 796   \n 797           // If the class is public, we are done\n 798           if (Modifier.isPublic(clazz.getModifiers())) {\n 799               if (!sameClass && !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n 800                   setMethodAccessible(method); // Default access superclass workaround\n 801               }\n 802               return (method);\n 803           }\n 804   \n 805           final String methodName      = method.getName();\n 806           final Class<?>[] parameterTypes = method.getParameterTypes();\n 807   \n 808           // Check the implemented interfaces and subinterfaces\n 809           method =\n 810                   getAccessibleMethodFromInterfaceNest(clazz,\n 811                           methodName,\n 812                           parameterTypes);\n 813   \n 814           // Check the superclass chain\n 815           if (method == null) {\n 816               method = getAccessibleMethodFromSuperclass(clazz,\n 817                           methodName,\n 818                           parameterTypes);\n 819           }\n 820   \n 821           return (method);\n 822       }\n 867       private static Method getAccessibleMethodFromInterfaceNest\n 868               (Class<?> clazz, final String methodName, final Class<?>[] parameterTypes) {\n 869   \n 870           Method method = null;\n 871   \n 872           // Search up the superclass chain\n 873           for (; clazz != null; clazz = clazz.getSuperclass()) {\n 874   \n 875               // Check the implemented interfaces of the parent class\n 876               final Class<?>[] interfaces = clazz.getInterfaces();\n 877               for (int i = 0; i < interfaces.length; i++) {\n 878   \n 879                   // Is this interface public?\n 880                   if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n 881                       continue;\n 882                   }\n 883   \n 884                   // Does the method exist on this interface?\n 885                   try {\n 886                       method = interfaces[i].getDeclaredMethod(methodName,\n 887                               parameterTypes);\n 888                   } catch (final NoSuchMethodException e) {\n 889                       /* Swallow, if no method is found after the loop then this\n 890                        * method returns null.\n 891                        */\n 892                   }\n 893                   if (method != null) {\n 894                       return method;\n 895                   }\n 896   \n 897                   // Recursively check our parent interfaces\n 898                   method =\n 899                           getAccessibleMethodFromInterfaceNest(interfaces[i],\n 900                                   methodName,\n 901                                   parameterTypes);\n 902                   if (method != null) {\n 903                       return method;\n 904                   }\n 905   \n 906               }\n 907   \n 908           }\n 909   \n 910           // We did not find anything\n 911           return (null);\n 912       }\n",
            "cost": 1.199685,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:34",
            "status": "corpus",
            "valid_path": "YES",
            "id": 1
        },
        {
            "blob": [
                "AAAAAQAAABUAAABGamF2YS5sYW5nLkNsYXNzTG9hZGVyAGphdmEubGFuZy5SdW50aW1lAGphdmEubGFuZy5TdHJpbmcAIiJqYXoiKyJ6ZXIiIg=="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 416       public Object getIndexedProperty(final Object bean, String name)\n 417               throws IllegalAccessException, InvocationTargetException,\n 418               NoSuchMethodException {\n 419   \n 420           if (bean == null) {\n 421               throw new IllegalArgumentException(\"No bean specified\");\n 422           }\n 423           if (name == null) {\n 424               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 425                       bean.getClass() + \"'\");\n 426           }\n 427   \n 428           // Identify the index of the requested individual property\n 429           int index = -1;\n 430           try {\n 431               index = resolver.getIndex(name);\n 432           } catch (final IllegalArgumentException e) {\n 433               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 434                       name + \"' on bean class '\" + bean.getClass() + \"' \" +\n 435                       e.getMessage());\n 436           }\n 437           if (index < 0) {\n 438               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 439                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 440           }\n 441   \n 442           // Isolate the name\n 443           name = resolver.getProperty(name);\n 444   \n 445           // Request the specified indexed property value\n 446           return (getIndexedProperty(bean, name, index));\n 447   \n 448       }\n 473       public Object getIndexedProperty(final Object bean,\n 474                                               final String name, final int index)\n 475               throws IllegalAccessException, InvocationTargetException,\n 476               NoSuchMethodException {\n 477   \n 478           if (bean == null) {\n 479               throw new IllegalArgumentException(\"No bean specified\");\n 480           }\n 481           if (name == null || name.length() == 0) {\n 482               if (bean.getClass().isArray()) {\n 483                   return Array.get(bean, index);\n 484               } else if (bean instanceof List) {\n 485                   return ((List<?>)bean).get(index);\n 486               }\n 487           }\n 488           if (name == null) {\n 489               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 490                       bean.getClass() + \"'\");\n 491           }\n 492   \n 493           // Handle DynaBean instances specially\n 494           if (bean instanceof DynaBean) {\n 495               final DynaProperty descriptor =\n 496                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n 497               if (descriptor == null) {\n 498                   throw new NoSuchMethodException(\"Unknown property '\" +\n 499                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 500               }\n 501               return (((DynaBean) bean).get(name, index));\n 502           }\n 503   \n 504           // Retrieve the property descriptor for the specified property\n 505           final PropertyDescriptor descriptor =\n 506                   getPropertyDescriptor(bean, name);\n 507           if (descriptor == null) {\n 508               throw new NoSuchMethodException(\"Unknown property '\" +\n 509                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 510           }\n 511   \n 512           // Call the indexed getter method if there is one\n 513           if (descriptor instanceof IndexedPropertyDescriptor) {\n 514               Method readMethod = ((IndexedPropertyDescriptor) descriptor).\n 515                       getIndexedReadMethod();\n 516               readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);\n 517               if (readMethod != null) {\n 518                   final Object[] subscript = new Object[1];\n 519                   subscript[0] = new Integer(index);\n 520                   try {\n 521                       return (invokeMethod(readMethod,bean, subscript));\n 522                   } catch (final InvocationTargetException e) {\n 523                       if (e.getTargetException() instanceof\n 524                               IndexOutOfBoundsException) {\n 525                           throw (IndexOutOfBoundsException)\n 526                                   e.getTargetException();\n 527                       } else {\n 528                           throw e;\n 529                       }\n 530                   }\n 531               }\n 532           }\n 533   \n 534           // Otherwise, the underlying property must be an array\n 535           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n 536           if (readMethod == null) {\n 537               throw new NoSuchMethodException(\"Property '\" + name + \"' has no \" +\n 538                       \"getter method on bean class '\" + bean.getClass() + \"'\");\n 539           }\n 540   \n 541           // Call the property getter and return the value\n 542           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n 543           if (!value.getClass().isArray()) {\n 544               if (!(value instanceof java.util.List)) {\n 545                   throw new IllegalArgumentException(\"Property '\" + name +\n 546                           \"' is not indexed on bean class '\" + bean.getClass() + \"'\");\n 547               } else {\n 548                   //get the List's value\n 549                   return ((java.util.List<?>) value).get(index);\n 550               }\n 551           } else {\n 552               //get the array's value\n 553               try {\n 554                   return (Array.get(value, index));\n 555               } catch (final ArrayIndexOutOfBoundsException e) {\n 556                   throw new ArrayIndexOutOfBoundsException(\"Index: \" +\n 557                           index + \", Size: \" + Array.getLength(value) +\n 558                           \" for property '\" + name + \"'\");\n 559               }\n 560           }\n 561   \n 562       }\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n 919       public PropertyDescriptor getPropertyDescriptor(Object bean,\n 920                                                              String name)\n 921               throws IllegalAccessException, InvocationTargetException,\n 922               NoSuchMethodException {\n 923   \n 924           if (bean == null) {\n 925               throw new IllegalArgumentException(\"No bean specified\");\n 926           }\n 927           if (name == null) {\n 928               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 929                       bean.getClass() + \"'\");\n 930           }\n 931   \n 932           // Resolve nested references\n 933           while (resolver.hasNested(name)) {\n 934               final String next = resolver.next(name);\n 935               final Object nestedBean = getProperty(bean, next);\n 936               if (nestedBean == null) {\n 937                   throw new NestedNullException\n 938                           (\"Null property value for '\" + next +\n 939                           \"' on bean class '\" + bean.getClass() + \"'\");\n 940               }\n 941               bean = nestedBean;\n 942               name = resolver.remove(name);\n 943           }\n 944   \n 945           // Remove any subscript from the final name value\n 946           name = resolver.getProperty(name);\n 947   \n 948           // Look up and return this property from our cache\n 949           // creating and adding it to the cache if not found.\n 950           if (name == null) {\n 951               return (null);\n 952           }\n 953   \n 954           final BeanIntrospectionData data = getIntrospectionData(bean.getClass());\n 955           PropertyDescriptor result = data.getDescriptor(name);\n 956           if (result != null) {\n 957               return result;\n 958           }\n 959   \n 960           FastHashMap mappedDescriptors =\n 961                   getMappedPropertyDescriptors(bean);\n 962           if (mappedDescriptors == null) {\n 963               mappedDescriptors = new FastHashMap();\n 964               mappedDescriptors.setFast(true);\n 965               mappedDescriptorsCache.put(bean.getClass(), mappedDescriptors);\n 966           }\n 967           result = (PropertyDescriptor) mappedDescriptors.get(name);\n 968           if (result == null) {\n 969               // not found, try to create it\n 970               try {\n 971                   result = new MappedPropertyDescriptor(name, bean.getClass());\n 972               } catch (final IntrospectionException ie) {\n 973                   /* Swallow IntrospectionException\n 974                    * TODO: Why?\n 975                    */\n 976               }\n 977               if (result != null) {\n 978                   mappedDescriptors.put(name, result);\n 979               }\n 980           }\n 981   \n 982           return result;\n 983   \n 984       }\n1201       Method getReadMethod(final Class<?> clazz, final PropertyDescriptor descriptor) {\n1202           return (MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod()));\n1203       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n2218       private BeanIntrospectionData getIntrospectionData(final Class<?> beanClass) {\n2219           if (beanClass == null) {\n2220               throw new IllegalArgumentException(\"No bean class specified\");\n2221           }\n2222   \n2223           // Look up any cached information for this bean class\n2224           BeanIntrospectionData data = descriptorsCache.get(beanClass);\n2225           if (data == null) {\n2226               data = fetchIntrospectionData(beanClass);\n2227               descriptorsCache.put(beanClass, data);\n2228           }\n2229   \n2230           return data;\n2231       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/expression/DefaultResolver.java:\n 79       public int getIndex(final String expression) {\n 80           if (expression == null || expression.length() == 0) {\n 81               return -1;\n 82           }\n 83           for (int i = 0; i < expression.length(); i++) {\n 84               final char c = expression.charAt(i);\n 85               if (c == NESTED || c == MAPPED_START) {\n 86                   return -1;\n 87               } else if (c == INDEXED_START) {\n 88                   final int end = expression.indexOf(INDEXED_END, i);\n 89                   if (end < 0) {\n 90                       throw new IllegalArgumentException(\"Missing End Delimiter\");\n 91                   }\n 92                   final String value = expression.substring(i + 1, end);\n 93                   if (value.length() == 0) {\n 94                       throw new IllegalArgumentException(\"No Index Value\");\n 95                   }\n 96                   int index = 0;\n 97                   try {\n 98                       index = Integer.parseInt(value, 10);\n 99                   } catch (final Exception e) {\n100                       throw new IllegalArgumentException(\"Invalid index value '\"\n101                               + value + \"'\");\n102                   }\n103                   return index;\n104               }\n105           }\n106           return -1;\n107       }\n163       public boolean hasNested(final String expression) {\n164           if (expression == null || expression.length() == 0) {\n165               return false;\n166           } else {\n167               return (remove(expression) != null);\n168           }\n169       }\n178       public boolean isIndexed(final String expression) {\n179           if (expression == null || expression.length() == 0) {\n180               return false;\n181           }\n182           for (int i = 0; i < expression.length(); i++) {\n183               final char c = expression.charAt(i);\n184               if (c == NESTED || c == MAPPED_START) {\n185                   return false;\n186               } else if (c == INDEXED_START) {\n187                   return true;\n188               }\n189           }\n190           return false;\n191       }\n200       public boolean isMapped(final String expression) {\n201           if (expression == null || expression.length() == 0) {\n202               return false;\n203           }\n204           for (int i = 0; i < expression.length(); i++) {\n205               final char c = expression.charAt(i);\n206               if (c == NESTED || c == INDEXED_START) {\n207                   return false;\n208               } else if (c == MAPPED_START) {\n209                   return true;\n210               }\n211           }\n212           return false;\n213       }\n222       public String next(final String expression) {\n223           if (expression == null || expression.length() == 0) {\n224               return null;\n225           }\n226           boolean indexed = false;\n227           boolean mapped  = false;\n228           for (int i = 0; i < expression.length(); i++) {\n229               final char c = expression.charAt(i);\n230               if (indexed) {\n231                   if (c == INDEXED_END) {\n232                       return expression.substring(0, i + 1);\n233                   }\n234               } else if (mapped) {\n235                   if (c == MAPPED_END) {\n236                       return expression.substring(0, i + 1);\n237                   }\n238               } else {\n239                   if (c == NESTED) {\n240                       return expression.substring(0, i);\n241                   } else if (c == MAPPED_START) {\n242                       mapped = true;\n243                   } else if (c == INDEXED_START) {\n244                       indexed = true;\n245                   }\n246               }\n247           }\n248           return expression;\n249       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/WeakFastHashMap.java:\n155       @Override\n156       public V get(final Object key) {\n157           if (fast) {\n158               return (map.get(key));\n159           } else {\n160               synchronized (map) {\n161                   return (map.get(key));\n162               }\n163           }\n164       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanIntrospectionData.java:\n 79       public PropertyDescriptor[] getDescriptors() {\n 80           return descriptors;\n 81       }\n 90       public PropertyDescriptor getDescriptor(final String name) {\n 91           for (final PropertyDescriptor pd : getDescriptors()) {\n 92               if (name.equals(pd.getName())) {\n 93                   return pd;\n 94               }\n 95           }\n 96           return null;\n 97       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java:\n 774       public static Method getAccessibleMethod(Class<?> clazz, Method method) {\n 775   \n 776           // Make sure we have a method to check\n 777           if (method == null) {\n 778               return (null);\n 779           }\n 780   \n 781           // If the requested method is not public we cannot call it\n 782           if (!Modifier.isPublic(method.getModifiers())) {\n 783               return (null);\n 784           }\n 785   \n 786           boolean sameClass = true;\n 787           if (clazz == null) {\n 788               clazz = method.getDeclaringClass();\n 789           } else {\n 790               sameClass = clazz.equals(method.getDeclaringClass());\n 791               if (!method.getDeclaringClass().isAssignableFrom(clazz)) {\n 792                   throw new IllegalArgumentException(clazz.getName() +\n 793                           \" is not assignable from \" + method.getDeclaringClass().getName());\n 794               }\n 795           }\n 796   \n 797           // If the class is public, we are done\n 798           if (Modifier.isPublic(clazz.getModifiers())) {\n 799               if (!sameClass && !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n 800                   setMethodAccessible(method); // Default access superclass workaround\n 801               }\n 802               return (method);\n 803           }\n 804   \n 805           final String methodName      = method.getName();\n 806           final Class<?>[] parameterTypes = method.getParameterTypes();\n 807   \n 808           // Check the implemented interfaces and subinterfaces\n 809           method =\n 810                   getAccessibleMethodFromInterfaceNest(clazz,\n 811                           methodName,\n 812                           parameterTypes);\n 813   \n 814           // Check the superclass chain\n 815           if (method == null) {\n 816               method = getAccessibleMethodFromSuperclass(clazz,\n 817                           methodName,\n 818                           parameterTypes);\n 819           }\n 820   \n 821           return (method);\n 822       }\n 867       private static Method getAccessibleMethodFromInterfaceNest\n 868               (Class<?> clazz, final String methodName, final Class<?>[] parameterTypes) {\n 869   \n 870           Method method = null;\n 871   \n 872           // Search up the superclass chain\n 873           for (; clazz != null; clazz = clazz.getSuperclass()) {\n 874   \n 875               // Check the implemented interfaces of the parent class\n 876               final Class<?>[] interfaces = clazz.getInterfaces();\n 877               for (int i = 0; i < interfaces.length; i++) {\n 878   \n 879                   // Is this interface public?\n 880                   if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n 881                       continue;\n 882                   }\n 883   \n 884                   // Does the method exist on this interface?\n 885                   try {\n 886                       method = interfaces[i].getDeclaredMethod(methodName,\n 887                               parameterTypes);\n 888                   } catch (final NoSuchMethodException e) {\n 889                       /* Swallow, if no method is found after the loop then this\n 890                        * method returns null.\n 891                        */\n 892                   }\n 893                   if (method != null) {\n 894                       return method;\n 895                   }\n 896   \n 897                   // Recursively check our parent interfaces\n 898                   method =\n 899                           getAccessibleMethodFromInterfaceNest(interfaces[i],\n 900                                   methodName,\n 901                                   parameterTypes);\n 902                   if (method != null) {\n 903                       return method;\n 904                   }\n 905   \n 906               }\n 907   \n 908           }\n 909   \n 910           // We did not find anything\n 911           return (null);\n 912       }\n",
            "cost": 1.1825599999999998,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:20",
            "status": "corpus",
            "valid_path": "YES",
            "id": 2
        },
        {
            "blob": [
                "AAAAAQAAABUAAABCY2xhc3NMb2FkZXJQcm9wZXJ0eQBqYXp6ZXJfaG9uZXlwb3QAamF2YS5sYW5nLlN0cmluZwB2YWxpZEFyZ3VtZW50"
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 584       public Object getMappedProperty(final Object bean, String name)\n 585               throws IllegalAccessException, InvocationTargetException,\n 586               NoSuchMethodException {\n 587   \n 588           if (bean == null) {\n 589               throw new IllegalArgumentException(\"No bean specified\");\n 590           }\n 591           if (name == null) {\n 592               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 593                       bean.getClass() + \"'\");\n 594           }\n 595   \n 596           // Identify the key of the requested individual property\n 597           String key  = null;\n 598           try {\n 599               key = resolver.getKey(name);\n 600           } catch (final IllegalArgumentException e) {\n 601               throw new IllegalArgumentException\n 602                       (\"Invalid mapped property '\" + name +\n 603                       \"' on bean class '\" + bean.getClass() + \"' \" + e.getMessage());\n 604           }\n 605           if (key == null) {\n 606               throw new IllegalArgumentException(\"Invalid mapped property '\" +\n 607                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 608           }\n 609   \n 610           // Isolate the name\n 611           name = resolver.getProperty(name);\n 612   \n 613           // Request the specified indexed property value\n 614           return (getMappedProperty(bean, name, key));\n 615   \n 616       }\n 635       public Object getMappedProperty(final Object bean,\n 636                                              final String name, final String key)\n 637               throws IllegalAccessException, InvocationTargetException,\n 638               NoSuchMethodException {\n 639   \n 640           if (bean == null) {\n 641               throw new IllegalArgumentException(\"No bean specified\");\n 642           }\n 643           if (name == null) {\n 644               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 645                       bean.getClass() + \"'\");\n 646           }\n 647           if (key == null) {\n 648               throw new IllegalArgumentException(\"No key specified for property '\" +\n 649                       name + \"' on bean class \" + bean.getClass() + \"'\");\n 650           }\n 651   \n 652           // Handle DynaBean instances specially\n 653           if (bean instanceof DynaBean) {\n 654               final DynaProperty descriptor =\n 655                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n 656               if (descriptor == null) {\n 657                   throw new NoSuchMethodException(\"Unknown property '\" +\n 658                           name + \"'+ on bean class '\" + bean.getClass() + \"'\");\n 659               }\n 660               return (((DynaBean) bean).get(name, key));\n 661           }\n 662   \n 663           Object result = null;\n 664   \n 665           // Retrieve the property descriptor for the specified property\n 666           final PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);\n 667           if (descriptor == null) {\n 668               throw new NoSuchMethodException(\"Unknown property '\" +\n 669                       name + \"'+ on bean class '\" + bean.getClass() + \"'\");\n 670           }\n 671   \n 672           if (descriptor instanceof MappedPropertyDescriptor) {\n 673               // Call the keyed getter method if there is one\n 674               Method readMethod = ((MappedPropertyDescriptor) descriptor).\n 675                       getMappedReadMethod();\n 676               readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);\n 677               if (readMethod != null) {\n 678                   final Object[] keyArray = new Object[1];\n 679                   keyArray[0] = key;\n 680                   result = invokeMethod(readMethod, bean, keyArray);\n 681               } else {\n 682                   throw new NoSuchMethodException(\"Property '\" + name +\n 683                           \"' has no mapped getter method on bean class '\" +\n 684                           bean.getClass() + \"'\");\n 685               }\n 686           } else {\n 687             /* means that the result has to be retrieved from a map */\n 688             final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n 689             if (readMethod != null) {\n 690               final Object invokeResult = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n 691               /* test and fetch from the map */\n 692               if (invokeResult instanceof java.util.Map) {\n 693                 result = ((java.util.Map<?, ?>)invokeResult).get(key);\n 694               }\n 695             } else {\n 696               throw new NoSuchMethodException(\"Property '\" + name +\n 697                       \"' has no mapped getter method on bean class '\" +\n 698                       bean.getClass() + \"'\");\n 699             }\n 700           }\n 701           return result;\n 702   \n 703       }\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java:\n237       public Method getMappedReadMethod() {\n238           return mappedReadMethodRef.get();\n239       }\n448           private Method get() {\n449               if (methodRef == null) {\n450                   return null;\n451               }\n452               Method m = methodRef.get();\n453               if (m == null) {\n454                   Class<?> clazz = classRef.get();\n455                   if (clazz == null) {\n456                       clazz = reLoadClass();\n457                       if (clazz != null) {\n458                           classRef = new WeakReference<Class<?>>(clazz);\n459                       }\n460                   }\n461                   if (clazz == null) {\n462                       throw new RuntimeException(\"Method \" + methodName + \" for \" +\n463                               className + \" could not be reconstructed - class reference has gone\");\n464                   }\n465                   Class<?>[] paramTypes = null;\n466                   if (writeParamClassNames != null) {\n467                       paramTypes = new Class[2];\n468                       paramTypes[0] = writeParamTypeRef0.get();\n469                       if (paramTypes[0] == null) {\n470                           paramTypes[0] = reLoadClass(writeParamClassNames[0]);\n471                           if (paramTypes[0] != null) {\n472                               writeParamTypeRef0 = new WeakReference<Class<?>>(paramTypes[0]);\n473                           }\n474                       }\n475                       paramTypes[1] = writeParamTypeRef1.get();\n476                       if (paramTypes[1] == null) {\n477                           paramTypes[1] = reLoadClass(writeParamClassNames[1]);\n478                           if (paramTypes[1] != null) {\n479                               writeParamTypeRef1 = new WeakReference<Class<?>>(paramTypes[1]);\n480                           }\n481                       }\n482                   } else {\n483                       paramTypes = STRING_CLASS_PARAMETER;\n484                   }\n485                   try {\n486                       m = clazz.getMethod(methodName, paramTypes);\n487                       // Un-comment following line for testing\n488                       // System.out.println(\"Recreated Method \" + methodName + \" for \" + className);\n489                   } catch (final NoSuchMethodException e) {\n490                       throw new RuntimeException(\"Method \" + methodName + \" for \" +\n491                               className + \" could not be reconstructed - method not found\");\n492                   }\n493                   methodRef = new SoftReference<Method>(m);\n494               }\n495               return m;\n496           }\n508           private Class<?> reLoadClass(final String name) {\n509   \n510               ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n511   \n512               // Try the context class loader\n513               if (classLoader != null) {\n514                   try {\n515                       return classLoader.loadClass(name);\n516                   } catch (final ClassNotFoundException e) {\n517                       // ignore\n518                   }\n519               }\n520   \n521               // Try this class's class loader\n522               classLoader = MappedPropertyDescriptor.class.getClassLoader();\n523               try {\n524                   return classLoader.loadClass(name);\n525               } catch (final ClassNotFoundException e) {\n526                   return null;\n527               }\n528           }\n",
            "cost": 0.618425,
            "harness_id": "id_1",
            "sanitizer": "load arbitrary library",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java:515:50",
            "status": "corpus",
            "valid_path": "YES",
            "id": 3
        },
        {
            "blob": [
                "AAAAAQAAABUAAABHY2xhc3NMb2FkZXJQcm9wZXJ0eQBqYXp6ZXJfaG9uZXlwb3QAamF2YS5sYW5nLlN0cmluZwAvcGF0aC90by9kdW1teUZpbGU="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n 92       public static byte[] readInput(Path corpusDir, String seedId) throws IOException {\n 93           // Open file to read the content\n 94           Path seedPath = corpusDir.resolve(seedId);\n 95           return java.nio.file.Files.readAllBytes(seedPath);\n 96       }\n 98       public static byte[] getDummyInput() {\n 99           return \"a:b:c:d\".getBytes();\n100       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 584       public Object getMappedProperty(final Object bean, String name)\n 585               throws IllegalAccessException, InvocationTargetException,\n 586               NoSuchMethodException {\n 587   \n 588           if (bean == null) {\n 589               throw new IllegalArgumentException(\"No bean specified\");\n 590           }\n 591           if (name == null) {\n 592               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 593                       bean.getClass() + \"'\");\n 594           }\n 595   \n 596           // Identify the key of the requested individual property\n 597           String key  = null;\n 598           try {\n 599               key = resolver.getKey(name);\n 600           } catch (final IllegalArgumentException e) {\n 601               throw new IllegalArgumentException\n 602                       (\"Invalid mapped property '\" + name +\n 603                       \"' on bean class '\" + bean.getClass() + \"' \" + e.getMessage());\n 604           }\n 605           if (key == null) {\n 606               throw new IllegalArgumentException(\"Invalid mapped property '\" +\n 607                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 608           }\n 609   \n 610           // Isolate the name\n 611           name = resolver.getProperty(name);\n 612   \n 613           // Request the specified indexed property value\n 614           return (getMappedProperty(bean, name, key));\n 615   \n 616       }\n 635       public Object getMappedProperty(final Object bean,\n 636                                              final String name, final String key)\n 637               throws IllegalAccessException, InvocationTargetException,\n 638               NoSuchMethodException {\n 639   \n 640           if (bean == null) {\n 641               throw new IllegalArgumentException(\"No bean specified\");\n 642           }\n 643           if (name == null) {\n 644               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 645                       bean.getClass() + \"'\");\n 646           }\n 647           if (key == null) {\n 648               throw new IllegalArgumentException(\"No key specified for property '\" +\n 649                       name + \"' on bean class \" + bean.getClass() + \"'\");\n 650           }\n 651   \n 652           // Handle DynaBean instances specially\n 653           if (bean instanceof DynaBean) {\n 654               final DynaProperty descriptor =\n 655                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n 656               if (descriptor == null) {\n 657                   throw new NoSuchMethodException(\"Unknown property '\" +\n 658                           name + \"'+ on bean class '\" + bean.getClass() + \"'\");\n 659               }\n 660               return (((DynaBean) bean).get(name, key));\n 661           }\n 662   \n 663           Object result = null;\n 664   \n 665           // Retrieve the property descriptor for the specified property\n 666           final PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);\n 667           if (descriptor == null) {\n 668               throw new NoSuchMethodException(\"Unknown property '\" +\n 669                       name + \"'+ on bean class '\" + bean.getClass() + \"'\");\n 670           }\n 671   \n 672           if (descriptor instanceof MappedPropertyDescriptor) {\n 673               // Call the keyed getter method if there is one\n 674               Method readMethod = ((MappedPropertyDescriptor) descriptor).\n 675                       getMappedReadMethod();\n 676               readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);\n 677               if (readMethod != null) {\n 678                   final Object[] keyArray = new Object[1];\n 679                   keyArray[0] = key;\n 680                   result = invokeMethod(readMethod, bean, keyArray);\n 681               } else {\n 682                   throw new NoSuchMethodException(\"Property '\" + name +\n 683                           \"' has no mapped getter method on bean class '\" +\n 684                           bean.getClass() + \"'\");\n 685               }\n 686           } else {\n 687             /* means that the result has to be retrieved from a map */\n 688             final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n 689             if (readMethod != null) {\n 690               final Object invokeResult = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n 691               /* test and fetch from the map */\n 692               if (invokeResult instanceof java.util.Map) {\n 693                 result = ((java.util.Map<?, ?>)invokeResult).get(key);\n 694               }\n 695             } else {\n 696               throw new NoSuchMethodException(\"Property '\" + name +\n 697                       \"' has no mapped getter method on bean class '\" +\n 698                       bean.getClass() + \"'\");\n 699             }\n 700           }\n 701           return result;\n 702   \n 703       }\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java:\n237       public Method getMappedReadMethod() {\n238           return mappedReadMethodRef.get();\n239       }\n448           private Method get() {\n449               if (methodRef == null) {\n450                   return null;\n451               }\n452               Method m = methodRef.get();\n453               if (m == null) {\n454                   Class<?> clazz = classRef.get();\n455                   if (clazz == null) {\n456                       clazz = reLoadClass();\n457                       if (clazz != null) {\n458                           classRef = new WeakReference<Class<?>>(clazz);\n459                       }\n460                   }\n461                   if (clazz == null) {\n462                       throw new RuntimeException(\"Method \" + methodName + \" for \" +\n463                               className + \" could not be reconstructed - class reference has gone\");\n464                   }\n465                   Class<?>[] paramTypes = null;\n466                   if (writeParamClassNames != null) {\n467                       paramTypes = new Class[2];\n468                       paramTypes[0] = writeParamTypeRef0.get();\n469                       if (paramTypes[0] == null) {\n470                           paramTypes[0] = reLoadClass(writeParamClassNames[0]);\n471                           if (paramTypes[0] != null) {\n472                               writeParamTypeRef0 = new WeakReference<Class<?>>(paramTypes[0]);\n473                           }\n474                       }\n475                       paramTypes[1] = writeParamTypeRef1.get();\n476                       if (paramTypes[1] == null) {\n477                           paramTypes[1] = reLoadClass(writeParamClassNames[1]);\n478                           if (paramTypes[1] != null) {\n479                               writeParamTypeRef1 = new WeakReference<Class<?>>(paramTypes[1]);\n480                           }\n481                       }\n482                   } else {\n483                       paramTypes = STRING_CLASS_PARAMETER;\n484                   }\n485                   try {\n486                       m = clazz.getMethod(methodName, paramTypes);\n487                       // Un-comment following line for testing\n488                       // System.out.println(\"Recreated Method \" + methodName + \" for \" + className);\n489                   } catch (final NoSuchMethodException e) {\n490                       throw new RuntimeException(\"Method \" + methodName + \" for \" +\n491                               className + \" could not be reconstructed - method not found\");\n492                   }\n493                   methodRef = new SoftReference<Method>(m);\n494               }\n495               return m;\n496           }\n508           private Class<?> reLoadClass(final String name) {\n509   \n510               ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n511   \n512               // Try the context class loader\n513               if (classLoader != null) {\n514                   try {\n515                       return classLoader.loadClass(name);\n516                   } catch (final ClassNotFoundException e) {\n517                       // ignore\n518                   }\n519               }\n520   \n521               // Try this class's class loader\n522               classLoader = MappedPropertyDescriptor.class.getClassLoader();\n523               try {\n524                   return classLoader.loadClass(name);\n525               } catch (final ClassNotFoundException e) {\n526                   return null;\n527               }\n528           }\n",
            "cost": 0.604535,
            "harness_id": "id_1",
            "sanitizer": "load arbitrary library",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/MappedPropertyDescriptor.java:524:46",
            "status": "corpus",
            "valid_path": "YES",
            "id": 4
        },
        {
            "blob": [
                "AAAAAQAAABUAAABGamF2YS5uZXQuVVJMQ2xhc3NMb2FkZXIAamF6emVyX2hvbmV5cG90AGphdmEubGFuZy5TdHJpbmcAZHVtbXlJbnN0YW5jZQ=="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:\n 112       public BeanUtilsBean() {\n 113           this(new ConvertUtilsBean(), new PropertyUtilsBean());\n 114       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/ConvertUtilsBean.java:\n159       public ConvertUtilsBean() {\n160           converters.setFast(false);\n161           deregister();\n162           converters.setFast(true);\n163       }\n596       public void deregister() {\n597   \n598           converters.clear();\n599   \n600           registerPrimitives(false);\n601           registerStandard(false, false);\n602           registerOther(true);\n603           registerArrays(false, 0);\n604           register(BigDecimal.class, new BigDecimalConverter());\n605           register(BigInteger.class, new BigIntegerConverter());\n606       }\n648       private void registerPrimitives(final boolean throwException) {\n649           register(Boolean.TYPE,   throwException ? new BooleanConverter()    : new BooleanConverter(Boolean.FALSE));\n650           register(Byte.TYPE,      throwException ? new ByteConverter()       : new ByteConverter(ZERO));\n651           register(Character.TYPE, throwException ? new CharacterConverter()  : new CharacterConverter(SPACE));\n652           register(Double.TYPE,    throwException ? new DoubleConverter()     : new DoubleConverter(ZERO));\n653           register(Float.TYPE,     throwException ? new FloatConverter()      : new FloatConverter(ZERO));\n654           register(Integer.TYPE,   throwException ? new IntegerConverter()    : new IntegerConverter(ZERO));\n655           register(Long.TYPE,      throwException ? new LongConverter()       : new LongConverter(ZERO));\n656           register(Short.TYPE,     throwException ? new ShortConverter()      : new ShortConverter(ZERO));\n657       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/BooleanConverter.java:\n 81       public BooleanConverter(final Object defaultValue) {\n 82           super();\n 83           if (defaultValue != NO_DEFAULT) {\n 84               setDefaultValue(defaultValue);\n 85           }\n 86       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/AbstractConverter.java:\n130       public <T> T convert(final Class<T> type, Object value) {\n131   \n132           if (type == null) {\n133               return convertToDefaultType(type, value);\n134           }\n135   \n136           Class<?> sourceType  = value == null ? null : value.getClass();\n137           final Class<T> targetType  = ConvertUtils.primitiveToWrapper(type);\n138   \n139           if (log().isDebugEnabled()) {\n140               log().debug(\"Converting\"\n141                       + (value == null ? \"\" : \" '\" + toString(sourceType) + \"'\")\n142                       + \" value '\" + value + \"' to type '\" + toString(targetType) + \"'\");\n143           }\n144   \n145           value = convertArray(value);\n146   \n147           // Missing Value\n148           if (value == null) {\n149               return handleMissing(targetType);\n150           }\n151   \n152           sourceType = value.getClass();\n153   \n154           try {\n155               // Convert --> String\n156               if (targetType.equals(String.class)) {\n157                   return targetType.cast(convertToString(value));\n158   \n159               // No conversion necessary\n160               } else if (targetType.equals(sourceType)) {\n161                   if (log().isDebugEnabled()) {\n162                       log().debug(\"    No conversion required, value is already a \"\n163                                       + toString(targetType));\n164                   }\n165                   return targetType.cast(value);\n166   \n167               // Convert --> Type\n168               } else {\n169                   final Object result = convertToType(targetType, value);\n170                   if (log().isDebugEnabled()) {\n171                       log().debug(\"    Converted to \" + toString(targetType) +\n172                                      \" value '\" + result + \"'\");\n173                   }\n174                   return targetType.cast(result);\n175               }\n176           } catch (final Throwable t) {\n177               return handleError(targetType, value, t);\n178           }\n179   \n180       }\n350       protected void setDefaultValue(final Object defaultValue) {\n351           useDefault = false;\n352           if (log().isDebugEnabled()) {\n353               log().debug(\"Setting default value: \" + defaultValue);\n354           }\n355           if (defaultValue == null) {\n356              this.defaultValue  = null;\n357           } else {\n358              this.defaultValue  = convert(getDefaultType(), defaultValue);\n359           }\n360           useDefault = true;\n361       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java:\n 88       @Override\n 89       protected <T> T convertToType(final Class<T> type, final Object value) throws Throwable {\n 90           if (Class.class.equals(type)) {\n 91               ClassLoader classLoader = Thread.currentThread()\n 92                       .getContextClassLoader();\n 93               if (classLoader != null) {\n 94                   try {\n 95                       return type.cast(classLoader.loadClass(value.toString()));\n 96                   } catch (final ClassNotFoundException ex) {\n 97                       // Don't fail, carry on and try this class's class loader\n 98                       // (see issue# BEANUTILS-263)\n 99                   }\n100               }\n101   \n102               // Try this class's class loader\n103               classLoader = ClassConverter.class.getClassLoader();\n104               return type.cast(classLoader.loadClass(value.toString()));\n105           }\n106   \n107           throw conversionException(type, value);\n108       }\n",
            "cost": 0.5177,
            "harness_id": "id_1",
            "sanitizer": "load arbitrary library",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java:95:60",
            "status": "corpus",
            "valid_path": "YES",
            "id": 5
        },
        {
            "blob": [
                "AAAAAQAAABUAAAA2Y2xhc3NMb2FkZXIAamF6emVyX2hvbmV5cG90AGphdmEubGFuZy5PYmplY3QAZHVtbXlGaWxl"
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:\n 112       public BeanUtilsBean() {\n 113           this(new ConvertUtilsBean(), new PropertyUtilsBean());\n 114       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/ConvertUtilsBean.java:\n159       public ConvertUtilsBean() {\n160           converters.setFast(false);\n161           deregister();\n162           converters.setFast(true);\n163       }\n596       public void deregister() {\n597   \n598           converters.clear();\n599   \n600           registerPrimitives(false);\n601           registerStandard(false, false);\n602           registerOther(true);\n603           registerArrays(false, 0);\n604           register(BigDecimal.class, new BigDecimalConverter());\n605           register(BigInteger.class, new BigIntegerConverter());\n606       }\n648       private void registerPrimitives(final boolean throwException) {\n649           register(Boolean.TYPE,   throwException ? new BooleanConverter()    : new BooleanConverter(Boolean.FALSE));\n650           register(Byte.TYPE,      throwException ? new ByteConverter()       : new ByteConverter(ZERO));\n651           register(Character.TYPE, throwException ? new CharacterConverter()  : new CharacterConverter(SPACE));\n652           register(Double.TYPE,    throwException ? new DoubleConverter()     : new DoubleConverter(ZERO));\n653           register(Float.TYPE,     throwException ? new FloatConverter()      : new FloatConverter(ZERO));\n654           register(Integer.TYPE,   throwException ? new IntegerConverter()    : new IntegerConverter(ZERO));\n655           register(Long.TYPE,      throwException ? new LongConverter()       : new LongConverter(ZERO));\n656           register(Short.TYPE,     throwException ? new ShortConverter()      : new ShortConverter(ZERO));\n657       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/BooleanConverter.java:\n 81       public BooleanConverter(final Object defaultValue) {\n 82           super();\n 83           if (defaultValue != NO_DEFAULT) {\n 84               setDefaultValue(defaultValue);\n 85           }\n 86       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/AbstractConverter.java:\n130       public <T> T convert(final Class<T> type, Object value) {\n131   \n132           if (type == null) {\n133               return convertToDefaultType(type, value);\n134           }\n135   \n136           Class<?> sourceType  = value == null ? null : value.getClass();\n137           final Class<T> targetType  = ConvertUtils.primitiveToWrapper(type);\n138   \n139           if (log().isDebugEnabled()) {\n140               log().debug(\"Converting\"\n141                       + (value == null ? \"\" : \" '\" + toString(sourceType) + \"'\")\n142                       + \" value '\" + value + \"' to type '\" + toString(targetType) + \"'\");\n143           }\n144   \n145           value = convertArray(value);\n146   \n147           // Missing Value\n148           if (value == null) {\n149               return handleMissing(targetType);\n150           }\n151   \n152           sourceType = value.getClass();\n153   \n154           try {\n155               // Convert --> String\n156               if (targetType.equals(String.class)) {\n157                   return targetType.cast(convertToString(value));\n158   \n159               // No conversion necessary\n160               } else if (targetType.equals(sourceType)) {\n161                   if (log().isDebugEnabled()) {\n162                       log().debug(\"    No conversion required, value is already a \"\n163                                       + toString(targetType));\n164                   }\n165                   return targetType.cast(value);\n166   \n167               // Convert --> Type\n168               } else {\n169                   final Object result = convertToType(targetType, value);\n170                   if (log().isDebugEnabled()) {\n171                       log().debug(\"    Converted to \" + toString(targetType) +\n172                                      \" value '\" + result + \"'\");\n173                   }\n174                   return targetType.cast(result);\n175               }\n176           } catch (final Throwable t) {\n177               return handleError(targetType, value, t);\n178           }\n179   \n180       }\n350       protected void setDefaultValue(final Object defaultValue) {\n351           useDefault = false;\n352           if (log().isDebugEnabled()) {\n353               log().debug(\"Setting default value: \" + defaultValue);\n354           }\n355           if (defaultValue == null) {\n356              this.defaultValue  = null;\n357           } else {\n358              this.defaultValue  = convert(getDefaultType(), defaultValue);\n359           }\n360           useDefault = true;\n361       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java:\n 88       @Override\n 89       protected <T> T convertToType(final Class<T> type, final Object value) throws Throwable {\n 90           if (Class.class.equals(type)) {\n 91               ClassLoader classLoader = Thread.currentThread()\n 92                       .getContextClassLoader();\n 93               if (classLoader != null) {\n 94                   try {\n 95                       return type.cast(classLoader.loadClass(value.toString()));\n 96                   } catch (final ClassNotFoundException ex) {\n 97                       // Don't fail, carry on and try this class's class loader\n 98                       // (see issue# BEANUTILS-263)\n 99                   }\n100               }\n101   \n102               // Try this class's class loader\n103               classLoader = ClassConverter.class.getClassLoader();\n104               return type.cast(classLoader.loadClass(value.toString()));\n105           }\n106   \n107           throw conversionException(type, value);\n108       }\n",
            "cost": 0.513335,
            "harness_id": "id_1",
            "sanitizer": "load arbitrary library",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/converters/ClassConverter.java:104:52",
            "status": "corpus",
            "valid_path": "YES",
            "id": 6
        },
        {
            "blob": [
                ""
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtils.java:\n465       public static boolean initCause(final Throwable throwable, final Throwable cause) {\n466           return BeanUtilsBean.getInstance().initCause(throwable, cause);\n467       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:\n1052       public boolean initCause(final Throwable throwable, final Throwable cause) {\n1053           if (INIT_CAUSE_METHOD != null && cause != null) {\n1054               try {\n1055                   INIT_CAUSE_METHOD.invoke(throwable, new Object[] { cause });\n1056                   return true;\n1057               } catch (final Throwable e) {\n1058                   return false; // can't initialize cause\n1059               }\n1060           }\n1061           return false;\n1062       }\n",
            "cost": 0.07549,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:1055:17",
            "status": "corpus",
            "valid_path": "NO",
            "id": 7
        },
        {
            "blob": [
                ""
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtils.java:\n465       public static boolean initCause(final Throwable throwable, final Throwable cause) {\n466           return BeanUtilsBean.getInstance().initCause(throwable, cause);\n467       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:\n1052       public boolean initCause(final Throwable throwable, final Throwable cause) {\n1053           if (INIT_CAUSE_METHOD != null && cause != null) {\n1054               try {\n1055                   INIT_CAUSE_METHOD.invoke(throwable, new Object[] { cause });\n1056                   return true;\n1057               } catch (final Throwable e) {\n1058                   return false; // can't initialize cause\n1059               }\n1060           }\n1061           return false;\n1062       }\n",
            "cost": 0.08229,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:1055:42",
            "status": "corpus",
            "valid_path": "NO",
            "id": 8
        },
        {
            "blob": [
                ""
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n",
            "cost": 0.071925,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:34",
            "status": "corpus",
            "valid_path": "NO",
            "id": 9
        },
        {
            "blob": [
                "AAAAAQAAABUAAABWb3JnLmFwYWNoZS5jb21tb25zLmJlYW51dGlscy5CZWFuVXRpbHNCZWFuAGphdmEuaW8uRmlsZQBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 416       public Object getIndexedProperty(final Object bean, String name)\n 417               throws IllegalAccessException, InvocationTargetException,\n 418               NoSuchMethodException {\n 419   \n 420           if (bean == null) {\n 421               throw new IllegalArgumentException(\"No bean specified\");\n 422           }\n 423           if (name == null) {\n 424               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 425                       bean.getClass() + \"'\");\n 426           }\n 427   \n 428           // Identify the index of the requested individual property\n 429           int index = -1;\n 430           try {\n 431               index = resolver.getIndex(name);\n 432           } catch (final IllegalArgumentException e) {\n 433               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 434                       name + \"' on bean class '\" + bean.getClass() + \"' \" +\n 435                       e.getMessage());\n 436           }\n 437           if (index < 0) {\n 438               throw new IllegalArgumentException(\"Invalid indexed property '\" +\n 439                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 440           }\n 441   \n 442           // Isolate the name\n 443           name = resolver.getProperty(name);\n 444   \n 445           // Request the specified indexed property value\n 446           return (getIndexedProperty(bean, name, index));\n 447   \n 448       }\n 473       public Object getIndexedProperty(final Object bean,\n 474                                               final String name, final int index)\n 475               throws IllegalAccessException, InvocationTargetException,\n 476               NoSuchMethodException {\n 477   \n 478           if (bean == null) {\n 479               throw new IllegalArgumentException(\"No bean specified\");\n 480           }\n 481           if (name == null || name.length() == 0) {\n 482               if (bean.getClass().isArray()) {\n 483                   return Array.get(bean, index);\n 484               } else if (bean instanceof List) {\n 485                   return ((List<?>)bean).get(index);\n 486               }\n 487           }\n 488           if (name == null) {\n 489               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 490                       bean.getClass() + \"'\");\n 491           }\n 492   \n 493           // Handle DynaBean instances specially\n 494           if (bean instanceof DynaBean) {\n 495               final DynaProperty descriptor =\n 496                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n 497               if (descriptor == null) {\n 498                   throw new NoSuchMethodException(\"Unknown property '\" +\n 499                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 500               }\n 501               return (((DynaBean) bean).get(name, index));\n 502           }\n 503   \n 504           // Retrieve the property descriptor for the specified property\n 505           final PropertyDescriptor descriptor =\n 506                   getPropertyDescriptor(bean, name);\n 507           if (descriptor == null) {\n 508               throw new NoSuchMethodException(\"Unknown property '\" +\n 509                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n 510           }\n 511   \n 512           // Call the indexed getter method if there is one\n 513           if (descriptor instanceof IndexedPropertyDescriptor) {\n 514               Method readMethod = ((IndexedPropertyDescriptor) descriptor).\n 515                       getIndexedReadMethod();\n 516               readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);\n 517               if (readMethod != null) {\n 518                   final Object[] subscript = new Object[1];\n 519                   subscript[0] = new Integer(index);\n 520                   try {\n 521                       return (invokeMethod(readMethod,bean, subscript));\n 522                   } catch (final InvocationTargetException e) {\n 523                       if (e.getTargetException() instanceof\n 524                               IndexOutOfBoundsException) {\n 525                           throw (IndexOutOfBoundsException)\n 526                                   e.getTargetException();\n 527                       } else {\n 528                           throw e;\n 529                       }\n 530                   }\n 531               }\n 532           }\n 533   \n 534           // Otherwise, the underlying property must be an array\n 535           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n 536           if (readMethod == null) {\n 537               throw new NoSuchMethodException(\"Property '\" + name + \"' has no \" +\n 538                       \"getter method on bean class '\" + bean.getClass() + \"'\");\n 539           }\n 540   \n 541           // Call the property getter and return the value\n 542           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n 543           if (!value.getClass().isArray()) {\n 544               if (!(value instanceof java.util.List)) {\n 545                   throw new IllegalArgumentException(\"Property '\" + name +\n 546                           \"' is not indexed on bean class '\" + bean.getClass() + \"'\");\n 547               } else {\n 548                   //get the List's value\n 549                   return ((java.util.List<?>) value).get(index);\n 550               }\n 551           } else {\n 552               //get the array's value\n 553               try {\n 554                   return (Array.get(value, index));\n 555               } catch (final ArrayIndexOutOfBoundsException e) {\n 556                   throw new ArrayIndexOutOfBoundsException(\"Index: \" +\n 557                           index + \", Size: \" + Array.getLength(value) +\n 558                           \" for property '\" + name + \"'\");\n 559               }\n 560           }\n 561   \n 562       }\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n 919       public PropertyDescriptor getPropertyDescriptor(Object bean,\n 920                                                              String name)\n 921               throws IllegalAccessException, InvocationTargetException,\n 922               NoSuchMethodException {\n 923   \n 924           if (bean == null) {\n 925               throw new IllegalArgumentException(\"No bean specified\");\n 926           }\n 927           if (name == null) {\n 928               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 929                       bean.getClass() + \"'\");\n 930           }\n 931   \n 932           // Resolve nested references\n 933           while (resolver.hasNested(name)) {\n 934               final String next = resolver.next(name);\n 935               final Object nestedBean = getProperty(bean, next);\n 936               if (nestedBean == null) {\n 937                   throw new NestedNullException\n 938                           (\"Null property value for '\" + next +\n 939                           \"' on bean class '\" + bean.getClass() + \"'\");\n 940               }\n 941               bean = nestedBean;\n 942               name = resolver.remove(name);\n 943           }\n 944   \n 945           // Remove any subscript from the final name value\n 946           name = resolver.getProperty(name);\n 947   \n 948           // Look up and return this property from our cache\n 949           // creating and adding it to the cache if not found.\n 950           if (name == null) {\n 951               return (null);\n 952           }\n 953   \n 954           final BeanIntrospectionData data = getIntrospectionData(bean.getClass());\n 955           PropertyDescriptor result = data.getDescriptor(name);\n 956           if (result != null) {\n 957               return result;\n 958           }\n 959   \n 960           FastHashMap mappedDescriptors =\n 961                   getMappedPropertyDescriptors(bean);\n 962           if (mappedDescriptors == null) {\n 963               mappedDescriptors = new FastHashMap();\n 964               mappedDescriptors.setFast(true);\n 965               mappedDescriptorsCache.put(bean.getClass(), mappedDescriptors);\n 966           }\n 967           result = (PropertyDescriptor) mappedDescriptors.get(name);\n 968           if (result == null) {\n 969               // not found, try to create it\n 970               try {\n 971                   result = new MappedPropertyDescriptor(name, bean.getClass());\n 972               } catch (final IntrospectionException ie) {\n 973                   /* Swallow IntrospectionException\n 974                    * TODO: Why?\n 975                    */\n 976               }\n 977               if (result != null) {\n 978                   mappedDescriptors.put(name, result);\n 979               }\n 980           }\n 981   \n 982           return result;\n 983   \n 984       }\n1201       Method getReadMethod(final Class<?> clazz, final PropertyDescriptor descriptor) {\n1202           return (MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod()));\n1203       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n2218       private BeanIntrospectionData getIntrospectionData(final Class<?> beanClass) {\n2219           if (beanClass == null) {\n2220               throw new IllegalArgumentException(\"No bean class specified\");\n2221           }\n2222   \n2223           // Look up any cached information for this bean class\n2224           BeanIntrospectionData data = descriptorsCache.get(beanClass);\n2225           if (data == null) {\n2226               data = fetchIntrospectionData(beanClass);\n2227               descriptorsCache.put(beanClass, data);\n2228           }\n2229   \n2230           return data;\n2231       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/expression/DefaultResolver.java:\n 79       public int getIndex(final String expression) {\n 80           if (expression == null || expression.length() == 0) {\n 81               return -1;\n 82           }\n 83           for (int i = 0; i < expression.length(); i++) {\n 84               final char c = expression.charAt(i);\n 85               if (c == NESTED || c == MAPPED_START) {\n 86                   return -1;\n 87               } else if (c == INDEXED_START) {\n 88                   final int end = expression.indexOf(INDEXED_END, i);\n 89                   if (end < 0) {\n 90                       throw new IllegalArgumentException(\"Missing End Delimiter\");\n 91                   }\n 92                   final String value = expression.substring(i + 1, end);\n 93                   if (value.length() == 0) {\n 94                       throw new IllegalArgumentException(\"No Index Value\");\n 95                   }\n 96                   int index = 0;\n 97                   try {\n 98                       index = Integer.parseInt(value, 10);\n 99                   } catch (final Exception e) {\n100                       throw new IllegalArgumentException(\"Invalid index value '\"\n101                               + value + \"'\");\n102                   }\n103                   return index;\n104               }\n105           }\n106           return -1;\n107       }\n163       public boolean hasNested(final String expression) {\n164           if (expression == null || expression.length() == 0) {\n165               return false;\n166           } else {\n167               return (remove(expression) != null);\n168           }\n169       }\n178       public boolean isIndexed(final String expression) {\n179           if (expression == null || expression.length() == 0) {\n180               return false;\n181           }\n182           for (int i = 0; i < expression.length(); i++) {\n183               final char c = expression.charAt(i);\n184               if (c == NESTED || c == MAPPED_START) {\n185                   return false;\n186               } else if (c == INDEXED_START) {\n187                   return true;\n188               }\n189           }\n190           return false;\n191       }\n200       public boolean isMapped(final String expression) {\n201           if (expression == null || expression.length() == 0) {\n202               return false;\n203           }\n204           for (int i = 0; i < expression.length(); i++) {\n205               final char c = expression.charAt(i);\n206               if (c == NESTED || c == INDEXED_START) {\n207                   return false;\n208               } else if (c == MAPPED_START) {\n209                   return true;\n210               }\n211           }\n212           return false;\n213       }\n222       public String next(final String expression) {\n223           if (expression == null || expression.length() == 0) {\n224               return null;\n225           }\n226           boolean indexed = false;\n227           boolean mapped  = false;\n228           for (int i = 0; i < expression.length(); i++) {\n229               final char c = expression.charAt(i);\n230               if (indexed) {\n231                   if (c == INDEXED_END) {\n232                       return expression.substring(0, i + 1);\n233                   }\n234               } else if (mapped) {\n235                   if (c == MAPPED_END) {\n236                       return expression.substring(0, i + 1);\n237                   }\n238               } else {\n239                   if (c == NESTED) {\n240                       return expression.substring(0, i);\n241                   } else if (c == MAPPED_START) {\n242                       mapped = true;\n243                   } else if (c == INDEXED_START) {\n244                       indexed = true;\n245                   }\n246               }\n247           }\n248           return expression;\n249       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/WeakFastHashMap.java:\n155       @Override\n156       public V get(final Object key) {\n157           if (fast) {\n158               return (map.get(key));\n159           } else {\n160               synchronized (map) {\n161                   return (map.get(key));\n162               }\n163           }\n164       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanIntrospectionData.java:\n 79       public PropertyDescriptor[] getDescriptors() {\n 80           return descriptors;\n 81       }\n 90       public PropertyDescriptor getDescriptor(final String name) {\n 91           for (final PropertyDescriptor pd : getDescriptors()) {\n 92               if (name.equals(pd.getName())) {\n 93                   return pd;\n 94               }\n 95           }\n 96           return null;\n 97       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/MethodUtils.java:\n 774       public static Method getAccessibleMethod(Class<?> clazz, Method method) {\n 775   \n 776           // Make sure we have a method to check\n 777           if (method == null) {\n 778               return (null);\n 779           }\n 780   \n 781           // If the requested method is not public we cannot call it\n 782           if (!Modifier.isPublic(method.getModifiers())) {\n 783               return (null);\n 784           }\n 785   \n 786           boolean sameClass = true;\n 787           if (clazz == null) {\n 788               clazz = method.getDeclaringClass();\n 789           } else {\n 790               sameClass = clazz.equals(method.getDeclaringClass());\n 791               if (!method.getDeclaringClass().isAssignableFrom(clazz)) {\n 792                   throw new IllegalArgumentException(clazz.getName() +\n 793                           \" is not assignable from \" + method.getDeclaringClass().getName());\n 794               }\n 795           }\n 796   \n 797           // If the class is public, we are done\n 798           if (Modifier.isPublic(clazz.getModifiers())) {\n 799               if (!sameClass && !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n 800                   setMethodAccessible(method); // Default access superclass workaround\n 801               }\n 802               return (method);\n 803           }\n 804   \n 805           final String methodName      = method.getName();\n 806           final Class<?>[] parameterTypes = method.getParameterTypes();\n 807   \n 808           // Check the implemented interfaces and subinterfaces\n 809           method =\n 810                   getAccessibleMethodFromInterfaceNest(clazz,\n 811                           methodName,\n 812                           parameterTypes);\n 813   \n 814           // Check the superclass chain\n 815           if (method == null) {\n 816               method = getAccessibleMethodFromSuperclass(clazz,\n 817                           methodName,\n 818                           parameterTypes);\n 819           }\n 820   \n 821           return (method);\n 822       }\n 867       private static Method getAccessibleMethodFromInterfaceNest\n 868               (Class<?> clazz, final String methodName, final Class<?>[] parameterTypes) {\n 869   \n 870           Method method = null;\n 871   \n 872           // Search up the superclass chain\n 873           for (; clazz != null; clazz = clazz.getSuperclass()) {\n 874   \n 875               // Check the implemented interfaces of the parent class\n 876               final Class<?>[] interfaces = clazz.getInterfaces();\n 877               for (int i = 0; i < interfaces.length; i++) {\n 878   \n 879                   // Is this interface public?\n 880                   if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n 881                       continue;\n 882                   }\n 883   \n 884                   // Does the method exist on this interface?\n 885                   try {\n 886                       method = interfaces[i].getDeclaredMethod(methodName,\n 887                               parameterTypes);\n 888                   } catch (final NoSuchMethodException e) {\n 889                       /* Swallow, if no method is found after the loop then this\n 890                        * method returns null.\n 891                        */\n 892                   }\n 893                   if (method != null) {\n 894                       return method;\n 895                   }\n 896   \n 897                   // Recursively check our parent interfaces\n 898                   method =\n 899                           getAccessibleMethodFromInterfaceNest(interfaces[i],\n 900                                   methodName,\n 901                                   parameterTypes);\n 902                   if (method != null) {\n 903                       return method;\n 904                   }\n 905   \n 906               }\n 907   \n 908           }\n 909   \n 910           // We did not find anything\n 911           return (null);\n 912       }\n",
            "cost": 1.18107,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:20",
            "status": "corpus",
            "valid_path": "YES",
            "id": 10
        },
        {
            "blob": [
                "AAAAAQAAABUAAAA7Y2xhc3NMb2FkZXIAamF2YS5sYW5nLlN0cmluZwBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI="
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 21       public static void main(String[] args) throws Exception {\n 22           byte[] input;\n 23           if (args.length == 2) {\n 24               input = readInput(Path.of(args[0]), args[1]);\n 25           } else {\n 26               input = getDummyInput();\n 27           }\n 28           fuzzerTestOneInput(input);\n 29       }\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtils.java:\n465       public static boolean initCause(final Throwable throwable, final Throwable cause) {\n466           return BeanUtilsBean.getInstance().initCause(throwable, cause);\n467       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:\n1052       public boolean initCause(final Throwable throwable, final Throwable cause) {\n1053           if (INIT_CAUSE_METHOD != null && cause != null) {\n1054               try {\n1055                   INIT_CAUSE_METHOD.invoke(throwable, new Object[] { cause });\n1056                   return true;\n1057               } catch (final Throwable e) {\n1058                   return false; // can't initialize cause\n1059               }\n1060           }\n1061           return false;\n1062       }\n",
            "cost": 0.606115,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/BeanUtilsBean.java:1055:17",
            "status": "corpus",
            "valid_path": "YES",
            "id": 11
        },
        {
            "blob": [
                ""
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n",
            "cost": 0.071225,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:20",
            "status": "corpus",
            "valid_path": "NO",
            "id": 12
        },
        {
            "blob": [
                ""
            ],
            "code": "src/beanutils-harnesses/beanutils-harness-one/src/main/java/com/aixcc/beanutils/harnesses/one/BeanUtilsOne.java:\n 41       public static void fuzzerTestOneInput(byte[] input) throws Exception {\n 42           new BeanUtilsOne().fuzz(input);\n 43       }\n 45       private void fuzz(byte[] data) {\n 46           ByteBuffer buf = ByteBuffer.wrap(data);\n 47           int count = buf.getInt();\n 48           System.err.println(\"count: \" + count);\n 49   \n 50           if (count > 255)\n 51               return;\n 52   \n 53           for (int i = 0; i < count; i++) {\n 54               int picker = buf.getInt();\n 55               System.err.println(\"picker: \" + picker);\n 56               try {\n 57                   switch (picker) {\n 58                       case 21: {\n 59                            int data_size = buf.getInt();\n 60                            byte[] inner_data = new byte[data_size];\n 61                            buf.get(inner_data);\n 62                            String whole = new String(inner_data);\n 63   \n 64                            String[] parts = whole.split(\"\\0\");\n 65   \n 66   \n 67                            if (parts.length != 4) {\n 68                                return;\n 69                            }\n 70                            BeanUtilsBean.setInstance(new BeanUtilsBean2());\n 71                            BeanUtilsBean bub = new BeanUtilsBean();\n 72                            PropertyUtilsBean pb = bub.getPropertyUtils();\n 73   \n 74                            ClassLoader a = (ClassLoader) pb.getNestedProperty(pb, parts[0]);\n 75                            Class c = a.loadClass(parts[1]);\n 76                            Constructor con = c.getConstructor(a.loadClass(parts[2]));\n 77   \n 78                            File f = (File) con.newInstance(parts[3]);\n 79                            Scanner s = new Scanner(f);\n 80                            break;\n 81                       }\n 82   \n 83                       default:\n 84                           throw new Exception(\"unsupported method picker\");\n 85                   }\n 86               } catch (Exception e) {\n 87                   continue; // eat it\n 88               }\n 89           }\n 90       }\n\nsrc/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:\n 767       public Object getNestedProperty(Object bean, String name)\n 768               throws IllegalAccessException, InvocationTargetException,\n 769               NoSuchMethodException {\n 770   \n 771           if (bean == null) {\n 772               throw new IllegalArgumentException(\"No bean specified\");\n 773           }\n 774           if (name == null) {\n 775               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n 776                       bean.getClass() + \"'\");\n 777           }\n 778   \n 779           // Resolve nested references\n 780           while (resolver.hasNested(name)) {\n 781               final String next = resolver.next(name);\n 782               Object nestedBean = null;\n 783               if (bean instanceof Map) {\n 784                   nestedBean = getPropertyOfMapBean((Map<?, ?>) bean, next);\n 785               } else if (resolver.isMapped(next)) {\n 786                   nestedBean = getMappedProperty(bean, next);\n 787               } else if (resolver.isIndexed(next)) {\n 788                   nestedBean = getIndexedProperty(bean, next);\n 789               } else {\n 790                   nestedBean = getSimpleProperty(bean, next);\n 791               }\n 792               if (nestedBean == null) {\n 793                   throw new NestedNullException\n 794                           (\"Null property value for '\" + name +\n 795                           \"' on bean class '\" + bean.getClass() + \"'\");\n 796               }\n 797               bean = nestedBean;\n 798               name = resolver.remove(name);\n 799           }\n 800   \n 801           if (bean instanceof Map) {\n 802               bean = getPropertyOfMapBean((Map<?, ?>) bean, name);\n 803           } else if (resolver.isMapped(name)) {\n 804               bean = getMappedProperty(bean, name);\n 805           } else if (resolver.isIndexed(name)) {\n 806               bean = getIndexedProperty(bean, name);\n 807           } else {\n 808               bean = getSimpleProperty(bean, name);\n 809           }\n 810           return bean;\n 811   \n 812       }\n1225       public Object getSimpleProperty(final Object bean, final String name)\n1226               throws IllegalAccessException, InvocationTargetException,\n1227               NoSuchMethodException {\n1228   \n1229           if (bean == null) {\n1230               throw new IllegalArgumentException(\"No bean specified\");\n1231           }\n1232           if (name == null) {\n1233               throw new IllegalArgumentException(\"No name specified for bean class '\" +\n1234                       bean.getClass() + \"'\");\n1235           }\n1236   \n1237           // Validate the syntax of the property name\n1238           if (resolver.hasNested(name)) {\n1239               throw new IllegalArgumentException\n1240                       (\"Nested property names are not allowed: Property '\" +\n1241                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1242           } else if (resolver.isIndexed(name)) {\n1243               throw new IllegalArgumentException\n1244                       (\"Indexed property names are not allowed: Property '\" +\n1245                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1246           } else if (resolver.isMapped(name)) {\n1247               throw new IllegalArgumentException\n1248                       (\"Mapped property names are not allowed: Property '\" +\n1249                       name + \"' on bean class '\" + bean.getClass() + \"'\");\n1250           }\n1251   \n1252           // Handle DynaBean instances specially\n1253           if (bean instanceof DynaBean) {\n1254               final DynaProperty descriptor =\n1255                       ((DynaBean) bean).getDynaClass().getDynaProperty(name);\n1256               if (descriptor == null) {\n1257                   throw new NoSuchMethodException(\"Unknown property '\" +\n1258                           name + \"' on dynaclass '\" +\n1259                           ((DynaBean) bean).getDynaClass() + \"'\" );\n1260               }\n1261               return (((DynaBean) bean).get(name));\n1262           }\n1263   \n1264           // Retrieve the property getter method for the specified property\n1265           final PropertyDescriptor descriptor =\n1266                   getPropertyDescriptor(bean, name);\n1267           if (descriptor == null) {\n1268               throw new NoSuchMethodException(\"Unknown property '\" +\n1269                       name + \"' on class '\" + bean.getClass() + \"'\" );\n1270           }\n1271           final Method readMethod = getReadMethod(bean.getClass(), descriptor);\n1272           if (readMethod == null) {\n1273               throw new NoSuchMethodException(\"Property '\" + name +\n1274                       \"' has no getter method in class '\" + bean.getClass() + \"'\");\n1275           }\n1276   \n1277           // Call the property getter and return the value\n1278           final Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);\n1279           return (value);\n1280   \n1281       }\n2113       private Object invokeMethod(\n2114                           final Method method,\n2115                           final Object bean,\n2116                           final Object[] values)\n2117                               throws\n2118                                   IllegalAccessException,\n2119                                   InvocationTargetException {\n2120           if(bean == null) {\n2121               throw new IllegalArgumentException(\"No bean specified \" +\n2122                   \"- this should have been checked before reaching this method\");\n2123           }\n2124   \n2125           try {\n2126   \n2127               return method.invoke(bean, values);\n2128   \n2129           } catch (final NullPointerException cause) {\n2130               // JDK 1.3 and JDK 1.4 throw NullPointerException if an argument is\n2131               // null for a primitive value (JDK 1.5+ throw IllegalArgumentException)\n2132               String valueString = \"\";\n2133               if (values != null) {\n2134                   for (int i = 0; i < values.length; i++) {\n2135                       if (i>0) {\n2136                           valueString += \", \" ;\n2137                       }\n2138                       if (values[i] == null) {\n2139                           valueString += \"<null>\";\n2140                       } else {\n2141                           valueString += (values[i]).getClass().getName();\n2142                       }\n2143                   }\n2144               }\n2145               String expectedString = \"\";\n2146               final Class<?>[] parTypes = method.getParameterTypes();\n2147               if (parTypes != null) {\n2148                   for (int i = 0; i < parTypes.length; i++) {\n2149                       if (i > 0) {\n2150                           expectedString += \", \";\n2151                       }\n2152                       expectedString += parTypes[i].getName();\n2153                   }\n2154               }\n2155               final IllegalArgumentException e = new IllegalArgumentException(\n2156                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2157                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2158                   \"' - \" + cause.getMessage()\n2159                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2160                   + \" - had objects of type \\\"\" + valueString\n2161                   + \"\\\" but expected signature \\\"\"\n2162                   +   expectedString + \"\\\"\"\n2163                   );\n2164               if (!BeanUtils.initCause(e, cause)) {\n2165                   log.error(\"Method invocation failed\", cause);\n2166               }\n2167               throw e;\n2168           } catch (final IllegalArgumentException cause) {\n2169               String valueString = \"\";\n2170               if (values != null) {\n2171                   for (int i = 0; i < values.length; i++) {\n2172                       if (i>0) {\n2173                           valueString += \", \" ;\n2174                       }\n2175                       if (values[i] == null) {\n2176                           valueString += \"<null>\";\n2177                       } else {\n2178                           valueString += (values[i]).getClass().getName();\n2179                       }\n2180                   }\n2181               }\n2182               String expectedString = \"\";\n2183               final Class<?>[] parTypes = method.getParameterTypes();\n2184               if (parTypes != null) {\n2185                   for (int i = 0; i < parTypes.length; i++) {\n2186                       if (i > 0) {\n2187                           expectedString += \", \";\n2188                       }\n2189                       expectedString += parTypes[i].getName();\n2190                   }\n2191               }\n2192               final IllegalArgumentException e = new IllegalArgumentException(\n2193                   \"Cannot invoke \" + method.getDeclaringClass().getName() + \".\"\n2194                   + method.getName() + \" on bean class '\" + bean.getClass() +\n2195                   \"' - \" + cause.getMessage()\n2196                   // as per https://issues.apache.org/jira/browse/BEANUTILS-224\n2197                   + \" - had objects of type \\\"\" + valueString\n2198                   + \"\\\" but expected signature \\\"\"\n2199                   +   expectedString + \"\\\"\"\n2200                   );\n2201               if (!BeanUtils.initCause(e, cause)) {\n2202                   log.error(\"Method invocation failed\", cause);\n2203               }\n2204               throw e;\n2205   \n2206           }\n2207       }\n",
            "cost": 0.071225,
            "harness_id": "id_1",
            "sanitizer": "Script Engine Injection",
            "sink": "src/beanutils/src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java:2127:20",
            "status": "corpus",
            "valid_path": "NO",
            "id": 13
        }
    ],
    "result": [
        {
            "harness_id": "id_1",
            "blob": [
                "",
                "AAAAAQAAABUAAAA2Y2xhc3NMb2FkZXIAamF6emVyX2hvbmV5cG90AGphdmEubGFuZy5PYmplY3QAZHVtbXlGaWxl",
                "AAAAAQAAABUAAAA7Y2xhc3NMb2FkZXIAamF2YS5sYW5nLlN0cmluZwBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI=",
                "AAAAAQAAABUAAAA7amF2YS5sYW5nLlN5c3RlbQBnZXRQcm9wZXJ0eQBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI=",
                "AAAAAQAAABUAAABCY2xhc3NMb2FkZXJQcm9wZXJ0eQBqYXp6ZXJfaG9uZXlwb3QAamF2YS5sYW5nLlN0cmluZwB2YWxpZEFyZ3VtZW50",
                "AAAAAQAAABUAAABGamF2YS5sYW5nLkNsYXNzTG9hZGVyAGphdmEubGFuZy5SdW50aW1lAGphdmEubGFuZy5TdHJpbmcAIiJqYXoiKyJ6ZXIiIg==",
                "AAAAAQAAABUAAABGamF2YS5uZXQuVVJMQ2xhc3NMb2FkZXIAamF6emVyX2hvbmV5cG90AGphdmEubGFuZy5TdHJpbmcAZHVtbXlJbnN0YW5jZQ==",
                "AAAAAQAAABUAAABHY2xhc3NMb2FkZXJQcm9wZXJ0eQBqYXp6ZXJfaG9uZXlwb3QAamF2YS5sYW5nLlN0cmluZwAvcGF0aC90by9kdW1teUZpbGU=",
                "AAAAAQAAABUAAABWb3JnLmFwYWNoZS5jb21tb25zLmJlYW51dGlscy5CZWFuVXRpbHNCZWFuAGphdmEuaW8uRmlsZQBqYXZhLmxhbmcuU3RyaW5nACIiamF6IisiemVyIiI="
            ]
        }
    ]
}