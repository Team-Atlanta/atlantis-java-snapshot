/**
 * @name API Sinks Analysis
 * @description Identifies API sinks and checks for non-constant arguments or receivers
 * @kind problem
 * @problem.severity warning
 * @id java/api-sinks-analysis
 * @tags security
 */

import java
import semmle.code.java.dataflow.DataFlow
import semmle.code.java.dataflow.ExternalFlow
import semmle.code.java.dataflow.internal.FlowSummaryImpl

/**
 * A sink for various types of API calls that can lead to security vulnerabilities.
 * This includes XPath, command, environment, JNDI, LDAP, path injections,
 * regex uses, request forgery, and SQL injection.
 */
class ApiSink extends DataFlow::Node {
  private string sinkType;

  ApiSink() {
{%- for sink_type in sink_types %}
    sinkType = "{{ sink_type }}" and sinkNode(this, sinkType){% if not loop.last %} or{% endif %}
{%- endfor %}
  }

  /**
   * Gets the sink type for this API sink.
   */
  string getSinkType() {
    result = sinkType
  }

  /**
   * Gets the fully qualified class name for this sink.
   */
  string getClassFQDN() {
    result = this.getEnclosingCallable().getDeclaringType().getQualifiedName()
  }

  /**
   * Gets the method name for this sink.
   */
  string getMethodName() {
    result = this.getEnclosingCallable().getName()
  }

  /**
   * Gets the method signature for better identification.
   */
  string getMethodSignature() {
    exists(Callable c | c = this.getEnclosingCallable() |
      if exists(c.getSignature())
      then
        exists(Type returnType | returnType = c.getReturnType() |
          if returnType instanceof RefType
          then result = returnType.(RefType).getSourceDeclaration().getQualifiedName() + " " + c.getSignature()
          else result = returnType.toString() + " " + c.getSignature()
        )
      else result = "UNKNOWN"
    )
  }

  /**
   * Gets the method descriptor for better identification.
   */
  string getMethodDescriptor() {
    result = this.getEnclosingCallable().getMethodDescriptor()
  }

  /**
   * Checks if this sink has at least one non-constant argument or a non-constant receiver.
   */
  predicate hasNonConstantArgumentOrReceiver() {
    exists(Expr expr | expr = this.asExpr() |
      // Handle method calls
      exists(MethodCall mc | mc = expr |
        // Check if any argument is non-constant
        exists(Expr arg | arg = mc.getAnArgument() | not arg.isCompileTimeConstant()) or
        // Check if receiver/qualifier is non-constant (and exists)
        exists(Expr qualifier | qualifier = mc.getQualifier() | not qualifier.isCompileTimeConstant())
      ) or
      // Handle constructor calls
      exists(ClassInstanceExpr cie | cie = expr |
        // Check if any argument is non-constant
        exists(Expr arg | arg = cie.getAnArgument() | not arg.isCompileTimeConstant())
      ) or
      // Handle field access
      exists(FieldAccess fa | fa = expr |
        // Check if qualifier is non-constant
        exists(Expr qualifier | qualifier = fa.getQualifier() | not qualifier.isCompileTimeConstant())
      ) or
      // Handle array access
      exists(ArrayAccess aa | aa = expr |
        // Check if array or index is non-constant
        not aa.getArray().isCompileTimeConstant() or
        not aa.getIndexExpr().isCompileTimeConstant()
      ) or
      // Handle other expressions - if the expression itself is non-constant
      (not expr.isCompileTimeConstant() and
       not expr instanceof MethodCall and
       not expr instanceof ClassInstanceExpr and
       not expr instanceof FieldAccess and
       not expr instanceof ArrayAccess)
    )
  }

  /**
   * Returns true if this sink has non-constant arguments or receiver, false otherwise.
   */
  boolean hasNonConstantArgumentOrReceiverBoolean() {
    if this.hasNonConstantArgumentOrReceiver()
    then result = true
    else result = false
  }

  /**
   * Gets the sink definition info of this sink.
   */
  QlBuiltins::ExtensionId getMadId() {
    exists(
      string model, string namespace, string type, boolean subtypes, string name, string signature, string ext,
      string originalInput, string provenance, QlBuiltins::ExtensionId madId
    |
      sinkNode(this, sinkType, model) and
      sinkModel(namespace, type, subtypes, name, signature, ext, originalInput, sinkType, provenance, madId) and
      model = "MaD:" + madId.toString() and
      result = madId
    )
  }

  string getModelInfo() {
    exists(string modelInfo | interpretModelForTest(this.getMadId(), modelInfo) |
      result = modelInfo
    )
  }
}



from ApiSink sink
select sink.getLocation(),
       sink.getSinkType() as sink_type,
       sink.hasNonConstantArgumentOrReceiverBoolean() as has_non_constant_args,
       sink.getClassFQDN() as class_name,
       sink.getMethodName() as method_name,
       sink.getMethodSignature() as method_signature,
       sink.getMethodDescriptor() as method_descriptor,
       sink.getLocation().getFile().getBaseName() as file_path,
       sink.getLocation().getStartLine() as line_number,
       sink.getModelInfo() as model_info