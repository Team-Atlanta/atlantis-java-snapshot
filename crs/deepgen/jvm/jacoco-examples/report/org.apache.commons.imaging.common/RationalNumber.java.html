<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RationalNumber.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Coverage Report</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.imaging.common</a> &gt; <span class="el_source">RationalNumber.java</span></div><h1>RationalNumber.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.imaging.common;

import java.text.NumberFormat;

/**
 * Rational number, as used by the TIFF image format.
 * &lt;p&gt;
 * The TIFF format specifies two data types for rational numbers based on a pair of 32-bit integers. Rational is based on unsigned 32-bit integers and SRational
 * is based on signed 32-bit integers. This treatment is problematic in Java because Java does not support unsigned types. To address this challenge, this class
 * stores the numerator and divisor in long (64-bit) integers, applying masks as necessary for the unsigned type.
 */
public class RationalNumber extends Number {

    private static final class Option {
        public static Option factory(final RationalNumber rationalNumber, final double value) {
<span class="nc" id="L32">            return new Option(rationalNumber, Math.abs(rationalNumber.doubleValue() - value));</span>
        }

        public final RationalNumber rationalNumber;

        public final double error;

<span class="nc" id="L39">        private Option(final RationalNumber rationalNumber, final double error) {</span>
<span class="nc" id="L40">            this.rationalNumber = rationalNumber;</span>
<span class="nc" id="L41">            this.error = error;</span>
<span class="nc" id="L42">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L46">            return rationalNumber.toString();</span>
        }
    }

    private static final long serialVersionUID = -1;

    // int-precision tolerance
    private static final double TOLERANCE = 1E-8;
    public static final int SHALLOW_SIZE = 32;

    static RationalNumber factoryMethod(long n, long d) {
        // safer than constructor - handles values outside min/max range.
        // also does some simple finding of common denominators.

<span class="nc bnc" id="L60" title="All 8 branches missed.">        if (n &gt; Integer.MAX_VALUE || n &lt; Integer.MIN_VALUE || d &gt; Integer.MAX_VALUE || d &lt; Integer.MIN_VALUE) {</span>
<span class="nc bnc" id="L61" title="All 12 branches missed.">            while ((n &gt; Integer.MAX_VALUE || n &lt; Integer.MIN_VALUE || d &gt; Integer.MAX_VALUE || d &lt; Integer.MIN_VALUE) &amp;&amp; Math.abs(n) &gt; 1 &amp;&amp; Math.abs(d) &gt; 1) {</span>
                // brutal, imprecise truncation =(
                // use the sign-preserving right shift operator.
<span class="nc" id="L64">                n &gt;&gt;= 1;</span>
<span class="nc" id="L65">                d &gt;&gt;= 1;</span>
            }

<span class="nc bnc" id="L68" title="All 2 branches missed.">            if (d == 0) {</span>
<span class="nc" id="L69">                throw new NumberFormatException(&quot;Invalid value, numerator: &quot; + n + &quot;, divisor: &quot; + d);</span>
            }
        }

<span class="nc" id="L73">        final long gcd = gcd(n, d);</span>
<span class="nc" id="L74">        d /= gcd;</span>
<span class="nc" id="L75">        n /= gcd;</span>

<span class="nc" id="L77">        return new RationalNumber((int) n, (int) d);</span>
    }

    /**
     * Gets the greatest common divisor
     */
    private static long gcd(final long a, final long b) {
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (b == 0) {</span>
<span class="nc" id="L85">            return a;</span>
        }
<span class="nc" id="L87">        return gcd(b, a % b);</span>
    }

    /**
     * Calculate rational number using successive approximations.
     *
     * @param value rational number double value
     * @return the RationalNumber representation of the double value
     */
    public static RationalNumber valueOf(double value) {
<span class="nc bnc" id="L97" title="All 2 branches missed.">        if (value &gt;= Integer.MAX_VALUE) {</span>
<span class="nc" id="L98">            return new RationalNumber(Integer.MAX_VALUE, 1);</span>
        }
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (value &lt;= -Integer.MAX_VALUE) {</span>
<span class="nc" id="L101">            return new RationalNumber(-Integer.MAX_VALUE, 1);</span>
        }

<span class="nc" id="L104">        boolean negative = false;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (value &lt; 0) {</span>
<span class="nc" id="L106">            negative = true;</span>
<span class="nc" id="L107">            value = Math.abs(value);</span>
        }

        RationalNumber l;
        RationalNumber h;

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (value == 0) {</span>
<span class="nc" id="L114">            return new RationalNumber(0, 1);</span>
        }
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (value &gt;= 1) {</span>
<span class="nc" id="L117">            final int approx = (int) value;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (approx &lt; value) {</span>
<span class="nc" id="L119">                l = new RationalNumber(approx, 1);</span>
<span class="nc" id="L120">                h = new RationalNumber(approx + 1, 1);</span>
            } else {
<span class="nc" id="L122">                l = new RationalNumber(approx - 1, 1);</span>
<span class="nc" id="L123">                h = new RationalNumber(approx, 1);</span>
            }
<span class="nc" id="L125">        } else {</span>
<span class="nc" id="L126">            final int approx = (int) (1.0 / value);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">            if (1.0 / approx &lt; value) {</span>
<span class="nc" id="L128">                l = new RationalNumber(1, approx);</span>
<span class="nc" id="L129">                h = new RationalNumber(1, approx - 1);</span>
            } else {
<span class="nc" id="L131">                l = new RationalNumber(1, approx + 1);</span>
<span class="nc" id="L132">                h = new RationalNumber(1, approx);</span>
            }
        }
<span class="nc" id="L135">        Option low = Option.factory(l, value);</span>
<span class="nc" id="L136">        Option high = Option.factory(h, value);</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">        Option bestOption = low.error &lt; high.error ? low : high;</span>

<span class="nc" id="L140">        final int maxIterations = 100; // value is quite high, actually.</span>
                                       // shouldn't matter.
<span class="nc bnc" id="L142" title="All 4 branches missed.">        for (int count = 0; bestOption.error &gt; TOLERANCE &amp;&amp; count &lt; maxIterations; count++) {</span>
<span class="nc" id="L143">            final RationalNumber mediant = RationalNumber.factoryMethod(low.rationalNumber.numerator + high.rationalNumber.numerator,</span>
                    low.rationalNumber.divisor + high.rationalNumber.divisor);
<span class="nc" id="L145">            final Option mediantOption = Option.factory(mediant, value);</span>

<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (value &lt; mediant.doubleValue()) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (high.error &lt;= mediantOption.error) {</span>
<span class="nc" id="L149">                    break;</span>
                }

<span class="nc" id="L152">                high = mediantOption;</span>
            } else {
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (low.error &lt;= mediantOption.error) {</span>
<span class="nc" id="L155">                    break;</span>
                }

<span class="nc" id="L158">                low = mediantOption;</span>
            }

<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (mediantOption.error &lt; bestOption.error) {</span>
<span class="nc" id="L162">                bestOption = mediantOption;</span>
            }
        }

<span class="nc bnc" id="L166" title="All 2 branches missed.">        return negative ? bestOption.rationalNumber.negate() : bestOption.rationalNumber;</span>
    }

    // The TIFF and EXIF specifications call for the use
    // of 32 bit unsigned integers. Since Java does not have an
    // unsigned type, this class widens the type to long in order
    // to avoid unintended negative numbers.
    public final long numerator;

    public final long divisor;

    public final boolean unsignedType;

    /**
     * Constructs an instance based on signed integers
     *
     * @param numerator a 32-bit signed integer
     * @param divisor   a non-zero 32-bit signed integer
     */
<span class="nc" id="L185">    public RationalNumber(final int numerator, final int divisor) {</span>
<span class="nc" id="L186">        this.numerator = numerator;</span>
<span class="nc" id="L187">        this.divisor = divisor;</span>
<span class="nc" id="L188">        this.unsignedType = false;</span>
<span class="nc" id="L189">    }</span>

    /**
     * Constructs an instance supports either signed or unsigned integers.
     *
     * @param numerator    a numerator in the indicated form (signed or unsigned)
     * @param divisor      a non-zero divisor in the indicated form (signed or unsigned)
     * @param unsignedType indicates whether the input values are to be treated as unsigned.
     */
<span class="nc" id="L198">    public RationalNumber(final int numerator, final int divisor, final boolean unsignedType) {</span>
<span class="nc" id="L199">        this.unsignedType = unsignedType;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (unsignedType) {</span>
<span class="nc" id="L201">            this.numerator = numerator &amp; 0xffffffffL;</span>
<span class="nc" id="L202">            this.divisor = divisor &amp; 0xffffffffL;</span>
        } else {
<span class="nc" id="L204">            this.numerator = numerator;</span>
<span class="nc" id="L205">            this.divisor = divisor;</span>
        }
<span class="nc" id="L207">    }</span>

    /**
     * A private constructor for methods such as negate() that create instances of this class using the content of the current instance.
     *
     * @param numerator    a valid numerator
     * @param divisor      a valid denominator
     * @param unsignedType indicates how numerator and divisor values are to be interpreted.
     */
<span class="nc" id="L216">    private RationalNumber(final long numerator, final long divisor, final boolean unsignedType) {</span>
<span class="nc" id="L217">        this.numerator = numerator;</span>
<span class="nc" id="L218">        this.divisor = divisor;</span>
<span class="nc" id="L219">        this.unsignedType = unsignedType;</span>
<span class="nc" id="L220">    }</span>

    @Override
    public double doubleValue() {
<span class="nc" id="L224">        return (double) numerator / (double) divisor;</span>
    }

    @Override
    public float floatValue() {
        // The computation uses double value in order to preserve
        // as much of the precision of the source numerator and denominator
        // as possible. Note that the expression
        // return (float)numerator/(float) denominator
        // could lose precision since a Java float only carries 24 bits
        // of precision while an integer carries 32.
<span class="nc" id="L235">        return (float) doubleValue();</span>
    }

    @Override
    public int intValue() {
<span class="nc" id="L240">        return (int) (numerator / divisor);</span>
    }

    @Override
    public long longValue() {
<span class="nc" id="L245">        return numerator / divisor;</span>
    }

    /**
     * Negates the value of the RationalNumber. If the numerator of this instance has its high-order bit set, then its value is too large to be treated as a
     * Java 32-bit signed integer. In such a case, the only way that a RationalNumber instance can be negated is to divide both terms by a common divisor, if a
     * non-zero common divisor exists. However, if no such divisor exists, there is no numerically correct way to perform the negation. When a negation cannot
     * be performed correctly, this method throws an unchecked exception.
     *
     * @return a valid instance with a negated value.
     */
    public RationalNumber negate() {
<span class="nc" id="L257">        long n = numerator;</span>
<span class="nc" id="L258">        long d = divisor;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (unsignedType) {</span>
            // An instance of an unsigned type can be negated if and only if
            // its high-order bit (the sign bit) is clear. If the bit is set,
            // the value will be too large to convert to a signed type.
            // In such a case it is necessary to adjust the numerator and denominator
            // by their greatest common divisor (gcd), if one exists.
            // If no non-zero common divisor exists, an exception is thrown.
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (n &gt;&gt; 31 == 1) {</span>
                // the unsigned value is so large that the high-order bit is set
                // it cannot be converted to a negative number. Check to see
                // whether there is an option to reduce its magnitude.
<span class="nc" id="L270">                final long g = gcd(numerator, divisor);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (g != 0) {</span>
<span class="nc" id="L272">                    n /= g;</span>
<span class="nc" id="L273">                    d /= g;</span>
                }
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if (n &gt;&gt; 31 == 1) {</span>
<span class="nc" id="L276">                    throw new NumberFormatException(&quot;Unsigned numerator is too large to negate &quot; + numerator);</span>
                }
            }
        }
<span class="nc" id="L280">        return new RationalNumber(-n, d, false);</span>
    }

    public String toDisplayString() {
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (numerator % divisor == 0) {</span>
<span class="nc" id="L285">            return Long.toString(numerator / divisor);</span>
        }
<span class="nc" id="L287">        final NumberFormat nf = NumberFormat.getInstance();</span>
<span class="nc" id="L288">        nf.setMaximumFractionDigits(3);</span>
<span class="nc" id="L289">        return nf.format((double) numerator / (double) divisor);</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (divisor == 0) {</span>
<span class="nc" id="L295">            return &quot;Invalid rational (&quot; + numerator + &quot;/&quot; + divisor + &quot;)&quot;;</span>
        }
<span class="nc" id="L297">        final NumberFormat nf = NumberFormat.getInstance();</span>

<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (numerator % divisor == 0) {</span>
<span class="nc" id="L300">            return nf.format(numerator / divisor);</span>
        }
<span class="nc" id="L302">        return numerator + &quot;/&quot; + divisor + &quot; (&quot; + nf.format((double) numerator / divisor) + &quot;)&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>