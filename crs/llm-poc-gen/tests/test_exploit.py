import asyncio
from unittest.mock import patch

import pytest
from langgraph.graph.state import CompiledGraph

from vuli.agents.exploit import Exploit
from vuli.blobgen import BlobGeneratorResult, BytePoVGenerator, EvaluatorResult
from vuli.model_manager import ModelManager
from vuli.struct import CodeLocation, CodePoint, Sanitizer


@pytest.fixture(autouse=True)
def setup():
    asyncio.run(ModelManager().clear())


@pytest.mark.asyncio
@patch("vuli.cp.CP.get_harness_path")
@patch("vuli.blackboard.Blackboard.add_seed")
@patch("vuli.verifier.DebuggerVerifier.visited_for_path")
@patch("vuli.verifier.DebuggerVerifier.verify")
@patch("vuli.model_manager.ModelManager.invoke_atomic")
@patch("vuli.codereader.BaseReader.read_by_table")
async def test_base(
    read_by_table,
    invoke,
    verify,
    visited_for_path,
    add_seed,
    get_harness_path,
):
    def mock_read_by_table(*args, **kwargs) -> str:
        return """Test.java
21 public static void fuzzTestOneInput(byte[] data) throws Exception {
22     ByteBuffer buf = ByteBuffer.wrap(data);
23     int check = buf.getInt();
24     String whole = new String(Arrays.copyOfRange(data, 4, data.length));
25     if (check != 42) return;
26     ProcessBuilder builder = new ProcessBuilder(whole.split("\0"));
27     builder.start();
28 }"""

    def mock_invoke(*args, **kwargs) -> dict:
        return [
            {
                "blob": b"\x00\x00\x00*jazze",
                "script": """import struct
import sys

def generate_blob(malicious_command):
    # Pack the integer 42 in big-endian format and append the malicious command
    return struct.pack(">i", 42) + malicious_command

if __name__ == "__main__":
    with open(sys.argv[1], "rb") as f:
        command_to_injection = sys.argv[1] # Malicious command from first argument
    output_file_path = sys.argv[2]   # Output file path from second argument
    # Generate the malicious blob
    blob = generate_blob(command_to_inject)

    # Write the blob to the specified file
    with open(output_file_path, "wb") as f:
        f.write(blob)""",
            }
        ]

    def mock_verify(*args, **kwargs) -> tuple[bool, bool]:
        return True

    def mock_visited_for_path(*args, **kwargs) -> list[CodeLocation]:
        return [
            CodeLocation("Test.java", 21),
            CodeLocation("Test.java", 22),
            CodeLocation("Test.java", 23),
            CodeLocation("Test.java", 24),
            CodeLocation("Test.java", 25),
            CodeLocation("Test.java", 26),
            CodeLocation("Test.java", 27),
        ]

    def mock_add_seed(*args, **kwargs) -> None:
        return

    def mock_get_harness_path(*args, **kwargs) -> str:
        return "Test.java"

    read_by_table.side_effect = mock_read_by_table
    invoke.side_effect = mock_invoke
    verify.side_effect = mock_verify
    visited_for_path.side_effect = mock_visited_for_path
    add_seed.side_effect = mock_add_seed
    get_harness_path.side_effect = mock_get_harness_path
    await ModelManager().add_model(
        lambda input, output: input * 1 + output * 1, "mock-model", None
    )
    graph: CompiledGraph = Exploit(BytePoVGenerator()).compile()
    prev: BlobGeneratorResult = BlobGeneratorResult(
        blob=b"\x00\x00\x00\x2aa",
        eval=EvaluatorResult(crash=False, last_visit=4, score=1.0),
        localized=(
            CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
            None,
        ),
        model_name="mock-model",
        script="""import struct
import sys

def generate_blob():
    retrun struct.pack(">i", 42) + "a".encode()

if __name__ == "__main__":
    with open(sys.argv[1], "wb") as f:
        f.write(generate_blob())
""",
        prompt=[],
    )
    result: dict = await graph.ainvoke(
        {
            "code_table": {"Test.java": [(21, 28)]},
            "harness_id": "id_1",
            "path": [
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 21),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 22),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 24),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 26),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
            ],
            "point": "path: Test.java, line: 27, column: 13",
            "prev": prev,
            "sanitizer": Sanitizer("cmdi", ["jazze"]),
        }
    )
    assert result["prev"].localized == (
        CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
        None,
    )
    result["prev"].prompt = []
    assert result["prev"] == BlobGeneratorResult(
        blob=b"\x00\x00\x00\x2ajazze",
        eval=EvaluatorResult(crash=True, last_visit=4, score=1.0),
        localized=(
            CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
            None,
        ),
        model_name="mock-model",
        script="""import struct
import sys

def generate_blob(malicious_command):
    # Pack the integer 42 in big-endian format and append the malicious command
    return struct.pack(">i", 42) + malicious_command

if __name__ == "__main__":
    with open(sys.argv[1], "rb") as f:
        command_to_injection = sys.argv[1] # Malicious command from first argument
    output_file_path = sys.argv[2]   # Output file path from second argument
    # Generate the malicious blob
    blob = generate_blob(command_to_inject)

    # Write the blob to the specified file
    with open(output_file_path, "wb") as f:
        f.write(blob)""",
        prompt=[],
    )
    assert result["crash"] is True


@pytest.mark.asyncio
@patch("vuli.cp.CP.get_harness_path")
@patch("vuli.blackboard.Blackboard.add_seed")
@patch("vuli.verifier.DebuggerVerifier.visited_for_path")
@patch("vuli.verifier.DebuggerVerifier.verify")
@patch("vuli.model_manager.ModelManager.get_all_model_names")
@patch("vuli.model_manager.ModelManager.invoke")
@patch("vuli.codereader.BaseReader.read_by_table")
async def test_failure(
    read_by_table,
    invoke,
    get_all_model_names,
    verify,
    visited_for_path,
    add_seed,
    get_harness_path,
):
    def mock_read_by_table(*args, **kwargs) -> str:
        return """Test.java
21 public static void fuzzTestOneInput(byte[] data) throws Exception {
22     ByteBuffer buf = ByteBuffer.wrap(data);
23     int check = buf.getInt();
24     String whole = new String(Arrays.copyOfRange(data, 4, data.length));
25     if (check != 42) return;
26     ProcessBuilder builder = new ProcessBuilder(whole.split("\0"));
27     builder.start();
28 }"""

    def mock_invoke(*args, **kwargs) -> dict:
        return [
            {
                "blob": b"\x00\x00\x00*hello",
                "script": """import struct
import sys

def generate_blob(malicious_command):
    # Pack the integer 42 in big-endian format and append the malicious command
    return struct.pack(">i", 42) + malicious_command

if __name__ == "__main__":
    with open(sys.argv[1], "rb") as f:
        command_to_injection = sys.argv[1] # Malicious command from first argument
    output_file_path = sys.argv[2]   # Output file path from second argument
    # Generate the malicious blob
    blob = generate_blob(command_to_inject)

    # Write the blob to the specified file
    with open(output_file_path, "wb") as f:
        f.write(blob)""",
            }
        ]

    def mock_get_all_model_names(*args, **kwargs) -> list[str]:
        return ["model_A", "model_B"]

    def mock_verify(*args, **kwargs) -> tuple[bool, bool]:
        return False

    def mock_visited_for_path(*args, **kwargs) -> list[CodeLocation]:
        return [
            CodeLocation("Test.java", 21),
            CodeLocation("Test.java", 22),
            CodeLocation("Test.java", 23),
            CodeLocation("Test.java", 24),
            CodeLocation("Test.java", 25),
        ]

    def mock_add_seed(*args, **kwargs) -> None:
        return

    def mock_get_harness_path(*args, **kwargs) -> str:
        return "Test.java"

    read_by_table.side_effect = mock_read_by_table
    invoke.side_effect = mock_invoke
    get_all_model_names.side_effect = mock_get_all_model_names
    verify.side_effect = mock_verify
    visited_for_path.side_effect = mock_visited_for_path
    add_seed.side_effect = mock_add_seed
    get_harness_path.side_effect = mock_get_harness_path
    await ModelManager().add_model(
        lambda input, output: input * 1 + output * 1, "mock-model", None
    )
    graph: CompiledGraph = Exploit(BytePoVGenerator()).compile()
    prev: BlobGeneratorResult = BlobGeneratorResult(
        blob=b"\x00\x00\x00\x2aa",
        eval=EvaluatorResult(crash=False, last_visit=4, score=1.0),
        localized=(
            CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
            CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
        ),
        model_name="gpt-4.1",
        script="""
import struct
import sys

def generate_blob():
    retrun struct.pack(">i", 42) + "a".encode()

if __name__ == "__main__":
    with open(sys.argv[1], "wb") as f:
        f.write(generate_blob())
""",
        prompt=[],
    )
    result: dict = await graph.ainvoke(
        {
            "blob": b"\x00\x00\x00\x2aa",
            "code_table": {"Test.java": [(21, 28)]},
            "harness_id": "id_1",
            "path": [
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 21),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 22),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 24),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 26),
                CodePoint("Test.java", "Test.fuzzTestOneInput(b[])", 27),
            ],
            "point": "path: Test.java, line: 27, column: 13",
            "prev": prev,
            "sanitizer": Sanitizer("cmdi", ["jazze"]),
        }
    )
    assert result["prev"] == prev
    assert result["crash"] is False
