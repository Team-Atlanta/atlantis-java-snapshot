import asyncio
import copy
import logging
import random
import sys
from collections import defaultdict
from typing import TypedDict

from langchain_core.messages import BaseMessage
from langchain_core.messages.human import HumanMessage
from langchain_core.messages.system import SystemMessage
from langgraph.graph import END, START, StateGraph
from langgraph.graph.state import CompiledGraph

from vuli.agents.parser import JsonParser
from vuli.blobgen import BlobGeneratorResult, PoVGenerator
from vuli.codereader import BaseReader
from vuli.cp import CP
from vuli.model_manager import ModelManager
from vuli.struct import CodePoint, LLMRetriable, Sanitizer


class State(TypedDict):
    code_table: dict
    harness_id: str
    path: list[CodePoint]
    prev: BlobGeneratorResult
    point: str
    sanitizer: Sanitizer
    crash: bool = False
    models: list[str]
    extend: bool = False


class Exploit:
    def __init__(self, generator: PoVGenerator):
        self._logger = logging.getLogger("exploit")
        self._log_prefix: str = ""
        self._generator = generator
        self._reader = BaseReader(CP().source_dir)

    def _log(self, msg: str) -> str:
        if len(self._log_prefix) == 0:
            return msg
        return f"[{self._log_prefix}] {msg}"

    def compile(self) -> CompiledGraph:
        graph = StateGraph(State)
        graph.add_node("prepare", self.prepare)
        graph.add_node("generate_blob", self.generate_blob)
        graph.add_node("extend_code", self.extend_code)
        graph.add_edge(START, "prepare")
        graph.add_edge("prepare", "generate_blob")
        graph.add_conditional_edges(
            "generate_blob", self.need_regenerate, {True: "extend_code", False: END}
        )
        graph.add_edge("extend_code", "generate_blob")
        return graph.compile()

    def prepare(self, state: dict) -> dict:
        if not isinstance(state.get("code_table", None), dict):
            raise RuntimeError("Invalid Input (code_table)")
        if not isinstance(state.get("harness_id", None), str):
            raise RuntimeError("Invalid Input (harness_id)")
        if not isinstance(state.get("path", None), list):
            raise RuntimeError("Invalid Input (path)")
        if not isinstance(state.get("prev", None), BlobGeneratorResult):
            raise RuntimeError("Invalid Input (prev)")
        if not isinstance(state.get("point", None), str):
            raise RuntimeError("Invalid Input (point)")
        if not isinstance(state.get("sanitizer", None), Sanitizer):
            raise RuntimeError("Invalid Input (sanitizer)")

        if len(state.get("models", [])) == 0:
            state["models"] = ModelManager().get_all_model_names()
        else:
            state["models"] = [
                x for x in state["models"] if x in ModelManager().get_all_model_names()
            ]
        self._logger.info(f"Models: {",".join(x for x in state["models"])}")

        state["extend"] = False
        state["crash"] = False
        return state

    async def generate_blob(self, state: dict) -> dict:
        code: str = await BaseReader(CP().source_dir).read_by_table(state["code_table"])
        result: BlobGeneratorResult = await self._generator.generate(
            code,
            state["harness_id"],
            state["models"],
            state["path"],
            state["point"],
            state["prev"],
            state["sanitizer"],
        )
        improve: bool = result.eval.score == 1.0
        if improve:
            state["crash"] = True
            state["prev"] = result
        self._logger.info(f"Summary PoV Generation [pov: {improve}]")
        return state

    def need_regenerate(self, state: dict) -> bool:
        return state["crash"] is False and state["extend"] is False

    async def extend_code(self, state: dict) -> bool:
        self._logger.info("PoV Code Extension Start")
        state["extend"] = True
        models: list[str] = [
            x
            for x in ["gemini-2.5-pro", "o3", "claude-opus-4-20250514"]
            if x in state["models"]
        ]
        if len(models) == 0:
            self._logger.info("No Model. Skip Expand for PoV Generation")
            return state

        messages: list[BaseMessage] = [
            SystemMessage(
                content=f"""Your goal is to generate data blob capable of triggering vulnerability when passed as the first argument of {CP().target_method(state["harness_id"])} within the given code under <CODE> label.
Vulnerability is triggered when maliciously crafted input is reached at ({state["point"]}).
To achieve the goal, please identify all of the essential lines of code for the file listed under the <FILE> label.
Your response must include a JSON format, structured as follows:
```json
[[start_line1, end_line1], [start_line2, end_line2], ...]
```
For example, if lines 3 to 6 and line 8 are required, write it as follows.
```json
[[3, 6], [8, 8]]
```"""
            )
        ]
        code_table: dict[str, list[tuple[int, int]]] = copy.deepcopy(
            state.get("code_table", {})
        )
        path: str = state["path"][-1].path
        code_table[path] = [(1, sys.maxsize)]
        code: str = await BaseReader(CP().source_dir).read_by_table(code_table)
        messages.append(
            HumanMessage(
                content=f"""<FILE>
{path}

<CODE>
{code}"""
            )
        )
        for i in range(0, 3):
            need_to_erase: set[str] = set()
            updated: bool = False
            for model_name in random.sample(models, k=len(models)):
                self._logger.info(f"PoV Extension with {model_name}")
                try:
                    result: dict[str, dict] = {
                        path: await ModelManager().invoke_atomic(
                            messages, model_name, JsonParser()
                        )
                    }
                    state["code_table"] = self.update_code_table(
                        state["code_table"], result
                    )
                    updated = True
                    break
                except LLMRetriable:
                    pass
                except Exception:
                    need_to_erase.add(model_name)
            if updated is True:
                break
            models: list[str] = [x for x in models if x not in need_to_erase]
            if len(models) > 0 and i < 2:
                await asyncio.sleep(60)
        return state

    def update_code_table(self, table_1: dict, table_2: dict) -> dict:
        merged_table: dict = defaultdict(list)

        for table in [table_1, table_2]:
            for path, intervals in table.items():
                merged_table[path].extend(intervals)

        def merge_ranges(ranges: list):
            if not ranges:
                return []

            for i in range(0, len(ranges)):
                if isinstance(ranges[i], tuple):
                    ranges[i] = list(ranges[i])

            ranges = [range for range in ranges if len(range) == 2]
            ranges.sort()
            merged: list = [ranges[0]]

            for current in ranges[1:]:
                last_start, last_end = merged[-1]
                current_start, current_end = current

                if current_start <= last_end:
                    merged[-1] = (last_start, max(last_end, current_end))
                else:
                    merged.append(current)

            return merged

        result: dict = {}
        for path, intervals in merged_table.items():
            result[path] = merge_ranges(intervals)

        return result
