/*
 * Copyright 2025 Code Intelligence GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.code_intelligence.jazzer.driver.directed;

import static com.code_intelligence.jazzer.driver.directed.LogLabel.LOG_ERROR;
import static com.code_intelligence.jazzer.driver.directed.LogLabel.LOG_WARN;

import jakarta.json.bind.Jsonb;
import jakarta.json.bind.JsonbBuilder;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;
import org.gts3.atlantis.staticanalysis.CodeLocation;
import org.gts3.atlantis.staticanalysis.SimpleCodeLocation;
import org.gts3.atlantis.staticanalysis.utils.SignatureUtils;

/**
 * Class representing information about a target loaded from distance files. This encapsulates all
 * the necessary information about a target that is used for directed fuzzing.
 *
 * <p>A FuzzTarget contains details about a specific code location that should be reached during
 * fuzzing, including its method signature, bytecode offset, source file information, and distance
 * metrics that help guide the fuzzer toward this target. This information is typically loaded from
 * distance files generated by the static analysis tool.
 *
 * <p>The class provides methods to access target information and convert it to other
 * representations like {@link org.gts3.atlantis.staticanalysis.CodeLocation}.
 */
public class FuzzTarget {
  private final String methodSignature;
  private final int bytecodeOffset;
  private final String configFilePath;
  private final Map<String, Integer> methodCallDistanceMap;
  private final String fileName;
  private final int lineNumber;
  private final String markDesc;
  private final String className;
  private final String methodName;
  private final String methodDesc;
  private final Map<String, Boolean> anaReachability;
  private final Map<String, Boolean> anaExploitability;
  private final int priority;

  /**
   * Creates a new FuzzTarget instance.
   *
   * @param methodSignature The signature of the target method
   * @param bytecodeOffset The bytecode offset within the method
   * @param configFilePath The path to the file containing the target
   * @param methodCallDistanceMap Map of method signatures to their distances from the target
   * @param fileName The source file name containing the target
   * @param lineNumber The line number of the target in the source file
   * @param markDesc The description of the mark at the target location
   * @param className The name of the class containing the target
   * @param methodName The name of the method containing the target
   * @param methodDesc The descriptor of the method containing the target
   * @param anaReachability Map of harnesses to their reachability status
   * @param anaExploitability Map of harnesses to their exploitability status
   * @param priority Priority flags of the target
   */
  public FuzzTarget(
      String methodSignature,
      int bytecodeOffset,
      String configFilePath,
      Map<String, Integer> methodCallDistanceMap,
      String fileName,
      int lineNumber,
      String markDesc,
      String className,
      String methodName,
      String methodDesc,
      Map<String, Boolean> anaReachability,
      Map<String, Boolean> anaExploitability,
      int priority) {
    this.methodSignature = SignatureUtils.sanitizeMethodSignature(methodSignature);
    this.bytecodeOffset = bytecodeOffset;
    this.configFilePath = configFilePath;
    this.methodCallDistanceMap = methodCallDistanceMap;
    this.fileName = fileName;
    this.lineNumber = lineNumber;
    this.markDesc = markDesc;
    this.className = className;
    this.methodName = methodName;
    this.methodDesc = methodDesc;
    this.anaReachability =
        anaReachability != null ? new HashMap<>(anaReachability) : new HashMap<>();
    this.anaExploitability =
        anaExploitability != null ? new HashMap<>(anaExploitability) : new HashMap<>();
    this.priority = priority;
  }

  /**
   * Creates a new FuzzTarget instance from a distance file.
   *
   * @param distanceFile The distance file to parse
   * @return A list of new FuzzTarget instances
   * @throws IOException If there is an error reading or parsing the file
   */
  public static List<FuzzTarget> fromDistanceFile(File distanceFile) throws IOException {
    String distanceFilePath = distanceFile.getAbsolutePath();

    Jsonb jsonb = JsonbBuilder.create();
    try (Reader reader = new FileReader(distanceFilePath)) {
      Map<String, Object> parsedData = jsonb.fromJson(reader, HashMap.class);

      if (parsedData.keySet().contains("target_data")) {
        // First, try to get mapped methods
        List<String> mappedMethods =
            (List<String>) parsedData.getOrDefault("all_mapped_methods", null);

        // Get all the target data maps
        List<Map<String, Object>> targetData =
            (List<Map<String, Object>>) parsedData.get("target_data");

        // Parse and return
        return targetData.stream()
            .map(t -> fromJsonMap(t, distanceFilePath, mappedMethods))
            .filter(t -> t != null)
            .collect(Collectors.toList());
      } else {
        FuzzTarget fuzzTarget = fromJsonMap(parsedData, distanceFilePath, null);
        return fuzzTarget != null ? Arrays.asList(fuzzTarget) : Collections.emptyList();
      }
    }
  }

  private static FuzzTarget fromJsonMap(
      Map<String, Object> parsedData, String distanceFilePath, List<String> mappedMethods) {
    Map<String, Object> targetLocationData =
        (Map<String, Object>) parsedData.get("target_location");

    Map<String, Integer> methodCallDistanceMapRaw = new HashMap<>();

    Map<String, Map> methodDistanceMap = (Map<String, Map>) parsedData.get("distance_map");
    if (methodDistanceMap != null) {
      for (Map.Entry<String, Map> entry : methodDistanceMap.entrySet()) {
        String methodSignature = SignatureUtils.sanitizeMethodSignature(entry.getKey());
        int distance = ((Number) entry.getValue().get("method_distance")).intValue();
        methodCallDistanceMapRaw.put(methodSignature, distance);
      }
    } else if (mappedMethods != null) {
      // We must rely on the mappedMethods in combination with "all_method_distances"
      List<BigDecimal> allMethodDistances =
          (List<BigDecimal>) parsedData.get("all_method_distances");
      if (mappedMethods.size() != allMethodDistances.size()) {
        System.err.println(
            LOG_ERROR + "Mapped methods and method distance lists have different lengths");
      }

      for (int i = 0; i < Math.min(mappedMethods.size(), allMethodDistances.size()); i++) {
        BigDecimal methodDistance = allMethodDistances.get(i);
        if (methodDistance == null) {
          continue;
        }

        String methodSignature = SignatureUtils.sanitizeMethodSignature(mappedMethods.get(i));
        methodCallDistanceMapRaw.put(methodSignature, methodDistance.intValue());
      }
    }

    if (methodCallDistanceMapRaw.isEmpty()) {
      System.err.println(LOG_WARN + "Unable to generate the methodCallDistanceMap");
      return null;
    }

    return createTargetFromData(targetLocationData, methodCallDistanceMapRaw, distanceFilePath);
  }

  private static FuzzTarget createTargetFromData(
      Map<String, Object> targetLocationData,
      Map<String, Integer> methodCallDistanceMap,
      String configFilePath) {
    Map<String, Object> coord = (Map<String, Object>) targetLocationData.get("coord");

    String targetMethodSignature = (String) coord.get("method_signature");
    int bytecodeOffset = ((Number) coord.get("bytecode_offset")).intValue();

    // We also need the file_name, line_num, and mark_desc
    String fileName = (String) coord.get("file_name");
    int lineNumber = ((Number) coord.get("line_num")).intValue();
    String markDesc = (String) coord.get("mark_desc");

    String className = (String) coord.get("class_name");
    String methodName = (String) coord.get("method_name");
    String methodDesc = (String) coord.get("method_desc");

    // Extract reachability data
    Map<String, Object> anaReachabilityData =
        (Map<String, Object>) targetLocationData.get("ana_reachability");
    Map<String, Boolean> anaReachability =
        anaReachabilityData.entrySet().stream()
            .collect(Collectors.toMap(Map.Entry::getKey, entry -> (Boolean) entry.getValue()));

    // Extract exploitability data
    Map<String, Object> anaExploitabilityData =
        (Map<String, Object>) targetLocationData.get("ana_exploitability");
    Map<String, Boolean> anaExploitability =
        anaExploitabilityData.entrySet().stream()
            .collect(Collectors.toMap(Map.Entry::getKey, entry -> (Boolean) entry.getValue()));

    int priority = 0;
    if (Boolean.TRUE.equals(targetLocationData.getOrDefault("in_diff", false))) {
      priority = Priority.IN_DIFF.getValue();
    }
    if (Boolean.TRUE.equals(targetLocationData.getOrDefault("sarif_target", false))) {
      priority = Priority.SARIF.getValue();
    }
    if (Boolean.TRUE.equals(targetLocationData.getOrDefault("tainted", false))) {
      priority = Priority.TAINTED.getValue();
    }

    return new FuzzTarget(
        targetMethodSignature,
        bytecodeOffset,
        configFilePath,
        methodCallDistanceMap,
        fileName,
        lineNumber,
        markDesc,
        className,
        methodName,
        methodDesc,
        anaReachability,
        anaExploitability,
        priority);
  }

  /**
   * Gets the method signature of the target.
   *
   * @return The method signature
   */
  public String getMethodSignature() {
    return methodSignature;
  }

  /**
   * Gets the bytecode offset of the target within the method.
   *
   * @return The bytecode offset
   */
  public int getBytecodeOffset() {
    return bytecodeOffset;
  }

  /**
   * Gets the file path of the distance file that defined this target.
   *
   * @return The file path
   */
  public String getConfigFilePath() {
    return configFilePath;
  }

  /**
   * Converts this FuzzTarget to a CodeLocation object.
   *
   * <p>This method creates a SimpleCodeLocation instance using the class name, method name, method
   * descriptor, line number, and bytecode offset from this FuzzTarget.
   *
   * @return A CodeLocation representation of this FuzzTarget
   */
  public CodeLocation asCodeLocation() {
    return new SimpleCodeLocation(className, methodName, methodDesc, lineNumber, bytecodeOffset);
  }

  /**
   * Gets the method call distance map for this target.
   *
   * @return Map of method signatures to their distances from the target
   */
  public Map<String, Integer> getMethodCallDistanceMap() {
    return methodCallDistanceMap;
  }

  /**
   * Gets the analysis reachability data for this target.
   *
   * @return Map of analysis variants to their reachability status
   */
  public Map<String, Boolean> getAnaReachability() {
    return new HashMap<>(anaReachability);
  }

  /**
   * Checks if this target is reachable from the specified harness/variant.
   *
   * @param harnessName The name of the harness or analysis variant to check reachability for
   * @return true if the target is reachable from the specified harness, false otherwise
   */
  public boolean reachableFrom(String harnessName) {
    if (harnessName == null || anaReachability == null) {
      return false;
    }
    return anaReachability.getOrDefault(harnessName, false);
  }

  /**
   * Checks if this target is possibly exploitable from the specified harness/variant.
   *
   * @param harnessName The name of the harness or analysis variant to check exploitability for
   * @return true if the target is possibly exploitable from the specified harness, false otherwise
   */
  public boolean exploitableFrom(String harnessName) {
    if (harnessName == null || anaExploitability == null) {
      return true;
    }
    return anaExploitability.getOrDefault(harnessName, true);
  }

  public boolean prioritized() {
    return priority != 0;
  }

  @Override
  public String toString() {
    return "FuzzTarget{"
        + "methodSignature='"
        + methodSignature
        + '\''
        + ", linenumber="
        + lineNumber
        + ", bytecodeOffset="
        + bytecodeOffset
        + ", configFilePath='"
        + configFilePath
        + '\''
        + ", methodCallDistanceMapSize="
        + (methodCallDistanceMap != null ? methodCallDistanceMap.size() : 0)
        + '}';
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    FuzzTarget that = (FuzzTarget) o;
    return bytecodeOffset == that.bytecodeOffset
        && lineNumber == that.lineNumber
        && Objects.equals(methodSignature, that.methodSignature)
        && Objects.equals(configFilePath, that.configFilePath)
        && Objects.equals(className, that.className)
        && Objects.equals(methodName, that.methodName)
        && Objects.equals(methodDesc, that.methodDesc);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        methodSignature,
        bytecodeOffset,
        configFilePath,
        lineNumber,
        className,
        methodName,
        methodDesc);
  }
}
